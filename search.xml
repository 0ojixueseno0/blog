<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>使用Winhex进行数据恢复（索引）</title>
    <url>/posts/1aa64c01.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇将以知识点的形式对所有的数据恢复教程文章进行索引，以便于更快的查找。</p>
<p>直接点击对应的标题即可访问其页面。</p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><h2 id="0-Winhex-数据恢复题库介绍"><a href="#0-Winhex-数据恢复题库介绍" class="headerlink" title="(0)Winhex 数据恢复题库介绍"></a>(0)<a href="/posts/winhex-tiku.html">Winhex 数据恢复题库介绍</a></h2><ul>
<li><a href="https://im0o.top/winhex-tiku/">点击直接打开题库</a></li>
</ul>
<h2 id="1-学习-Winhex-软件的用法"><a href="#1-学习-Winhex-软件的用法" class="headerlink" title="(1)学习 Winhex 软件的用法"></a>(1)<a href="/posts/405d4915.html">学习 Winhex 软件的用法</a></h2><ul>
<li><p>介绍 Winehex</p>
</li>
<li><p>Winhex 的常用快捷键</p>
</li>
<li><p>MBR 主引导记录</p>
</li>
<li><p>Windows 系统的常用分区简述</p>
</li>
</ul>
<h2 id="2-学习-MBR-的恢复方法，了解分区结构"><a href="#2-学习-MBR-的恢复方法，了解分区结构" class="headerlink" title="(2)学习 MBR 的恢复方法，了解分区结构"></a>(2)<a href="/posts/52e8e6fb.html">学习 MBR 的恢复方法，了解分区结构</a></h2><ul>
<li><p>Winhex 窗口使用介绍</p>
</li>
<li><p>实例：填写MBR</p>
</li>
<li><p>什么是 DBR</p>
</li>
<li><p>主分区与扩展分区</p>
</li>
</ul>
<h2 id="3-学习-FAT32-分区结构，手工恢复分区"><a href="#3-学习-FAT32-分区结构，手工恢复分区" class="headerlink" title="(3)学习 FAT32 分区结构，手工恢复分区"></a>(3)<a href="/posts/ea54819e.html">学习 FAT32 分区结构，手工恢复分区</a></h2><ul>
<li><p>FAT32分区构成</p>
</li>
<li><p>实例：导出损坏分区FAT32中的文件</p>
</li>
<li><p>实例：恢复FAT32分区（手动填写FAT32分区的DBR）</p>
</li>
<li><p>EBR的组成</p>
</li>
</ul>
<h2 id="4-学习从底层方法恢复-FAT32-分区中的文件"><a href="#4-学习从底层方法恢复-FAT32-分区中的文件" class="headerlink" title="(4)学习从底层方法恢复 FAT32 分区中的文件"></a>(4)<a href="/posts/7783b927.html">学习从底层方法恢复 FAT32 分区中的文件</a></h2><ul>
<li><p>FAT32 文件系统删除文件的分析</p>
</li>
<li><p>FAT32 文件系统删除文件后目录项起始簇号高位清零的分析</p>
</li>
<li><p>实例：恢复 FAT32 中被删除的文件</p>
</li>
</ul>
<h2 id="5-初步了解-NTFS-分区结构，手工恢复-NTFS-分区的DBR"><a href="#5-初步了解-NTFS-分区结构，手工恢复-NTFS-分区的DBR" class="headerlink" title="(5)初步了解 NTFS 分区结构，手工恢复 NTFS 分区的DBR"></a>(5)<a href="/posts/cf3fde42.html">初步了解 NTFS 分区结构，手工恢复 NTFS 分区的DBR</a></h2><ul>
<li><p>NTFS 文件系统的大致结构</p>
</li>
<li><p>NTFS 文件系统的 DBR 恢复</p>
</li>
<li><p>NTFS 文件系统的元文件 $MFT</p>
</li>
</ul>
<h2 id="6-学习-NTFS-分区的文件记录结构和其中属性的大致结构"><a href="#6-学习-NTFS-分区的文件记录结构和其中属性的大致结构" class="headerlink" title="(6)学习 NTFS 分区的文件记录结构和其中属性的大致结构"></a>(6)<a href="/posts/dd8a71ac.html">学习 NTFS 分区的文件记录结构和其中属性的大致结构</a></h2><ul>
<li>NTFS 分区结构文件记录分析</li>
<li>NTFS 文件记录头的结构</li>
<li>NTFS 文件记录中属性的结构</li>
</ul>
<h2 id="7-学习-NTFS-分区的常见属性的详细结构"><a href="#7-学习-NTFS-分区的常见属性的详细结构" class="headerlink" title="(7)学习 NTFS 分区的常见属性的详细结构"></a>(7)<a href="/posts/653616c9.html">学习 NTFS 分区的常见属性的详细结构</a></h2><ul>
<li>NTFS 文件记录的常见属性</li>
<li>各类文件/文件夹的常用属性</li>
<li>各项属性详解<ul>
<li>10H 属性</li>
<li>30H 属性</li>
<li>80H 属性</li>
<li>90H 属性</li>
<li>A0H 属性</li>
<li>B0H 属性</li>
</ul>
</li>
</ul>
<h2 id="8-计算-NTFS-分区大小，从底层提取文件"><a href="#8-计算-NTFS-分区大小，从底层提取文件" class="headerlink" title="(8)计算 NTFS 分区大小，从底层提取文件"></a>(8)<a href="/posts/3d55069f.html">计算 NTFS 分区大小，从底层提取文件</a></h2><ul>
<li>NTFS 常见元文件分析</li>
<li>多种方法计算 NTFS 分区大小</li>
<li>实例：恢复丢失 DBR 的 NTFS 分区</li>
<li>实例：从 NTFS 分区提取文件</li>
</ul>
<h2 id="9-NTFS-删除文件的底层分析"><a href="#9-NTFS-删除文件的底层分析" class="headerlink" title="(9)NTFS 删除文件的底层分析"></a>(9)<a href="/posts/85e961fa.html">NTFS 删除文件的底层分析</a></h2><ul>
<li>NTFS 删除文件的底层分析</li>
</ul>
<h2 id="10-GPT-磁盘分区，USB-的工作模式"><a href="#10-GPT-磁盘分区，USB-的工作模式" class="headerlink" title="(10)GPT 磁盘分区，USB 的工作模式"></a>(10)<a href="/posts/9907963b.html">GPT 磁盘分区，USB 的工作模式</a></h2><ul>
<li><p>GPT 磁盘分区的特点</p>
</li>
<li><p>GPT 磁盘分区的结构</p>
</li>
<li><p>U盘 的工作模式</p>
<ul>
<li>HDD 模式</li>
<li>FDD 模式</li>
<li>ZIP 模式</li>
</ul>
</li>
</ul>
<h2 id="11-exFAT-分区的基本结构和特点"><a href="#11-exFAT-分区的基本结构和特点" class="headerlink" title="(11)exFAT 分区的基本结构和特点"></a>(11)<a href="/posts/3dd75753.html">exFAT 分区的基本结构和特点</a></h2><ul>
<li>exFAT 文件系统的特点</li>
<li>exFAT 文件系统的结构</li>
<li>exFAT 文件系统的 DBR 分析</li>
</ul>
<h2 id="12-exFAT-文件系统的-FAT-表、簇位图、目录结构"><a href="#12-exFAT-文件系统的-FAT-表、簇位图、目录结构" class="headerlink" title="(12)exFAT 文件系统的 FAT 表、簇位图、目录结构"></a>(12)<a href="/posts/330e5eb0.html">exFAT 文件系统的 FAT 表、簇位图、目录结构</a></h2><ul>
<li>exFAT 分区 FAT 表结构</li>
<li>exFAT 分区 Bitmap 结构</li>
<li>exFAT 分区大写字符文件结构</li>
<li>exFAT 分区目录结构</li>
</ul>
<h2 id="13-恢复-exFAT-分区的-DBR、文件"><a href="#13-恢复-exFAT-分区的-DBR、文件" class="headerlink" title="(13)恢复 exFAT 分区的 DBR、文件"></a>(13)<a href="/posts/8bb239d5.html">恢复 exFAT 分区的 DBR、文件</a></h2><ul>
<li>实例：恢复丢失 DBR 的 exFAT 分区</li>
<li>实例：从 exFAT 分区中提取文件</li>
</ul>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Winhex数据恢复教程</category>
      </categories>
      <tags>
        <tag>Winhex</tag>
        <tag>数据恢复</tag>
      </tags>
  </entry>
  <entry>
    <title>2022年3月25日博客更新记录</title>
    <url>/posts/3723ef87.html</url>
    <content><![CDATA[<h1 id="更换图床"><a href="#更换图床" class="headerlink" title="更换图床"></a>更换图床</h1><p>更新文章 <a href="/posts/fbb2e56c.html">使用 Gitee/Github + PicGo 实现高速稳定图床</a> 提示：</p>
<p>Gitee 疑似使用 302 重定向防盗链，导致图片无法正常显示，blog 全站外链图片更换至 Github + jsdelivr 代替</p>
<blockquote>
<p>估计以后会用 COS 对象存储，不再使用 Gitee/Github 图床…</p>
</blockquote>
<h1 id="添加搜索"><a href="#添加搜索" class="headerlink" title="添加搜索"></a>添加搜索</h1><p>添加本地搜索功能（因为我自己都找不到我自己的文章了…）</p>
<h1 id="优化索引"><a href="#优化索引" class="headerlink" title="优化索引"></a>优化索引</h1><p>顶部索引栏合并~</p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>杂谈/踩坑笔记</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>优化博客</tag>
        <tag>更新记录</tag>
      </tags>
  </entry>
  <entry>
    <title>2021觅食记录</title>
    <url>/posts/ad82a4d2.html</url>
    <content><![CDATA[<p>开篇小Po来存放我在2021年吃过的好吃的哇~</p>
<p>感觉好像流水账哦 hhhh</p>
<h1 id="性价比超高的烤肉-2021-5-4"><a href="#性价比超高的烤肉-2021-5-4" class="headerlink" title="性价比超高的烤肉 2021.5.4"></a>性价比超高的烤肉 2021.5.4</h1><img src="https://image.im0o.top/gitee/img/20220203183227.jpg" alt="1643769150188.jpg" style="zoom: 50%;" />

<p>在学校附近的商场找到了一家人均五十还吃的超级饱超多肉的烤肉店，这一堆都是吃完一大堆肉剩下的，结果是我全部吃完，和我同行的同学完全吃不下了hhhh</p>
<h1 id="自助餐-2021-5-11"><a href="#自助餐-2021-5-11" class="headerlink" title="自助餐 2021.5.11"></a>自助餐 2021.5.11</h1><p><img src="https://image.im0o.top/gitee/img/20220203183222.jpg" alt="1643766876406.jpg"></p>
<p>对应 <a href="/posts/f0df67d7.html">21年5月11日</a> 日记的吃的，那段时间吃了好几顿自助餐hhh 以至于一听到自助餐就 say no.</p>
<h1 id="又是自助餐-2021-5-18"><a href="#又是自助餐-2021-5-18" class="headerlink" title="又是自助餐 2021.5.18"></a>又是自助餐 2021.5.18</h1><p><img src="https://image.im0o.top/gitee/img/20220203183228.jpg" alt="1643769427268.jpg"></p>
<p>又是吃自助餐！这一堆肉都是同行的俩同学拿多了吃不下的，结果又是我全吃了，哼。</p>
<p>怎么能浪费粮食呢！！</p>
<h1 id="麻辣香锅er！-2021-5-21"><a href="#麻辣香锅er！-2021-5-21" class="headerlink" title="麻辣香锅er！ 2021.5.21"></a>麻辣香锅er！ 2021.5.21</h1><p><img src="https://image.im0o.top/gitee/img/20220203183229.jpg"></p>
<p>在苏州比赛期间，第一天到酒店办理入住之后的晚饭。</p>
<h1 id="简单的早餐-2021-5-22"><a href="#简单的早餐-2021-5-22" class="headerlink" title="简单的早餐 2021.5.22"></a>简单的早餐 2021.5.22</h1><p><img src="https://image.im0o.top/gitee/img/20220203183224.jpg" alt="1643768600536.jpg"></p>
<p>在苏州比赛期间入住的苏州纽威丽筠酒店提供的早餐自助。</p>
<p>ahhh~ 那家酒店服务特别好，特别是淋浴室的水温不需要调节就特别适合了，服务也蛮不错的，随便拍照都能出片，太酷了！</p>
<h1 id="还是自助餐-2021-5-22"><a href="#还是自助餐-2021-5-22" class="headerlink" title="还是自助餐 2021.5.22"></a>还是自助餐 2021.5.22</h1><p>当天晚上做轨道交通跑了大老远，结果就吃了个自助，因为是分店，还不如之前吃得好hhh</p>
<img src="https://image.im0o.top/gitee/img/20220203183223.jpg" alt="1643768562032.jpg" style="zoom: 50%;" />

<p>没拍什么照片，放个冰淇淋意思意思吧~ 这家都不能烤肉，果然是分店，啧啧啧。</p>
<h1 id="好多米线哦-2021-5-27"><a href="#好多米线哦-2021-5-27" class="headerlink" title="好多米线哦 2021.5.27"></a>好多米线哦 2021.5.27</h1><p><img src="https://image.im0o.top/gitee/img/20220203183225.jpg" alt="1643768923186.jpg"></p>
<p>当天去了史可法纪念馆，参观结束后一群人跑去商场负一楼吃好吃的，哈哈哈哈哈w</p>
<h1 id="冰淇淋咖啡欸！2021-7-22"><a href="#冰淇淋咖啡欸！2021-7-22" class="headerlink" title="冰淇淋咖啡欸！2021.7.22"></a>冰淇淋咖啡欸！2021.7.22</h1><p>在皮市街里有一家有着两只可爱猫猫的茶吧，在里面点了甜品吃，顺带歇脚~</p>
<p><img src="https://image.im0o.top/gitee/img/20220203183230.jpg" alt="1643770419789.jpg"></p>
<h1 id="芝士火锅-2021-7-22"><a href="#芝士火锅-2021-7-22" class="headerlink" title="芝士火锅 2021.7.22"></a>芝士火锅 2021.7.22</h1><p>晚上在皮市街吃的芝士火锅，说实话量很少，也不咋好吃…</p>
<p><img src="https://image.im0o.top/gitee/img/20220203183226.jpg" alt="1643769045263.jpg"></p>
<p>就颜值高了，哼哼唧唧。</p>
<h1 id="番茄汤超好喝的米线-2021-10-10"><a href="#番茄汤超好喝的米线-2021-10-10" class="headerlink" title="番茄汤超好喝的米线 2021.10.10"></a>番茄汤超好喝的米线 2021.10.10</h1><p><img src="https://image.im0o.top/gitee/img/20220203183231.jpg" alt="1643771244630.jpg"></p>
<p>嗯…其实米线很寡淡，就汤好喝了hhh</p>
<h1 id="同学请客吃烤鱼！2021-10-13"><a href="#同学请客吃烤鱼！2021-10-13" class="headerlink" title="同学请客吃烤鱼！2021.10.13"></a>同学请客吃烤鱼！2021.10.13</h1><p><img src="https://image.im0o.top/gitee/img/20220203183232.jpg" alt="1643771308471.jpg"></p>
<p>同学过18大寿（？ 所以请客吃烤鱼欸~！</p>
<h1 id="薯条自由🍟！2021-10-25"><a href="#薯条自由🍟！2021-10-25" class="headerlink" title="薯条自由🍟！2021.10.25"></a>薯条自由🍟！2021.10.25</h1><p>11元买一送一两个中份，吃了俩中份感觉不够，所以又买了俩中份hhh</p>
<p><img src="https://image.im0o.top/gitee/img/20220203183233.jpg" alt="1643771457589.jpg"></p>
<p>从现在开始就喜欢动不动就往麦当当跑hhhhw</p>
<h1 id="又是薯条自由🍟！-2021-11-9"><a href="#又是薯条自由🍟！-2021-11-9" class="headerlink" title="又是薯条自由🍟！ 2021.11.9"></a>又是薯条自由🍟！ 2021.11.9</h1><p><img src="https://image.im0o.top/gitee/img/20220203183234.jpg" alt="1643771707808.jpg"></p>
<p><img src="https://image.im0o.top/gitee/img/20220203183235.jpg"></p>
<p>当天薅了一个免费吃安格斯的羊毛，是支付宝芝麻Go任务的w</p>
<p>呐呐呐，如果你吃麦当当了，手边有可乐的话，快试试看把盖子中间的吸管孔向下捅一下，然后对着直饮口去吸气…..哈哈哈哈哈哈你真的试了吗？快去整蛊你的朋友吧，这是新大陆啊哈哈哈哈哈哈哈w</p>
<h1 id="寿喜烧！2021-11-15"><a href="#寿喜烧！2021-11-15" class="headerlink" title="寿喜烧！2021.11.15"></a>寿喜烧！2021.11.15</h1><p><img src="https://image.im0o.top/gitee/img/20220203183236.jpg" alt="1643772002863.jpg"></p>
<p>这是一家特别特别难找到的店，经过同学的安利，一块儿去打卡了~</p>
<p>甜甜的牛肉真的太好吃了呜呜呜~</p>
<h1 id="吃个桃桃-2021-11-23"><a href="#吃个桃桃-2021-11-23" class="headerlink" title="吃个桃桃~ 2021.11.23"></a>吃个桃桃~ 2021.11.23</h1><p>想什么呢，就一个普通的甜品hhh</p>
<p><img src="https://image.im0o.top/gitee/img/20220203183237.jpg" alt="1643773277712.jpg"></p>
<h1 id="下午茶-🥤🍰-2021-11-27"><a href="#下午茶-🥤🍰-2021-11-27" class="headerlink" title="下午茶~🥤🍰 2021.11.27"></a>下午茶~🥤🍰 2021.11.27</h1><p><img src="https://image.im0o.top/gitee/img/20220203183238.jpg" alt="1643773393448.jpg"></p>
<p>这家蛋糕便宜又好吃~ 特别适合就着茶当茶点www</p>
<h1 id="🍔板烧自由！2021-12-1"><a href="#🍔板烧自由！2021-12-1" class="headerlink" title="🍔板烧自由！2021.12.1"></a>🍔板烧自由！2021.12.1</h1><p>12月的麦当当真的好多活动喔，在淘宝渠道上看到了15块3个板烧的羊毛，于是就买了一堆板烧，实现了板烧自由！所有的加起来得有三十四个了 hhhhh 虽然不全是我吃啦。</p>
<img src="https://image.im0o.top/gitee/img/20220203183240.jpg" alt="1643775463163.jpg" style="zoom: 80%;" />

<img src="https://image.im0o.top/gitee/img/20220203183239.jpg" alt="1643775452375.jpg" style="zoom: 80%;" />

<h1 id="在罗森经常吃的东西-2021-12-5"><a href="#在罗森经常吃的东西-2021-12-5" class="headerlink" title="在罗森经常吃的东西 2021.12.5"></a>在罗森经常吃的东西 2021.12.5</h1><p>考完二级python（好简单，就走个过场）之后去附近的便利店买了点关东煮的萝卜，一个冰杯，一个青梅绿茶，还有一个饭团，作为午饭了。</p>
<p><img src="https://image.im0o.top/gitee/img/20220203183241.jpg" alt="1643775759077.jpg"></p>
<h1 id="薅汉堡王的羊毛！-2021-12-10"><a href="#薅汉堡王的羊毛！-2021-12-10" class="headerlink" title="薅汉堡王的羊毛！ 2021.12.10"></a>薅汉堡王的羊毛！ 2021.12.10</h1><p>这么多东西实付不到5块欸！太香了，就是汉堡王的点单小程序又卡又烂，用户使用逻辑都不对，坏！</p>
<p><img src="https://image.im0o.top/gitee/img/20220203183242.jpg" alt="1643776725674.jpg"></p>
<h1 id="咖喱咖喱-2021-12-18"><a href="#咖喱咖喱-2021-12-18" class="headerlink" title="咖喱咖喱~ 2021.12.18"></a>咖喱咖喱~ 2021.12.18</h1><p>到这吃饭的前两天在马路对面看到过这家店的名字，叫“柠檬叶”，我们一度认为是卖茶叶的，后来在外卖平台上发现是卖咖喱的。就过来打个卡咯~</p>
<p><img src="https://image.im0o.top/gitee/img/20220203183243.jpg" alt="1643777088048.jpg"></p>
<p><img src="https://image.im0o.top/gitee/img/20220203183244.jpg" alt="1643777116273.jpg"></p>
<p>黄咖喱是我吃的，奶香奶香的，好吃~</p>
<p>绿咖喱有椰子香味~</p>
<h1 id="711！-2021-12-18"><a href="#711！-2021-12-18" class="headerlink" title="711！ 2021.12.18"></a>711！ 2021.12.18</h1><p>我们这儿今年才开的 7-Eleven 便利店，仅有3家，直接就是一个冲进去点关东煮！</p>
<img src="https://image.im0o.top/gitee/img/20220203183245.jpg" alt="1643777125403.jpg" style="zoom: 80%;" />

<p>呜呜呜，对不起，罗森，可是711的萝卜太好吃了…</p>
<h1 id="酸菜鱼欸-2021-12-23"><a href="#酸菜鱼欸-2021-12-23" class="headerlink" title="酸菜鱼欸 2021.12.23"></a>酸菜鱼欸 2021.12.23</h1><p>在南通比赛的第一晚吃的好吃的hhhhhw 有酸菜鱼和其他的菜w</p>
<p><img src="https://image.im0o.top/gitee/img/20220203183247.jpg" alt="1643777458445.jpg"></p>
<p><img src="https://image.im0o.top/gitee/img/20220203183246.jpg" alt="1643777448255.jpg"></p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>年度总结</tag>
        <tag>好吃的</tag>
      </tags>
  </entry>
  <entry>
    <title>小记：拿到第二个国家奖学金</title>
    <url>/posts/faf55402.html</url>
    <content><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>在 2021 年 12 月 21 日，站长拿到了 20-21 学年的国家奖学金，共计 6000 元。</p>
<p>买了台 YOGA 14C hhhhhw。</p>
<h1 id="照片"><a href="#照片" class="headerlink" title="照片"></a>照片</h1><p><img src="https://image.im0o.top/gitee/img/20220123051723.png"></p>
<h1 id="Ps"><a href="#Ps" class="headerlink" title="Ps"></a>Ps</h1><p>封面是oc约的模板图hhh</p>
<p>本文发布日期于2022年1月23日。</p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>奖状</tag>
        <tag>奖学金</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Winhex进行数据恢复（13）</title>
    <url>/posts/8bb239d5.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本节将学习如何从底层恢复 exFAT 分区的 DBR，与如何从底层提取 exFAT 分区中的文件。</p>
<blockquote>
<p><strong>你可以在 <a href="https://im0o.top/winhex-tiku/">https://im0o.top/winhex-tiku/</a> 中查看所有例题文件</strong></p>
</blockquote>
<h1 id="知识点总览"><a href="#知识点总览" class="headerlink" title="知识点总览"></a>知识点总览</h1><ul>
<li>实例：恢复丢失 DBR 的 exFAT 分区</li>
<li>实例：从 exFAT 分区中提取文件</li>
</ul>
<h1 id="实例：恢复丢失-DBR-的-exFAT-分区"><a href="#实例：恢复丢失-DBR-的-exFAT-分区" class="headerlink" title="实例：恢复丢失 DBR 的 exFAT 分区"></a>实例：恢复丢失 DBR 的 exFAT 分区</h1><h2 id="附加虚拟磁盘文件"><a href="#附加虚拟磁盘文件" class="headerlink" title="附加虚拟磁盘文件"></a>附加虚拟磁盘文件</h2><p>导入题目后可以从 <strong>计算机管理 —— 磁盘管理</strong> 中看到该虚拟磁盘显示位 “没有初始化”，其大小为 50GB，均未分配分区，可以初步判断该虚拟磁盘的 MBR（主引导扇区）损坏。</p>
<p><img src="https://image.im0o.top/gitee/img/202112201855170.png" alt="image-20211220185553136"></p>
<h2 id="使用-Winhex-打开虚拟磁盘"><a href="#使用-Winhex-打开虚拟磁盘" class="headerlink" title="使用 Winhex 打开虚拟磁盘"></a>使用 Winhex 打开虚拟磁盘</h2><p>使用 Winhex 打开该虚拟磁盘后可以观察到，主引导扇区损坏，首先填写位于最后两个字节的结束标志 <code>55 AA</code>。</p>
<p><img src="https://image.im0o.top/gitee/img/202112201855826.png" alt="image-20211220185532744"></p>
<h2 id="寻找分区1"><a href="#寻找分区1" class="headerlink" title="寻找分区1"></a>寻找分区1</h2><p><img src="https://image.im0o.top/gitee/img/202112201859212.png" alt="image-20211220185942129"></p>
<p>1 扇区为主引导记录-引导程序的备份。</p>
<p><img src="https://image.im0o.top/gitee/img/202112201900367.png" alt="image-20211220190056330"></p>
<p>从 2 扇区开始，使用快捷键 <code>Ctrl+Alt+x</code> 向下查找 16 进制数值 <code>!00</code>（非零），可以查找到一段数据。</p>
<p><img src="https://image.im0o.top/gitee/img/202112201902702.png" alt="image-20211220190217614"></p>
<p>该数据为 exFAT 分区 DBR 后的数据，继续向后寻找其他数据。</p>
<p>在 75 扇区找到了 exFAT 的 DBR，推测该分区为 exFAT 分区结构，该扇区为该分区 DBR 的备份。</p>
<p><img src="https://image.im0o.top/gitee/img/202112201948150.png" alt="image-20211220194844062"></p>
<p>选中复制整个扇区，向前跳转 12 个扇区，到达 DBR 位置并粘贴。</p>
<p><img src="https://image.im0o.top/gitee/img/202112201955465.png" alt="image-20211220195500362"></p>
<p>读取 BPB 参数，可得分区位置为 <code>00 00 00 00  00 00 00 3F</code> H，分区大小为 <code>00 00 00 00 02 80 48 F5</code> H。</p>
<p>向记事本内填写该分区的参数：</p>
<ul>
<li>分区类型：ex（07）</li>
<li>分区位置：63</li>
<li>分区大小：41,961,717</li>
</ul>
<p><img src="https://image.im0o.top/gitee/img/202112202038456.png" alt="image-20211220203833415"></p>
<h2 id="寻找分区2"><a href="#寻找分区2" class="headerlink" title="寻找分区2"></a>寻找分区2</h2><p>从分区1的 DBR 处向后跳转 41,961,717 个扇区，前往分区2。</p>
<p><img src="https://image.im0o.top/gitee/img/202112202039693.png" alt="image-20211220203935655"></p>
<p><img src="https://image.im0o.top/gitee/img/202112202039303.png" alt="image-20211220203953215"></p>
<p>可以看到该扇区为空，后面有着和分区1的 DBR 后一个扇区相同的数据，初步判断该分区为 exFAT 类型分区。</p>
<p>向后跳转 12 个扇区，查看其备份位置。</p>
<p><img src="https://image.im0o.top/gitee/img/202112202041486.png" alt="image-20211220204103403"></p>
<p>如上图，备份位置为空，可以判断该分区的备份与 DBR 被损坏。</p>
<h2 id="修复-exFAT-分区的-DBR"><a href="#修复-exFAT-分区的-DBR" class="headerlink" title="修复 exFAT 分区的 DBR"></a>修复 exFAT 分区的 DBR</h2><h3 id="需要的数据"><a href="#需要的数据" class="headerlink" title="需要的数据"></a>需要的数据</h3><p>修复 exFAT 分区的 DBR 需要以下数据：</p>
<ul>
<li>跳转指令：<code>EB 76 90</code>（固定值）</li>
<li>OEM代号：<code>EXFAT</code>（ASCII 固定值）</li>
<li>分区位置</li>
<li>分区大小</li>
<li>FAT 表起始扇区号（FAT 表相对 DBR 的位置）</li>
<li>FAT 表大小</li>
<li>簇位图文件起始扇区号（= FAT 表起始扇区号 + FAT表大小）</li>
<li>总簇数</li>
<li>根目录首簇号</li>
<li>每扇区字节数：<code>09</code>（2<sup>9</sup>=512 字节）</li>
<li>每簇扇区数：<code>N</code>（2<sup>N</sup> = 每簇扇区数）</li>
<li>FAT 表个数：<code>01</code>（固定值）</li>
<li>结束标志：<code>55 AA</code>（固定值）</li>
</ul>
<p>首先填写好固定值与分区位置：</p>
<p><img src="https://image.im0o.top/gitee/img/202112202049731.png" alt="image-20211220204933645"></p>
<h3 id="计算-FAT-表偏移位置"><a href="#计算-FAT-表偏移位置" class="headerlink" title="计算 FAT 表偏移位置"></a>计算 FAT 表偏移位置</h3><p>接着向后搜索 <code>F8 FF FF FF</code> 找到 FAT 表。</p>
<p><img src="https://image.im0o.top/gitee/img/202112202051242.png" alt="image-20211220205109199"></p>
<blockquote>
<p>找不到 FAT 表可以向后多次搜索几次，或者打开“偏移计算”</p>
</blockquote>
<p><img src="https://image.im0o.top/gitee/img/202112202051738.png" alt="image-20211220205157640"></p>
<p>用 FAT 表的位置减去分区 DBR 的位置：41963828 - 41961780 = 2,048</p>
<p>将该值填入 DBR 的 BPB参数中：</p>
<p><img src="https://image.im0o.top/gitee/img/202112202054923.png" alt="image-20211220205449871"></p>
<h3 id="计算-FAT-表大小"><a href="#计算-FAT-表大小" class="headerlink" title="计算 FAT 表大小"></a>计算 FAT 表大小</h3><p>向后跳转 2048 扇区，到达 FAT 表位置，在空白处向下搜索 <code>!00</code>，找到 簇位图文件位置。</p>
<p><img src="https://image.im0o.top/gitee/img/202112202056686.png" alt="image-20211220205609545"></p>
<p>用簇位图文件位置减去 FAT 表文件位置得到 FAT 表大小：41972020 - 41963828 = 8,192</p>
<p>将该值填入 BPB 参数中：</p>
<p><img src="https://image.im0o.top/gitee/img/202112202057579.png" alt="image-20211220205753528"></p>
<h3 id="计算簇位图文件偏移位置"><a href="#计算簇位图文件偏移位置" class="headerlink" title="计算簇位图文件偏移位置"></a>计算簇位图文件偏移位置</h3><p>用簇位图文件位置减去分区 DBR 的位置：41972020 - 41961780 = 10,240</p>
<p>将该值填入 BPB 参数中：</p>
<p><img src="https://image.im0o.top/gitee/img/202112202059068.png" alt="image-20211220205951015"></p>
<h3 id="计算每簇扇区数"><a href="#计算每簇扇区数" class="headerlink" title="计算每簇扇区数"></a>计算每簇扇区数</h3><p>在簇位图文件的空白处向下搜索 <code>!00</code> 到大写字符文件处。</p>
<p><img src="https://image.im0o.top/gitee/img/202112202100748.png" alt="image-20211220210057654"></p>
<p>跳转后位置如下图：</p>
<p><img src="https://image.im0o.top/gitee/img/202112202101552.png" alt="image-20211220210115450"></p>
<p>记录大写字符文件位置为：41972276</p>
<p>向后跳转 12 个扇区，到达文件末尾，向下搜索 <code>!00</code> 前往根目录。</p>
<p><img src="https://image.im0o.top/gitee/img/202112202102230.png" alt="image-20211220210255131"></p>
<p>记录根目录位置为：41972340</p>
<p>每簇扇区数为根目录位置 - 大写字符文件位置：41972340 - 41972276 = 64</p>
<p>因为 2<sup>6</sup> = 64，所以在 BPB 中需要填入值 <code>06</code>：</p>
<p><img src="https://image.im0o.top/gitee/img/202112211023121.png" alt="image-20211221102329072"></p>
<h3 id="计算总簇数"><a href="#计算总簇数" class="headerlink" title="计算总簇数"></a>计算总簇数</h3><p>使用 <code>Ctrl+G</code> 快捷键跳转到根目录：41972340</p>
<p><img src="https://image.im0o.top/gitee/img/202112211013650.png" alt="image-20211221101340561"></p>
<p>查看簇位图文件的目录项“81H”，可以得知簇位图文件的大小为 122,824 字节。</p>
<p>用簇位图大小乘8可以得出总簇数： 122,824 * 8 = 982,592。</p>
<p>在 BPB 参数中填入总簇数：982,592。</p>
<p><img src="https://image.im0o.top/gitee/img/202112211024713.png" alt="image-20211221102430665"></p>
<h3 id="计算根目录首簇号"><a href="#计算根目录首簇号" class="headerlink" title="计算根目录首簇号"></a>计算根目录首簇号</h3><p>使用 Ctrl+G 快捷键跳转到根目录：41972340</p>
<p><img src="https://image.im0o.top/gitee/img/202112211032945.png" alt="image-20211221103256905"></p>
<p>查看大写字符文件的目录项“82H”，可以得知大写字符文件所在的簇号为 6 号簇，根目录所在簇号即为 6 + 1 = 7 号簇。</p>
<p>将根目录首簇号填入 BPB 参数：</p>
<p><img src="https://image.im0o.top/gitee/img/202112211035292.png" alt="image-20211221103547249"></p>
<h3 id="计算分区大小"><a href="#计算分区大小" class="headerlink" title="计算分区大小"></a>计算分区大小</h3><p>分区大小为总簇数 * 每簇扇区数：982,592 * 64 = 62,885,888</p>
<p>将分区大小填入 BPB 参数：</p>
<p><img src="https://image.im0o.top/gitee/img/202112211026563.png" alt="image-20211221102648520"></p>
<h3 id="将分区数据计入记事本"><a href="#将分区数据计入记事本" class="headerlink" title="将分区数据计入记事本"></a>将分区数据计入记事本</h3><p>向记事本内填写该分区的参数：</p>
<ul>
<li>分区类型：ex（07）</li>
<li>分区位置：41,961,780</li>
<li>分区大小：62,885,888</li>
</ul>
<p><img src="https://image.im0o.top/gitee/img/202112211027246.png" alt="image-20211221102732209"></p>
<h2 id="填写-MBR-主引导记录"><a href="#填写-MBR-主引导记录" class="headerlink" title="填写 MBR 主引导记录"></a>填写 MBR 主引导记录</h2><p>将记事本中记录的数据填入 MBR 的分区表中并保存：</p>
<p><img src="https://image.im0o.top/gitee/img/202112211028608.png" alt="image-20211221102846562"></p>
<p>在磁盘管理中查看分区情况：</p>
<p><img src="https://image.im0o.top/gitee/img/202112211030224.png" alt="image-20211221103051186"></p>
<p>手动填写的 exFAT 分区无法被 Windows 资源管理器读出，但是可以通过 Winhex 识别到该分区：</p>
<p><img src="https://image.im0o.top/gitee/img/202112211029074.png" alt="image-20211221102926981"></p>
<p>也可以直接双击打开分区 2：</p>
<p><img src="https://image.im0o.top/gitee/img/202112211042996.png" alt="image-20211221104212883"></p>
<p>至此，本题结束。</p>
<h1 id="实例：从-exFAT-分区中提取文件"><a href="#实例：从-exFAT-分区中提取文件" class="headerlink" title="实例：从 exFAT 分区中提取文件"></a>实例：从 exFAT 分区中提取文件</h1><blockquote>
<p>本题的目标文件为：<code>hkl039.png</code></p>
</blockquote>
<h2 id="附加虚拟磁盘文件-1"><a href="#附加虚拟磁盘文件-1" class="headerlink" title="附加虚拟磁盘文件"></a>附加虚拟磁盘文件</h2><p>导入题目后可以从 <strong>计算机管理 —— 磁盘管理</strong> 中看到该虚拟磁盘显示位 “没有初始化”，其大小为 25GB，均未分配分区，可以初步判断该虚拟磁盘的 MBR（主引导扇区）损坏。</p>
<p><img src="https://image.im0o.top/gitee/img/202112211103428.png" alt="image-20211221110353385"></p>
<h2 id="使用-Winhex-打开虚拟磁盘-1"><a href="#使用-Winhex-打开虚拟磁盘-1" class="headerlink" title="使用 Winhex 打开虚拟磁盘"></a>使用 Winhex 打开虚拟磁盘</h2><p><img src="https://image.im0o.top/gitee/img/202112211104889.png" alt="image-20211221110447780"></p>
<p>使用 Winhex 打开该虚拟磁盘何以观察到整个主引导扇区都为空，首先填写 MBR 的结束标志 <code>55 AA</code>，接着向下寻找分区。</p>
<h2 id="寻找分区"><a href="#寻找分区" class="headerlink" title="寻找分区"></a>寻找分区</h2><p><img src="https://image.im0o.top/gitee/img/202112211105787.png" alt="image-20211221110506677"></p>
<p>向下查找 16 进制数值 <code>!00</code>，如图所示，可以判断出这段数据疑似簇位图文件，在空白处继续向下搜索非零。</p>
<p><img src="https://image.im0o.top/gitee/img/202112211105782.png" alt="image-20211221110559667"></p>
<p>由上图可知，我们搜索到了大写字符文件，可以判断该分区为 exFAT 分区，记录大写字符文件的起始位置：10559</p>
<h2 id="计算每簇扇区数-1"><a href="#计算每簇扇区数-1" class="headerlink" title="计算每簇扇区数"></a>计算每簇扇区数</h2><p>向后跳转 12 个扇区，搜索非零，找到根目录：</p>
<p><img src="https://image.im0o.top/gitee/img/202112211107730.png" alt="image-20211221110706604"></p>
<p>记录根目录位置：10623，与大写字符位置相减得出每簇扇区数为：10623 - 10559 = 64。</p>
<h2 id="找到文件的目录项"><a href="#找到文件的目录项" class="headerlink" title="找到文件的目录项"></a>找到文件的目录项</h2><p>使用快捷键 <code>Ctrl+F</code> 向下搜索 Unicode 字符串：<code>hkl039.png</code></p>
<p><img src="https://image.im0o.top/gitee/img/202112211112418.png" alt="image-20211221111239372"></p>
<p><img src="https://image.im0o.top/gitee/img/202112211113687.png" alt="image-20211221111300636"></p>
<p>搜索到了文件 <code>hkl039.png</code> 的目录项。</p>
<p><img src="https://image.im0o.top/gitee/img/202112211117789.png" alt="image-20211221111708733"></p>
<p>查看其文件属性 “C0H”，可以得知该文件的起始簇号为：<code>00 00 00 14</code>H</p>
<p>文件大小为：<code>00 04 55 D8</code> H</p>
<p>转化为十进制后：</p>
<ul>
<li>起始簇号    20</li>
<li>文件大小    284,120</li>
</ul>
<h2 id="计算文件位置"><a href="#计算文件位置" class="headerlink" title="计算文件位置"></a>计算文件位置</h2><p>回到根目录，查看大写字符文件的目录项 “82H” 属性的起始簇号：</p>
<p><img src="https://image.im0o.top/gitee/img/202112211122217.png" alt="image-20211221112247173"></p>
<p><strong>大写字符文件的起始簇号为</strong>：6 号簇</p>
<p>根目录首簇号为 6 + 1 = 7 号簇</p>
<p>当前位于根目录，需要向后跳转 20 - 7 = 13 个簇达到文件数据的起始。</p>
<h2 id="跳转至文件数据区，恢复文件"><a href="#跳转至文件数据区，恢复文件" class="headerlink" title="跳转至文件数据区，恢复文件"></a>跳转至文件数据区，恢复文件</h2><p>使用快捷键 <code>Alt + G</code> 向后跳转 13 * 64 = 832 扇区到达目标文件的数据位置：</p>
<p><img src="https://image.im0o.top/gitee/img/202112211126949.png" alt="image-20211221112609817"></p>
<p>右键文件头，点击“选块起始位置”，向后跳转 284,120 字节，到达文件末尾：</p>
<p><img src="https://image.im0o.top/gitee/img/202112211132914.png" alt="image-20211221112716701"></p>
<p>右键点击“选块尾部”选中整个文件数据：</p>
<p><img src="https://image.im0o.top/gitee/img/202112211127970.png" alt="image-20211221112732932"></p>
<p>右键选块——编辑——复制选块——至新文件：</p>
<p><img src="https://image.im0o.top/gitee/img/202112211130645.png" alt="image-20211221113003588"></p>
<p>将数据另存为一个 png 文件：</p>
<p><img src="https://image.im0o.top/gitee/img/202112211131136.png" alt="image-20211221113112092"></p>
<p>打开文件后没有提示损坏：</p>
<p><img src="https://image.im0o.top/gitee/img/202112211131493.png" alt="image-20211221113134373"></p>
<p>至此，本题结束。</p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Winhex数据恢复教程</category>
      </categories>
      <tags>
        <tag>Winhex</tag>
        <tag>数据恢复</tag>
        <tag>exFAT</tag>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Winhex进行数据恢复（12）</title>
    <url>/posts/330e5eb0.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本节将学习到 exFAT 文件系统的 FAT 表、簇位图、目录结构。</p>
<h1 id="知识点总览"><a href="#知识点总览" class="headerlink" title="知识点总览"></a>知识点总览</h1><ul>
<li>exFAT 分区 FAT 表结构</li>
<li>exFAT 分区 Bitmap 结构</li>
<li>exFAT 分区大写字符文件结构</li>
<li>exFAT 分区目录结构</li>
</ul>
<h1 id="exFAT-分区-FAT-表结构"><a href="#exFAT-分区-FAT-表结构" class="headerlink" title="exFAT 分区 FAT 表结构"></a>exFAT 分区 FAT 表结构</h1><p>FAT（File Allocation Table）即文件分配表，对于ExFAT文件系统来讲也是很重要的一个组成部分，ExFAT文件系统FAT表的功能主要是记录不连续存储的文件的簇链，所以在FAT中看到数值为0的FAT项，并不能说明该FAT项对应的簇是可用簇。</p>
<h2 id="系统是如何定位到-FAT-表的？"><a href="#系统是如何定位到-FAT-表的？" class="headerlink" title="系统是如何定位到 FAT 表的？"></a>系统是如何定位到 FAT 表的？</h2><p>① 从 MBR 的分区表定位到该分区的 DBR 扇区。</p>
<p>② 读取 DBR 的 BPB 参数，主要读取 “ FAT 表起始扇区号” 这个参数，它在 DBR 的 50H~54H 偏移处。</p>
<p>③ 读取到 “FAT 表起始扇区号” 这个参数的值后，跳转到该分区的偏移扇区，这里就是 FAT 表的开始。</p>
<h2 id="FAT-表的实际应用"><a href="#FAT-表的实际应用" class="headerlink" title="FAT 表的实际应用"></a>FAT 表的实际应用</h2><p>把分区格式化为 exFAT 文件系统时，格式化程序会把分配给 FAT 表的第一个扇区清零，然后写入 0 号 FAT 项和 1 号 FAT 项，另外还会写入簇位图文件、大写字符文件及根目录所占簇对应的 FAT 项。</p>
<p><img src="https://image.im0o.top/files/202112200947684.jpeg" alt="ExFAT文件系统的FAT表分析"></p>
<p>由上图可以看出每个 FAT 项占用 4 字节：其中 0 号 FAT 项描述介质类型，其首字节为“F8”，表示介质类型为硬盘；1 号FAT项写入 4 个“FF”；从 2 号 FAT 项开始对应 2 号簇，3 号FAT项对应3号簇，一直到最后一个簇。目前 2、3、4 三个 FAT 项中都是结束标志，说明簇位图文件、大写字符文件、根目录各占一个簇。</p>
<blockquote>
<p>除了这5个FAT项以外，其他FAT项都是0，但这并不能说这些FAT项对应的簇就是空簇。</p>
</blockquote>
<h1 id="exFAT-分区-Bitmap-结构"><a href="#exFAT-分区-Bitmap-结构" class="headerlink" title="exFAT 分区 Bitmap 结构"></a>exFAT 分区 Bitmap 结构</h1><p>ExFAT 文件系统的 FAT 表之后就是数据区了，但数据区并不一定紧跟在 FAT 表之后，FAT 表后面可能还会有一些<strong>保留扇区</strong>，每个分区不一样，这要看实际情况。所以<strong>不能通过 Bitmap 的位置减去 FAT 表的位置直接计算分区大小</strong>。数据区的开始位置在 DBR 的 BPB 中有描述，“首簇起始扇区号”起始就是数据区的开始。数据区中第一个簇就是 2 号簇，2 号簇一般都分配给簇位图文件使用。</p>
<blockquote>
<p>簇位图文件是在分区格式化时创建的，该文件不允许用户访问和修改。</p>
</blockquote>
<p><img src="https://image.im0o.top/files/202112200951733.jpeg" alt="ExFAT文件系统的簇位图文件分析"></p>
<p>上图为一个 exFAT 分区的 Bitmap。</p>
<p>该扇区中只有一个字节“07H”，这就是簇位图文件的内容。</p>
<p>簇位图文件是ExFAT文件系统中的一个元文件，类似于NTFS文件系统中的元文件$BitMap，它的作用是用来<strong>管理分区中簇的使用情况</strong>。簇位图文件中的<strong>每一个位</strong>，映射到数据区中的<strong>每一个簇</strong>。如果某个簇分配给了文件，该簇在簇位图文件中对应的位就会被填入“1”，表示该簇已经占用；如果没用使用的空簇，它们在簇位图文件中对应的位就是“0”。</p>
<h1 id="exFAT-分区大写字符文件结构"><a href="#exFAT-分区大写字符文件结构" class="headerlink" title="exFAT 分区大写字符文件结构"></a>exFAT 分区大写字符文件结构</h1><p>大写字符文件是 exFAT 文件系统中的第二个元文件，类似于NTFS文件系统中的元文件$UpCase。Unicode字母表中每一个字符在这个文件中都有一个对应的条目，用于比较、排序、计算Hash值等方面。</p>
<blockquote>
<p>大写字符文件是在分区格式化时创建的，该文件不允许用户访问和修改。</p>
</blockquote>
<p>簇位图文件结束后的下一个簇一般就分配给大写字符文件使用。</p>
<p><strong>大写字符文件的大小固定为 5836 字节，约为 12 个扇区。</strong></p>
<p>下图为一个大写字符文件的第一个扇区的前半部分。</p>
<p><img src="https://image.im0o.top/files/202112200957633.jpeg" alt="ExFAT文件系统的大写字符文件分析"></p>
<p>从图中可以看到其内容都是Unicode字母表中的字符，每一个字符占用两个字节。</p>
<h1 id="exFAT-分区目录结构"><a href="#exFAT-分区目录结构" class="headerlink" title="exFAT 分区目录结构"></a>exFAT 分区目录结构</h1><p>目录项对于 exFAT 文件系统来讲是非常重要的组成部分，其主要作用及结构特点如下：</p>
<p>① 分区中的每个文件和文件夹（也称为目录）都被分配多个大小为 <strong>32字节</strong> 的目录项，用以描述文件或文件夹的<strong>属性、大小、起始簇号和时间、日期等信息</strong>，当然还会把文件名或目录名也记录在目录项中。</p>
<p>② 在 exFAT 文件系统中，目录也被视为特殊类型的文件，所以<strong>每个目录也与文件一样有目录项</strong>。</p>
<p>③ 在 exFAT 文件系统下，分区根目录下的文件及文件夹的目录项存放在根目录区中，分区<strong>子目录下的文件及文件夹的目录项存放在数据区相应的簇中</strong>。</p>
<p>④ exFAT文件系统目录项的第一个字节用来描述目录项的类型，剩下的31字节用来记录文件的相关信息。</p>
<p>⑤ 根据目录项的作用和结构特点，可以把目录项分为四种类型：</p>
<ul>
<li>卷标目录项</li>
<li>簇位图文件的目录项</li>
<li>大写字符文件的目录项</li>
<li>用户文件的目录项</li>
</ul>
<h2 id="卷标目录项"><a href="#卷标目录项" class="headerlink" title="卷标目录项"></a>卷标目录项</h2><p>卷标就是一个分区的名字，可以在格式化分区时创建，也可以随时修改。ExFAT文件系统把卷标当作文件，用文件目录项进行管理。系统为卷标建一个目录项，放在根目录区中。</p>
<p>卷标的目录项占用32字节，其中第一个字节是特征值，用来描述类型。</p>
<p>卷标目录项的特征值为“83H”，如果没有卷标或者将卷标删除，该特征值为“03H”。</p>
<h3 id="没有卷标的目录项"><a href="#没有卷标的目录项" class="headerlink" title="没有卷标的目录项"></a>没有卷标的目录项</h3><p><img src="https://image.im0o.top/gitee/img/202112201635142.png" alt="image-20211220163515076"></p>
<p>上图为一个没有卷标的 exFAT 类型分区，其特征值为“03H”，占用 32 字节。</p>
<h3 id="有卷标的目录项"><a href="#有卷标的目录项" class="headerlink" title="有卷标的目录项"></a>有卷标的目录项</h3><p>接下来查看有卷标的目录项（M:）：</p>
<p><img src="https://image.im0o.top/gitee/img/202112201642926.png" alt="image-20211220164218881"></p>
<p><img src="https://image.im0o.top/gitee/img/202112201642567.png" alt="image-20211220164201504"></p>
<p>上图为一个有卷标的 exFAT 类型分区，其特征值为“83H”，紧接着标识符后的即为卷标名，共占用 32 字节。</p>
<p>卷标的长度理论上为11字符，但实际上可以达到15字符。</p>
<h3 id="被修改过卷标的目录项"><a href="#被修改过卷标的目录项" class="headerlink" title="被修改过卷标的目录项"></a>被修改过卷标的目录项</h3><p>将上图 “M:” 分区的卷标改为 <code>expart</code> 后从底层查看该属性。</p>
<p><img src="https://image.im0o.top/gitee/img/202112201646962.png" alt="image-20211220164640907"></p>
<p>由上图可以看出，该分区根目录的第一个目录项 “83H” 的内容被修改了。</p>
<p>接下来查看将 “没有卷标的目录项” 改为 “有卷标的目录项”：</p>
<p>将 “N:” 分区的卷标改为 <code>newpart</code> 后从底层查看该属性。</p>
<p><img src="https://image.im0o.top/gitee/img/202112201648084.png" alt="image-20211220164824037"></p>
<p>从根目录可以看出，该分区的第一个目录项还是 “03H”。</p>
<p><img src="https://image.im0o.top/gitee/img/202112201649078.png" alt="image-20211220164906019"></p>
<p>但是在最后一个目录项（改完卷标后没有做任何文件操作）中可以看到一条特征值为 “83H” 的目录项。</p>
<p><img src="https://image.im0o.top/gitee/img/202112201649725.png" alt="image-20211220164946680"></p>
<p>该目录项为刚刚修改的 <code>newpart</code>，再次修改卷标后，只有该目录项变更值。</p>
<h2 id="簇位图文件的目录项"><a href="#簇位图文件的目录项" class="headerlink" title="簇位图文件的目录项"></a>簇位图文件的目录项</h2><p>ExFAT文件系统格式化时会创建一个簇位图文件，并为其建一个目录项，放在根目录区中。</p>
<p>簇位图文件的目录项占用32字节，其中第一个字节是特征值，用来描述类型。簇位图文件目录项的特征值为“81H”。</p>
<p>ExFAT簇位图文件目录项的含义：</p>
<table>
<thead>
<tr>
<th>字节偏移</th>
<th>字段长度（字节）</th>
<th>内容及含义</th>
</tr>
</thead>
<tbody><tr>
<td>0x00</td>
<td>1</td>
<td>目录项的类型（簇位图文件目录项的特征值为“81H”）</td>
</tr>
<tr>
<td>0x01</td>
<td>1</td>
<td>保留</td>
</tr>
<tr>
<td>0x02</td>
<td>18</td>
<td>保留</td>
</tr>
<tr>
<td>0x14</td>
<td>4</td>
<td>起始簇号</td>
</tr>
<tr>
<td>0x18</td>
<td>8</td>
<td>文件大小</td>
</tr>
</tbody></table>
<p>簇位图文件的目录项有如下特点：</p>
<p>①对于ExFAT格式的分区，簇位图文件起始簇号一般都为2。</p>
<p>②簇位图文件的目录项中不记录时间戳。</p>
<p>下图为一个示例分区的簇位图目录项：</p>
<p><img src="https://image.im0o.top/gitee/img/202112201659290.png" alt="image-20211220165914241"></p>
<p>从上图可以看出，该分区的簇位图的起始簇号为：00 00 00 02 H</p>
<p>簇位图的大小为：00 00 D0 12 H (53,266 字节)</p>
<p>故该分区 BPB 参数中的 “分区总簇数” 为 (53266 - 1) * 8 ≈ 426,120</p>
<blockquote>
<p>由于最后一个字节不一定完整表示 8 个簇，为避免误差，则将字节数 - 1，算出来的结果与原总簇号最多误差 8 个簇。</p>
</blockquote>
<h2 id="大写字符文件的目录项"><a href="#大写字符文件的目录项" class="headerlink" title="大写字符文件的目录项"></a>大写字符文件的目录项</h2><p>ExFAT文件系统格式化时会创建一个大写字符文件文件，并为其建一个目录项，放在根目录区中。</p>
<p>大写字符文件的目录项占用32字节，其中第一个字节是特征值，用来描述类型。大写字符文件目录项的特征值为“82H”。</p>
<p>ExFAT大写字符文件目录项的含义：</p>
<table>
<thead>
<tr>
<th>字节偏移</th>
<th>字段长度（字节）</th>
<th>内容及含义</th>
</tr>
</thead>
<tbody><tr>
<td>0x00</td>
<td>1</td>
<td>目录项的类型（大写字符文件目录项的特征值为“82H”）</td>
</tr>
<tr>
<td>0x01</td>
<td>3</td>
<td>保留</td>
</tr>
<tr>
<td>0x08</td>
<td>14</td>
<td>保留</td>
</tr>
<tr>
<td>0x14</td>
<td>4</td>
<td>起始簇号</td>
</tr>
<tr>
<td>0x18</td>
<td>8</td>
<td>文件大小</td>
</tr>
</tbody></table>
<p>大写字符文件的目录项有如下特点：</p>
<p>①对于ExFAT格式的分区，大写字符文件的目录项一般都跟在簇位图文件的目录项之后。</p>
<p>②大写字符文件的目录项中不记录时间戳。</p>
<p>下图为一个示例分区的大写字符文件目录项：</p>
<p><img src="https://image.im0o.top/gitee/img/202112201720109.png" alt="image-20211220172019066"></p>
<p>从上图可以看出，该分区的大写字符文件的起始簇号为：00 00 00 04 H</p>
<p>大写字符文件的大小为：00 00 16 CC H (5,836 字节)</p>
<p>跳转到大写字符文件数据区（4号簇）后查看其扇区位置：</p>
<p><img src="https://image.im0o.top/gitee/img/202112201724416.png" alt="image-20211220172400321"></p>
<p><strong>大写字符的位置为 6,335 号扇区</strong></p>
<p>根目录的数据区在大写字符后一个簇（即5号簇），向下跳转 5836 字节后搜索 <code>!00</code> 到达根目录：</p>
<p><img src="https://image.im0o.top/gitee/img/202112201727337.png" alt="image-20211220172727237"></p>
<p><strong>根目录的位置为 6,399 扇区。</strong></p>
<p>用根目录的位置（5号簇）减去大写字符文件位置（4号簇）可得每簇扇区数为：6399 - 6335 = 64 。</p>
<h2 id="用户文件的目录项"><a href="#用户文件的目录项" class="headerlink" title="用户文件的目录项"></a>用户文件的目录项</h2><p>ExFAT文件系统中每个用户文件至少有三个目录项，这三个目录项被称为三个属性：第一个目录项称为“属性1”，目录项首字节的特征值为“85H”；第二个目录项称为“属性2”，目录项首字节的特征值为“C0H”；第三个目录项称为“属性3”，目录项首字节的特征值为“C1H”。</p>
<h3 id="“属性1”目录项"><a href="#“属性1”目录项" class="headerlink" title="“属性1”目录项"></a>“属性1”目录项</h3><p>“属性1”目录项用来记录该目录项的附属目录项数、校验和、文件属性、时间戳等信息。</p>
<p>用户文件的“属性1”目录项如图所示。</p>
<p><img src="https://image.im0o.top/gitee/img/202112201750840.png" alt="image-20211220175047782"></p>
<p>用户文件的“属性1”目录项的含义</p>
<table>
<thead>
<tr>
<th>字节偏移</th>
<th>字段长度（字节）</th>
<th>内容及含义</th>
</tr>
</thead>
<tbody><tr>
<td>0x00</td>
<td>1</td>
<td>目录项的类型（“属性1”目录项的特征值为“85H”）</td>
</tr>
<tr>
<td>0x01</td>
<td>1</td>
<td>附属目录项数</td>
</tr>
<tr>
<td>0x02</td>
<td>2</td>
<td>校验和</td>
</tr>
<tr>
<td>0x04</td>
<td>4</td>
<td>文件属性</td>
</tr>
<tr>
<td>0x08</td>
<td>4</td>
<td>文件创建时间</td>
</tr>
<tr>
<td>0x0C</td>
<td>4</td>
<td>文件最后修改时间</td>
</tr>
<tr>
<td>0x10</td>
<td>4</td>
<td>文件最后访问时间</td>
</tr>
<tr>
<td>0x14</td>
<td>1</td>
<td>文件创建时间精确至10ms</td>
</tr>
<tr>
<td>0x15</td>
<td>3</td>
<td>保留</td>
</tr>
<tr>
<td>0x18</td>
<td>8</td>
<td>保留</td>
</tr>
</tbody></table>
<p>①0x00～0x00：类型。该参数为目录项类型的特征值，“属性1”目录项的特征值为“85H”。</p>
<p>②0x01～0x01：附属目录项数。该参数指除此目录项外，该文件还有几个目录项，当前值为2，说明这个文件除了“属性1”目录项外，后面还有两个目录项，起始就是“属性2”目录项和“属性3”目录项。</p>
<p>③0x02～0x03：校验和。该参数是校验算法算出来的目录项的校验和。</p>
<p>④0x04～0x07：文件属性。该参数描述文件的常规属性，属性具体含义见下表。</p>
<table>
<thead>
<tr>
<th>二进制值</th>
<th>属性含义</th>
<th>二进制值</th>
<th>属性含义</th>
</tr>
</thead>
<tbody><tr>
<td>00000000</td>
<td>读/写</td>
<td>00001000</td>
<td>卷标</td>
</tr>
<tr>
<td>00000001</td>
<td>只读</td>
<td>00010000</td>
<td>子目录</td>
</tr>
<tr>
<td>00000010</td>
<td>隐藏</td>
<td>00100000</td>
<td>存档</td>
</tr>
<tr>
<td>00000100</td>
<td>系统</td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>⑤0x08～0x0B：文件创建时间。该参数是文件的具体创建时间，格式为32位的DOS时间，包括年、月、日、时、分、秒，具体表示方法与FAT文件系统一样，这里就不再重复讲述。</p>
<p>⑥0x0C～0x0F：文件最后修改时间。该参数是文件最后一次修改时的具体时间，格式为32位的DOS时间，包括年、月、日、时、分、秒，具体表示方法跟FAT文件系统一样，这里就不再重复讲述。</p>
<p>⑦0x10～0x13：文件最后访问时间。该参数是文件最后一次访问时的具体时间，格式为32位的DOS时间，包括年、月、日，也包含时、分、秒，这一点跟FAT不一样，FAT中改时间只有年、月、日，没有时、分、秒。</p>
<p>⑧0x14～0x14：文件创建时间，精确至10ms。该参数是文件的具体创建时间精确到10ms的数值。</p>
<h3 id="“属性2”目录项"><a href="#“属性2”目录项" class="headerlink" title="“属性2”目录项"></a>“属性2”目录项</h3><p>“属性2”目录项用来记录文件是否有碎片、文件名的字符数、文件名的Hash值、文件的起始簇号及大小等信息。</p>
<p>用户文件的“属性2”目录项如图所示。</p>
<p><img src="https://image.im0o.top/gitee/img/202112201801290.png" alt="image-20211220180123226"></p>
<p>用户文件的“属性2”目录项的含义</p>
<table>
<thead>
<tr>
<th>字节偏移</th>
<th>字段长度（字节）</th>
<th>内容及含义</th>
</tr>
</thead>
<tbody><tr>
<td>0x00</td>
<td>1</td>
<td>目录项的类型（“属性2”目录项的特征值为“C0H”）</td>
</tr>
<tr>
<td>0x01</td>
<td>1</td>
<td>文件碎片标志</td>
</tr>
<tr>
<td>0x02</td>
<td>1</td>
<td>保留</td>
</tr>
<tr>
<td>0x03</td>
<td>1</td>
<td>文件名字符数N</td>
</tr>
<tr>
<td>0x04</td>
<td>2</td>
<td>文件名Hash值</td>
</tr>
<tr>
<td>0x06</td>
<td>2</td>
<td>保留</td>
</tr>
<tr>
<td>0x08</td>
<td>8</td>
<td>文件大小1</td>
</tr>
<tr>
<td>0x10</td>
<td>4</td>
<td>保留</td>
</tr>
<tr>
<td>0x14</td>
<td>4</td>
<td>起始簇号</td>
</tr>
<tr>
<td>0x18</td>
<td>8</td>
<td>文件大小2</td>
</tr>
</tbody></table>
<p>①0x00～0x00：类型。该参数为目录项类型的特征值，“属性2”目录项的特征值为“C0H”。</p>
<p>②0x01～0x01：文件碎片标志。该参数能够反映出文件是否连续存放。如果是连续存放没有碎片，该标志为03H；如果不是连续存放，文件有碎片，该标志就为01H。</p>
<p>③0x03～0x03：文件名字符数。该参数用来说明文件名的长度，ExFAT文件系统的文件名用Unicode码表示，每个字符占用两个字节。</p>
<p>④0x04～0x05：文件名Hash值。该参数是根据相应算法算出的文件名的校验值，当文件名发生改变时，Hash值也会发生改变，但当文件移动时，该值并不改变。</p>
<p>⑤0x08～0x0F：文件大小1。该参数是文件的总字节数，用64位记录文件大小。</p>
<p>⑥0x14～0x17：起始簇号。该参数描述文件的起始簇号，用32位记录簇的地址。</p>
<p>⑦0x18～0x1F：文件大小2。该参数也是文件的总字节数，是为NTFS文件系统的压缩属性准备的，一般情况下与“文件大小1”的数值保持一致。</p>
<h3 id="“属性3”目录项"><a href="#“属性3”目录项" class="headerlink" title="“属性3”目录项"></a>“属性3”目录项</h3><p>“属性3”目录项用来具体记录文件的名称。如果文件名很长，“属性3”可以包含多个目录项，每个目录项称为一个片段，从上至下依次记录文件名的每一个字符，记录的方向刚好跟FAT文件系统中长文件名目录项从下至上的顺序相反。</p>
<p><img src="https://image.im0o.top/gitee/img/202112201824374.png" alt="image-20211220182437323"></p>
<p>用户文件的“属性3”目录项的含义</p>
<table>
<thead>
<tr>
<th>字节偏移</th>
<th>字段长度（字节）</th>
<th>内容及含义</th>
</tr>
</thead>
<tbody><tr>
<td>0x00</td>
<td>1</td>
<td>目录项的类型（“属性3”目录项的特征值为“C1H”）</td>
</tr>
<tr>
<td>0x01</td>
<td>1</td>
<td>保留</td>
</tr>
<tr>
<td>0x02</td>
<td>2N</td>
<td>文件名</td>
</tr>
</tbody></table>
<p>因为该文件名很短，所以只有一个片段，如果文件名足够长，则有多个“属性3”（C1H）。</p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Winhex数据恢复教程</category>
      </categories>
      <tags>
        <tag>Winhex</tag>
        <tag>数据恢复</tag>
        <tag>exFAT</tag>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>What2Eat - 吃点啥？</title>
    <url>/posts/76c8cbd5.html</url>
    <content><![CDATA[<h1 id="What-To-Eat-吃点啥儿？"><a href="#What-To-Eat-吃点啥儿？" class="headerlink" title="What To Eat? 吃点啥儿？"></a>What To Eat? 吃点啥儿？</h1><p>这是一个可以决定人类命运的神奇工具，当你在犹豫吃什么的时候，不妨使用 <a href="https://what2eat.im0o.top/">吃点啥儿</a> 帮助你决定你接下来要吃什么吧！</p>
<h2 id="网站截图"><a href="#网站截图" class="headerlink" title="网站截图"></a>网站截图</h2><p><img src="https://image.im0o.top/files/202112161939078.png" alt="image-20211216193957564"></p>
<h2 id="工程说明"><a href="#工程说明" class="headerlink" title="工程说明"></a>工程说明</h2><p>What2Eat(WhatToEat) - 吃点啥儿，是基于 Vue.js 开发，使用 Vercel 服务部署的一个轻量的小工具。</p>
<p>源码开源至 <a href="https://github.com/trash-station/whattoeat">trash-station/whattoeat</a>，欢迎提交图片PR，图片将会通过 Github Actions 使用 Python 脚本自动添加进网站配置。</p>
<p><a href="https://wakatime.com/badge/user/0bba3393-9739-4e92-9fda-c69b3d03d860/project/59b5a7d4-01d3-4613-ae83-b538b0b9a791"><img src="https://wakatime.com/badge/user/0bba3393-9739-4e92-9fda-c69b3d03d860/project/59b5a7d4-01d3-4613-ae83-b538b0b9a791.svg" alt="wakatime"></a></p>
<h2 id="资源来源"><a href="#资源来源" class="headerlink" title="资源来源"></a>资源来源</h2><blockquote>
<p>图片素材来源：</p>
<p>食物图片部分来自 <a href="https://github.com/pcrbot/whattoeat">pcrbot/whattoeat: 今天吃点啥 (github.com)</a></p>
<p>商铺图片部分来自 美团，饿了么 商铺头像</p>
<p>Logo 来源：John Frank Wayre/Helen Rae Cooper</p>
</blockquote>
<h2 id="未来打算"><a href="#未来打算" class="headerlink" title="未来打算"></a>未来打算</h2><p>开放 “吃点啥儿” API，使用 GET 请求可以获取到一张美食图片之类的…</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p><a href="https://what2eat.im0o.top"><img src="https://what2eat.im0o.top/static/what2eat.jpg" /></a></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://what2eat.im0o.top&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://what2eat.im0o.top/static/what2eat.jpg&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>小玩意儿</category>
      </categories>
      <tags>
        <tag>what2eat</tag>
        <tag>html</tag>
        <tag>吃点啥</tag>
        <tag>vue.js</tag>
        <tag>elementui</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Winhex进行数据恢复（11）</title>
    <url>/posts/3dd75753.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本节将学习 exFAT 文件系统的特点、结构及引导扇区。</p>
<div class="note info modern"><p>你可以前往 <a href="https://docs.microsoft.com/zh-cn/windows/win32/fileio/exfat-specification">exFAT 文件系统规范 - Win32 apps | Microsoft Docs</a> 查看 Microsoft 官方对 exFAT 文件系统的描述。</p>
</div>

<h1 id="知识点总览"><a href="#知识点总览" class="headerlink" title="知识点总览"></a>知识点总览</h1><ul>
<li>exFAT 文件系统的特点</li>
<li>exFAT 文件系统的结构</li>
<li>exFAT 文件系统的 DBR 分析</li>
</ul>
<h1 id="exFAT-文件系统的特点"><a href="#exFAT-文件系统的特点" class="headerlink" title="exFAT 文件系统的特点"></a>exFAT 文件系统的特点</h1><blockquote>
<p>本小节多为 exFAT 相关理论，与实操无关，可以跳过本小节。</p>
</blockquote>
<p>exFAT全称为Extended File Allocation Table File System，即扩展文件分配表，是微软在Windows Embeded 6.0（包括Windows CE 6.0、Windows Mobile）中引入的一种适合于闪存的文件系统。</p>
<div class="note modern"><p><strong>exFAT 专为满足当今数字媒体的需求而构建，无论使用何种设备或操作系统，exFAT 均可使用永久性或可移动媒体进行无缝文件传输和存储。</strong></p>
<p>消费者和企业正在创造越来越多的高质量照片、视频和其他数字媒体。 一旦创建，该媒体就需要在多个平台和产品之间存储和共享。 云技术可以简化共享流程，但是在许多应用程序中，可移动存储的便利性是无法替代的。</p>
<p>扩展文件分配表（exFAT）是 Microsoft 专利文件系统。exFAT 可以处理非常大的文件，并可以在使用可移动存储的设备之间进行无缝文件交换，而与设备或操作系统无关。 exFAT 结合了广泛的互操作性和几乎无限规模的文件处理能力，对于寻求有效的文件存储和传输解决方案的公司来说，exFAT 是必不可少的。</p>
<p>exFAT 只是 Microsoft 授予原始设备制造商（OEM）的一项技术，可帮助他们创建<a href="https://www.microsoft.com/mtl-mobile-tablet">移动设备和平板电脑</a>，明天的设备<a href="https://www.microsoft.com/mtl-internet-of-things">物联网</a>。exFAT 还可以用于台式计算机、工业设备、照相机以及许多其他需要互操作文件存储和传输解决方案的设备中。</p>
<p><em>来源：<a href="https://www.microsoft.com/zh-cn/legal/intellectualproperty/mtl/exfat-licensing">exFAT 的许可| Microsoft IP 许可</a></em></p>
</div>

<p>exFAT文件系统跟原来的FAT文件系统相比，主要有以下优点：</p>
<div class="note modern"><ul>
<li>可拓展至更大磁盘大小，理论上64ZiB，推荐最大512TiB，相较32位限制的FAT32分区的2TB（每扇区512字节）。</li>
<li>理论的文件大小限制为264 - 1字节（16 exbibytes - 1），而FAT32文件系统中单一文件限制大小为232 - 1字节（4 GiB）。对于单档超过4 GB的用户来说，exFAT提供了很好的解决方案。</li>
<li><a href="https://zh.wikipedia.org/wiki/%E5%8F%A2%E9%9B%86">簇</a>大小最大可为每<a href="https://zh.wikipedia.org/wiki/%E6%89%87%E5%8C%BA">扇区</a>225字节，最大32 MB。</li>
<li>由于采用了<a href="https://zh.wikipedia.org/w/index.php?title=%E7%A9%BA%E9%A4%98%E7%A9%BA%E9%96%93%E5%B0%8B%E5%9D%80&action=edit&redlink=1">空余空间寻址</a>，空间分配和删除的性能得以改进。</li>
<li>在单一文件夹内支持超过216个文件。</li>
<li>支持<a href="https://zh.wikipedia.org/w/index.php?title=%E5%AD%98%E5%8F%96%E6%8E%A7%E5%88%B6%E6%B8%85%E5%96%AE&action=edit&redlink=1">访问控制清单</a>（但在Windows Vista SP1中尚未支持）。</li>
<li>提供给OEM的可定义参数可以使这个文件系统适应不同特色的设备。</li>
<li>支持<a href="https://zh.wikipedia.org/wiki/%E7%86%B1%E6%8F%92%E6%8B%94">热插拔</a>资料完整无损机制<a href="https://zh.wikipedia.org/wiki/TFAT">Transaction-Safe FAT</a>（TFAT，在<a href="https://zh.wikipedia.org/wiki/WinCE">WinCE</a>中可选的功能）。</li>
<li>时间戳记能够使用<a href="https://zh.wikipedia.org/wiki/UTC">UTC</a>时间而不仅仅是所在<a href="https://zh.wikipedia.org/wiki/%E6%99%82%E5%8D%80">时区</a>（从<a href="https://zh.wikipedia.org/wiki/Windows_Vista#Service_Pack_2">Vista SP2</a>开始）</li>
</ul>
<p><em>来源：<a href="https://zh.wikipedia.org/wiki/ExFAT">exFAT - 维基百科，自由的百科全书 (wikipedia.org)</a></em></p>
</div>

<p>exFAT文件系统跟原来的FAT文件系统相比，主要有以下缺点：</p>
<div class="note modern"><ul>
<li>某些旧设备（如<a href="https://zh.wikipedia.org/wiki/%E4%B8%AA%E4%BA%BA%E6%95%B0%E7%A0%81%E5%8A%A9%E7%90%86">个人数码助理</a>（PDA）和<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E7%A0%81%E7%9B%B8%E6%9C%BA">数字相机</a>）无法使用exFAT格式的存储卡。</li>
<li>使用exFAT的设备将不能用<a href="https://zh.wikipedia.org/wiki/Windows_Vista">Windows Vista</a>的<a href="https://zh.wikipedia.org/wiki/ReadyBoost">ReadyBoost</a>功能。（Windows 7 以上版本中的新的exFAT系统支持<a href="https://zh.wikipedia.org/wiki/ReadyBoost">ReadyBoost</a>）</li>
<li>专利授权方式不明确。夏普、RIM、任天堂分别和微软达成了exFAT授权协议。存在专利费。微软曾经为FAT的一部分申请专利。曾经有用户从三星的Android中分离出不基于FUSE实现的exFAT内核模块代码并按照Linux的GPL协议释放出来，被认为三星得到微软支持下开发的。之后三星也正式释放了相应模块代码。<ul>
<li>2019年8月，微软公开了exFAT的技术文档，并支持将exFAT功能集成到<a href="https://zh.wikipedia.org/wiki/Linux%E5%86%85%E6%A0%B8">Linux内核</a>中。Linux内核将于版本5.4中提供初步支持。</li>
</ul>
</li>
<li>Windows XP SP3之前的旧版Windows暂时不支持exFAT，Windows XP可以安装修改更新KB955704来支持exFAT，Linux操作系统需要通过第三方开发的文件系统驱动来支持exFAT（例如，<a href="https://zh.wikipedia.org/wiki/%E8%B0%B7%E6%AD%8C%E5%85%AC%E5%8F%B8">谷歌公司</a>的exfat工具、FUSE exfat、exfat-nofuse、sdfat），Mac OS X可透过升级至10.6.5来全面支持exFAT。</li>
<li><a href="https://zh.wikipedia.org/wiki/UEFI">UEFI</a>不支持exFAT，只支持<a href="https://zh.wikipedia.org/wiki/FAT">FAT</a>和<a href="https://zh.wikipedia.org/wiki/FAT32">FAT32</a>，格式化为exFAT的EFI启动磁盘将无法被识别。然而现今支持EFI引导安装的主流操作系统，其安装文件都存在单个文件大于4GB的情况（如<a href="https://zh.wikipedia.org/wiki/Windows_10">Windows 10</a>的<code>install.wim</code>、<a href="https://zh.wikipedia.org/wiki/Linux%E5%8F%91%E8%A1%8C%E7%89%88">Linux发行版</a>放置系统文件的<a href="https://zh.wikipedia.org/wiki/SquashFS">SquashFS</a>映像），显然不能再使用<a href="https://zh.wikipedia.org/wiki/FAT">FAT</a>与<a href="https://zh.wikipedia.org/wiki/FAT32">FAT32</a>。</li>
</ul>
<p><em>来源：<a href="https://zh.wikipedia.org/wiki/ExFAT">exFAT - 维基百科，自由的百科全书 (wikipedia.org)</a></em></p>
</div>

<h1 id="exFAT-文件系统的结构"><a href="#exFAT-文件系统的结构" class="headerlink" title="exFAT 文件系统的结构"></a>exFAT 文件系统的结构</h1><p><img src="https://image.im0o.top/files/202112081635821.jpeg" alt="ExFAT文件系统结构总览"></p>
<p>exFAT 文件系统是由 DBR 及其保留扇区、FAT、簇位图文件、大写字符文件、用户数据区五个部分组成。</p>
<p>这些结构是在分区被格式化时创建出来的，它们的含义如下：</p>
<p><strong>① DBR及其保留扇区</strong>。DBR的全称为DOS Boot Record，含义是DOS引导记录，也称为操作系统引导记录。在DBR之后往往有一些保留扇区，其中12号扇区为DBR的备份。</p>
<p><strong>② FAT</strong>。FAT的全称为File Allocation Table，含义是文件分配表。</p>
<blockquote>
<p>ExFAT一般只有一份FAT，而不像FAT文件系统那样有两个FAT表：FAT1和FAT2。</p>
</blockquote>
<p><strong>③ 簇位图文件</strong>。簇位图文件是ExFAT文件系统中的一个元文件，类似于NTFS文件系统中的元文件$BitMap，用来管理分区中簇的使用情况。</p>
<p><strong>④ 大写字符文件</strong>。是ExFAT文件系统中的第二个元文件，类似于NTFS文件系统中的元文件$UpCase，Unicode字母表中每一个字符在这个文件中都有一个对应的条目，用于比较、排序、计算Hash值等方面。</p>
<blockquote>
<p>该文件大小固定为5836字节。</p>
</blockquote>
<p><strong>⑤ 用户数据区</strong>。是ExFAT文件系统的主要区域，用来存放用户的文件及目录。</p>
<h1 id="exFAT-文件系统的-DBR-分析"><a href="#exFAT-文件系统的-DBR-分析" class="headerlink" title="exFAT 文件系统的 DBR 分析"></a>exFAT 文件系统的 DBR 分析</h1><p>ExFAT文件系统的DBR由6部分组成，分别为跳转指令、OEM代号、保留区、BPB参数、引导程序和结束标志。</p>
<p><img src="https://image.im0o.top/files/202112081654172.png" alt="image-20211208165426103"></p>
<p><strong>1．跳转指令</strong></p>
<p>跳转指令本身占用两个字节，它将程序执行流程跳转到引导程序处。例如，当前DBR中的“EB 76”，就是代表汇编语言的“JMP 76”。需要注意该指令本身占用两个字节，计算跳转目标地址时以该指令的下一字节为基准，所以实际执行的下一条指令应该位于78H。紧接着跳转指令的是一条空指令NOP（90H）。</p>
<p><strong>2．OEM代号</strong></p>
<p>这部分占8字节，其内容由创建该文件系统的OEM厂商具体安排。例如，微软的Windows Vista系统将此处设置为文件系统类型“ExFAT”。</p>
<p><strong>3．保留区</strong></p>
<p>从DBR的0BH～3FH处是原来的FAT文件系统BPB所占用的空间，ExFAT文件系统不使用这些字节。</p>
<p><strong>4．BPB（BIOS Parameter Block，BIOS参数块）</strong></p>
<p>ExFAT的BPB从第DBR的40BH偏移处开始，占用56字节，记录了有关该文件系统的重要信息。</p>
<p><img src="https://image.im0o.top/files/202112081829051.jpeg" alt="ExFAT文件系统的DBR分析"></p>
<p>（1）0x40～0x47：隐藏扇区数</p>
<p>隐藏扇区数是指本分区之前使用的扇区数，该值与分区表中所描述的该分区的起始扇区号一致：对于主磁盘分区来讲，是MBR到该分区DBR之间的扇区数；对于扩展分区中的逻辑驱动器来讲，是其EBR到该分区DBR之间的扇区数。</p>
<p>（2）0x48～0x4F：扇区总数</p>
<p>扇区总数是指分区的总扇区数，由8字节组成，也就是64位，所以能管理的最大分区为264×512＝273Byte＝8ZB。微软官方网站提供的信息称：ExFAT理论上最大可以支持64ZB的分区，但从这里只能算出8ZB。</p>
<p>（3）0x50～0x53：FAT起始扇区号</p>
<p>该值为相对于文件系统起始号扇区而言，也就是从DBR到FAT表之间的扇区数。</p>
<p>（4）0x54～0x57：FAT扇区数</p>
<p>是指FAT表包含的扇区数，ExFAT文件系统只有一份FAT表。</p>
<p>（5）0x58～0x5B：首簇起始扇区号</p>
<p>该值用来描述文件系统中的第1个簇的起始扇区号。与传统FAT文件系统一样，ExFAT文件系统的第一个簇也是2号簇，通常2号簇分配给簇位图文件使用，因此，该值也就是簇位图文件的起始扇区号。</p>
<p>（6）0x5C～0x5F：分区内的总簇数</p>
<p>分区内的总簇数是指从分区内第一个簇算起，到分区末尾所包含的簇的总数。</p>
<p>（7）0x60～0x63：根目录首簇号</p>
<p>分区在格式化为ExFAT文件系统时，格式化程序会在数据区中指派一个簇作为ExFAT的根目录区的开始，并把该簇号记录在BPB中。通常分区中的第一个簇被分配给簇位图文件使用，簇位图文件之后是大写字符文件，大写字符文件的下一个簇就根目录的起始位置了。</p>
<p>（8）0x64～0x67：卷序列号</p>
<p>卷序列号是格式化程序在创建文件系统时生成的一组4字节的随机数值。</p>
<p>（9）0x6C～0x6C：每扇区字节数描述</p>
<p>这个字节用来描述每扇区包含的字节数，描述方法为，假设此处值为N，则每扇区大小字节数为2N。例如，本例中该值为“09”，即每扇区大小字节数为29＝512。</p>
<p>（10）0x6D～0x6D：每簇扇区数描述</p>
<p>这个字节用来描述每簇包含的扇区数，描述方法为，假设此处值为N，则每簇扇区数为2N。例如，本例中该值为“06”，即每簇扇区数为26＝64。</p>
<p>ExFAT文件系统能够支持从512B～32MB的簇大小。</p>
<p>5．引导程序</p>
<p>ExFAT的DBR引导程序占用390字节（78H～1FDH）。这部分字节对于ExFAT来说也是很重要的，如果这些数据被破坏，文件系统将无法使用。</p>
<p>6．结束标志</p>
<p>ExFAT的DBR结束标志与FAT的DBR结束标志一样，也是“55 AA”。</p>
<p>在ExFAT的DBR之后还有很多保留扇区，其中12号扇区为DBR的备份，如果DBR遭到破坏，可以用其备份DBR进行修复。</p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Winhex数据恢复教程</category>
      </categories>
      <tags>
        <tag>Winhex</tag>
        <tag>数据恢复</tag>
        <tag>exFAT</tag>
        <tag>文件系统</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Winhex进行数据恢复（10）</title>
    <url>/posts/9907963b.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本节将进行学习 <strong>GPT（GUID Partition Table 全局唯一标识分区表</strong>）与三种U盘的工作模式。</p>
<h1 id="知识点总览"><a href="#知识点总览" class="headerlink" title="知识点总览"></a>知识点总览</h1><ul>
<li><p>GPT 磁盘分区的特点</p>
</li>
<li><p>GPT 磁盘分区的结构</p>
</li>
<li><p>U盘 的工作模式</p>
<ul>
<li>HDD 模式</li>
<li>FDD 模式</li>
<li>ZIP 模式</li>
</ul>
</li>
</ul>
<h1 id="GPT-磁盘分区的特点"><a href="#GPT-磁盘分区的特点" class="headerlink" title="GPT 磁盘分区的特点"></a>GPT 磁盘分区的特点</h1><p>GPT 是 GUID Partition Table 的缩写，其含义为“全局唯一标识磁盘分区表”，GUID 是 “全局唯一标识符（Globally Unique Identifier）”的缩写</p>
<p>GPT 分区有如下特点：</p>
<ol>
<li><p>目前能够支持 GPT 磁盘分区的操作系统有</p>
<table>
<thead>
<tr>
<th align="left">系统名称</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Windows Server 2008 64位 及以后版本</td>
<td></td>
</tr>
<tr>
<td align="left">Windows XP 64 位</td>
<td>无法作为 efi 引导</td>
</tr>
<tr>
<td align="left">Windows 7 64 位 及以后版本</td>
<td></td>
</tr>
<tr>
<td align="left">MacOS X</td>
<td></td>
</tr>
<tr>
<td align="left">Linux</td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>理论上，GPT 磁盘在长度上最大可达 2<sup>64</sup> 个逻辑块，每个逻辑块容量一般为 512 字节，最大分区（磁盘）容量受操作系统版本的影响。Windows XP 和 Windows Server 2003 的原始版本中，每个区物理磁盘的最大容量为 2TB。对于 Windows Server 2003 SPI、Windows XP x64 版本及以后的版本，支持最大原始分区为 18EB。</p>
</li>
<li><p>EFI 规范对分区数量几乎没有限制，但是 Windows 实现限制的分区数量为 128 个。</p>
<blockquote>
<p>与支持最大卷为2 TB（<a href="https://zh.wikipedia.org/wiki/Terabyte">Terabyte</a>s）并且每个磁盘最多有4个主分区（或3个主分区，1个扩展分区和无限制的逻辑驱动器）的MBR磁盘分区的样式相比，<a href="https://zh.wikipedia.org/wiki/GUID%E7%A3%81%E7%A2%9F%E5%88%86%E5%89%B2%E8%A1%A8">GPT</a>磁盘分区样式支持最大为128个分割，一个分割最大18 EB（<a href="https://zh.wikipedia.org/wiki/Exabyte">Exabyte</a>s），只受到操作系统限制（由于分区表本身需要占用一定空间，最初规划硬盘分区时，留给分区表的空间决定了最多可以有多少个分区，<a href="https://zh.wikipedia.org/wiki/IA-64">IA-64</a>版Windows限制最多有128个分区，这也是<a href="https://zh.wikipedia.org/wiki/%E5%8F%AF%E5%BB%B6%E4%BC%B8%E9%9F%8C%E9%AB%94%E4%BB%8B%E9%9D%A2">EFI</a>标准规定的分区表的<strong>最小</strong>尺寸）。与MBR分区的磁盘不同，至关重要的平台操作数据位于分区，而不是位于非分区或隐藏扇区。另外，GPT分区磁盘有备份分区表来提高分区数据结构的完整性。在<a href="https://zh.wikipedia.org/wiki/%E7%B5%B1%E4%B8%80%E5%8F%AF%E5%BB%B6%E4%BC%B8%E9%9F%8C%E9%AB%94%E4%BB%8B%E9%9D%A2">UEFI</a>系统上，通常是通过ESP分区中的EFI应用程序文件启动GPT硬盘上的操作系统，而不是活动主分区上的引导程序。</p>
<p>来源：<a href="https://zh.wikipedia.org/wiki/%E4%B8%BB%E5%BC%95%E5%AF%BC%E8%AE%B0%E5%BD%95">主引导记录 - 维基百科，自由的百科全书 (wikipedia.org)</a></p>
</blockquote>
<p>GPT 中分区表的存储空间大小会限制分区数量。</p>
</li>
<li><p>Windows Server 2008 等操作系统只能在 GPT 磁盘分区上进行数据操作，只有基于 Itanium 的 Windows 系统才能从 GPT 分区上启动。</p>
</li>
<li><p>GPT 和 MBR 结构可以在支持 GPT 的系统上混合使用，但支持 EFI 的系统要求启动分区位于 GPT 磁盘上，另一个硬盘可以是 MBR，也可以是 GPT。</p>
</li>
<li><p>在系统支持的情况下可以将 MBR 磁盘转换为 GPT 磁盘，但是只有在磁盘为空的情况下才可以将 GPT 磁盘转换为 MBR 磁盘，否则会清空所有数据。</p>
</li>
<li><p>GPT 磁盘尾部存有分区表备份。在磁盘的首尾部分存有相同的分区表，当其中一份被破坏后，可以通过另一份进行修复。</p>
</li>
</ol>
<h1 id="GPT-磁盘分区的结构"><a href="#GPT-磁盘分区的结构" class="headerlink" title="GPT 磁盘分区的结构"></a>GPT 磁盘分区的结构</h1><img src="https://image.im0o.top/files/202112071656450.png" alt="img" style="zoom:50%;background-color: white;" />

<div class="note modern"><p>原上传者为<a href="https://en.wikipedia.org/wiki/">英语维基百科</a>的<a href="https://en.wikipedia.org/wiki/User:Kbolino">Kbolino</a> - Transferred from <a href="https://en.wikipedia.org/">en.wikipedia</a> to Commons. Transfer was stated to be made by <a href="https://commons.wikimedia.org/wiki/User:Kbolino">User:Kbolino</a>.</p>
<ul>
<li><a href="https://creativecommons.org/licenses/by-sa/2.5">CC BY-SA 2.5</a></li>
<li>File:GUID Partition Table Scheme.svg</li>
<li>创作时间：2007年1月27日 (原始上传日期)</li>
</ul>
</div>



<p><img src="https://image.im0o.top/files/202112071707942.jpeg" alt="GPT磁盘分区的结构原理"></p>
<h2 id="保护MBR"><a href="#保护MBR" class="headerlink" title="保护MBR"></a>保护MBR</h2><p>保护 MBR 位于 GPT 磁盘的第 1 个扇区，即 0 号扇区，由磁盘签名、MBR 磁盘分区表和结束标志组成，如下图所示。</p>
<p><img src="https://image.im0o.top/files/202112071716694.png" alt="image-20211207171637650"></p>
<h2 id="GPT-头"><a href="#GPT-头" class="headerlink" title="GPT 头"></a>GPT 头</h2><p>GPT 头位于 GPT 磁盘的第 2 个扇区，即 1 号扇区，该磁盘是创建 GPT 磁盘时生成的，GPT 头会定义分区表的起始位置、分区表的结束位置、每个分区表项的大小、分区表项的个数及分区表的校验和等信息，如下图所示。</p>
<p><img src="https://image.im0o.top/files/202112071722452.png" alt="image-20211207172245412"></p>
<p>GPT头中各个参数的含义：</p>
<p><img src="https://image.im0o.top/files/202112071949634.jpeg" alt="GPT磁盘分区的结构原理"></p>
<p>使用模板管理器查看该数值为：</p>
<p><img src="https://image.im0o.top/files/202112071955481.png" alt="image-20211207195504429"></p>
<p>对这些参数具体分析如下。</p>
<p>①00H～07H。长度为8字节，是GPT头的签名，十六进制为“45 46 49 20 50 41 52 54”，ASCII码为“EFI PART”。</p>
<p>②08H～0BH。长度为4字节，表示版本号。</p>
<p>③0CH～0FH。长度为4字节，是GPT头的总字节数，当前值为92，说明GPT头占用92字节。</p>
<p>④10H～13H。长度为4字节，是GPT头的CRC校验和。</p>
<p>⑤14H～17H。长度为4字节，保留不用。</p>
<p>⑥18H～1FH。长度为8字节，表示GPT头所在扇区号，通常为1号扇区，也就是GPT磁盘的第二个扇区。</p>
<p>⑦20H～27H。长度为8字节，是GPT头备份的所在扇区号，也就是GPT磁盘的最后一个扇区，当前值为83,886,079。</p>
<p>⑧28H～2FH。长度为8字节，是GPT分区区域的起始扇区号，当前值为34，GPT分区区域通常都是起始于GPT磁盘的34号扇区。</p>
<p>⑨30H～37H。长度为8字节，是GPT分区区域的结束扇区号，当前值为83,886,046。</p>
<p>⑩38H～47H。长度为16字节，是GPT磁盘的GUID。</p>
<p>⑪ 48H～4FH。长度为8字节，表示GPT分区表的起始扇区号，当前值为2，GPT分区表通常都是起始于GPT磁盘的2号扇区。</p>
<p>⑫50H～53H。长度为4字节，表示分区表项的个数。Windows系统限定GPT分区个数为128，每个分区占用一个分区表项，所以该值为128。</p>
<p>⑬54H～57H。长度为4字节，每个分区表项占用字节数，该值固定为128。</p>
<p>⑭58H～5BH。长度为4字节，是分区表的CRC校验和。</p>
<p>⑮5CH～1FFH。长度为420字节，保留不用。</p>
<h2 id="分区表"><a href="#分区表" class="headerlink" title="分区表"></a>分区表</h2><p>分区表位于GPT磁盘的2～33号扇区，一共占用32个扇区，能够容纳128个分区表项，每个分区表项大小为128字节。因为每个分区表项管理一个分区，所以Windows系统允许GPT磁盘创建128个分区。</p>
<p>每个分区表项中记录着分区的起始和结束地址、分区类型的GUID、分区名字、分区属性和分区GUID。</p>
<p><img src="https://image.im0o.top/files/202112072003930.png" alt="image-20211207200311861"></p>
<p>分区表项中各个参数的含义</p>
<p><img src="https://image.im0o.top/files/202112072003495.jpeg" alt="GPT磁盘分区的结构原理"></p>
<p><img src="https://image.im0o.top/files/202112072004753.png" alt="image-20211207200434684"></p>
<p>对这些参数具体分析如下。</p>
<p>①00H～0FH。长度为16字节，用来描述分区类型，其类型可以是前面提到过的EFI系统分区（ESP）、微软保留分区（MSR）、LDM元数据分区、LDM数据分区、OEM分区、主分区。</p>
<h2 id="GPT头备份"><a href="#GPT头备份" class="headerlink" title="GPT头备份"></a>GPT头备份</h2><p>GPT头有一个备份，放在GPT磁盘的最后一个扇区，但这个GPT头备份并不是GPT头的简单复制，它们的结构虽然一样，但其中的参数却有一些区别。</p>
<p><img src="https://image.im0o.top/files/202112072007452.png" alt="image-20211207200715382"></p>
<p><img src="https://image.im0o.top/files/202112072007499.png" alt="image-20211207200739451"></p>
<p>对这些参数具体分析如下。</p>
<p>①00H～07H。长度为8字节，是GPT头的签名，十六进制为“45 46 49 20 50 41 52 54”，ASCII码为“EFI PART”。</p>
<p>②08H～0BH。长度为4字节，表示版本号。</p>
<p>③0CH～0FH。长度为4字节，是GPT头备份的总字节数。当前值为92，说明GPT头备份占用92字节。</p>
<p>④10H～13H。长度为4字节，是GPT头备份的CRC校验和。</p>
<p>⑤14H～17H。长度为4字节，保留不用。</p>
<p>⑥18H～1FH。长度为8字节，表示GPT头备份所在扇区号，当前值为83,886,079号扇区，也就是GPT磁盘的最后一个扇区。</p>
<p>⑦20H～27H。长度为8字节，是GPT头的所在扇区号，当前值为1号扇区，也就是GPT磁盘的第二个扇区。</p>
<p>⑧28H～2FH。长度为8字节，是GPT分区区域的起始扇区号，当前值为34，GPT分区区域通常都是起始于GPT磁盘的34号扇区。</p>
<p>⑨30H～37H。长度为8字节，是GPT分区区域的结束扇区号，当前值为83,886,046。</p>
<p>⑩38H～47H。长度为16字节，是GPT磁盘的GUID。</p>
<p>⑪ 48H～4FH。长度为8字节，表示GPT分区表备份的起始扇区号，当前值为83,886,047，这也是分区区域结束地址的下一个扇区，GPT分区表备份通常都是起始于GPT磁盘分区区域结束地址的下一个扇区。</p>
<p>⑫50H～53H。长度为4字节，表示分区表项的个数。Windows系统限定GPT分区个数为128，每个分区占用一个分区表项，所以该值为128。</p>
<p>⑬54H～57H。长度为4字节，每个分区表项占用字节数，该值固定为128。</p>
<p>⑭58H～5BH。长度为4字节，是分区表的CRC校验和。</p>
<p>⑮5CH～1FFH。长度为420字节，保留不用。</p>
<h2 id="分区表备份"><a href="#分区表备份" class="headerlink" title="分区表备份"></a>分区表备份</h2><p>分区区域结束后，紧跟着就是分区表的备份，其地址在GPT头备份扇区中有描述。</p>
<p>分区表备份是对分区表32个扇区的完整备份。如果分区表被破坏，系统会自动读取分区表备份，也就能够保证正常地识别分区。</p>
<p>“GPT分区表备份起始扇区号”参数的值就是分区表备份所在的扇区号了。当前值为83,886,047，跳转到该扇区，看到的内容与GPT磁盘的2号扇区中分区表完全一样：</p>
<p><img src="https://image.im0o.top/files/202112072010281.png" alt="image-20211207201016200"></p>
<div class="note modern"><p>Winhex 本身并没有提供GPT磁盘各数据结构的模板，文章中出现的模板为《数据恢复技术深度揭秘（第二版）》中随书附赠的光盘中所提供的。</p>
</div>

<h1 id="U盘的工作模式"><a href="#U盘的工作模式" class="headerlink" title="U盘的工作模式"></a>U盘的工作模式</h1><h2 id="HDD-模式"><a href="#HDD-模式" class="headerlink" title="HDD 模式"></a>HDD 模式</h2><p>将U盘模拟成硬盘模式，现在大多数U盘默认就是这个模式，该模式下多为 MBR 磁盘分区格式，也可以支持 GPT 分区。</p>
<p>在这个模式下，U盘的逻辑数据上与硬盘无差别，可以进行正常分区，支持多个分区（Windows 7及以下的版本无法在资源管理器访问多个分区）。</p>
<p>在 DiskGenius 中查看该模式下磁盘的图表为常规硬盘：</p>
<p><img src="https://image.im0o.top/files/202112081433077.png" alt="image-20211208143325033"></p>
<p>特别注意：如果选择了HDD模式，那么这个启动U盘启动后的盘符是C，在对启动分区进行操作时就容易产生很多问题，比如：装系统时安装程序会把启动文件写到U盘而不是你硬盘的启动分区！导致系统安装失败。所以请尽量先选择ZIP模式；</p>
<h2 id="FDD-模式"><a href="#FDD-模式" class="headerlink" title="FDD 模式"></a>FDD 模式</h2><p>将U盘模拟成软驱模式，这个模式下的分区类型为“无法分区的”磁盘，因为在底层情况下，0 扇区被替换为了分区的DBR。</p>
<p><img src="https://image.im0o.top/files/202112081436827.png" alt="image-20211208143650794"></p>
<p>用 Winhex 打开 FDD 模式下的 U盘（可以是虚拟分区），后可以看到 DBR 位于磁盘的 0 扇区。</p>
<p><img src="https://image.im0o.top/files/202112081432282.png" alt="image-20211208143238168"></p>
<p>在 DiskGenius 中可以看到该模式下磁盘的图标为 FDD 软驱：</p>
<p><img src="https://image.im0o.top/files/202112081431550.png" alt="image-20211208143118488"></p>
<p>这个模式的U盘在一些支持USB-FDD启动的机器上启动时会找不到U盘，所以请酌情使用；</p>
<h2 id="ZIP-模式"><a href="#ZIP-模式" class="headerlink" title="ZIP 模式"></a>ZIP 模式</h2><p>将U盘模拟成 ZIP 驱动器模式，在底层情况下，这种模式使用的是 MBR 磁盘分区格式，其中首个分区的位置在磁盘的 32 号扇区。</p>
<p><img src="https://image.im0o.top/files/202112081438432.png" alt="image-20211208143816350"></p>
<p>在 DiskGenius 中查看该模式下磁盘的图标为 Zip Drive（极碟）：</p>
<p><img src="https://image.im0o.top/files/202112081440069.png" alt="image-20211208144018035"></p>
<p>另外如果U盘容量超过了256M，就只能用HDD模式，小于等于256M可以用ZIP模式。</p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Winhex数据恢复教程</category>
      </categories>
      <tags>
        <tag>数据恢复</tag>
        <tag>GPT</tag>
        <tag>USB 工作模式</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Winhex进行数据恢复（9）</title>
    <url>/posts/85e961fa.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本节将从底层分析 NTFS 删除文件前后的变化。</p>
<h1 id="知识点总览"><a href="#知识点总览" class="headerlink" title="知识点总览"></a>知识点总览</h1><ul>
<li>NTFS 删除文件的底层分析</li>
</ul>
<h1 id="NTFS-删除文件的底层分析"><a href="#NTFS-删除文件的底层分析" class="headerlink" title="NTFS 删除文件的底层分析"></a>NTFS 删除文件的底层分析</h1><p>本例中有一 NTFS 分区，该分区的参数如下图</p>
<p><img src="https://image.im0o.top/files/202112061048313.png" alt="image-20211206104820267"></p>
<h2 id="文件删除前的底层分析"><a href="#文件删除前的底层分析" class="headerlink" title="文件删除前的底层分析"></a>文件删除前的底层分析</h2><p>分区中有两个文件 <code>0.png</code> 和 <code>TextFile.txt</code> 为例，文件如下图所示：</p>
<p><img src="https://image.im0o.top/files/202112061051101.png" alt="image-20211206105155050"></p>
<p><code>0.png</code> 是一个图片文件，该文件的底层参数如下：</p>
<ul>
<li>文件记录</li>
</ul>
<p><img src="https://image.im0o.top/files/202112061054091.png" alt="image-20211206105448987"></p>
<p>文件的数据是由 80H 属性管理的，该文件的 80H 属性如下：</p>
<p><img src="https://image.im0o.top/files/202112061132491.png" alt="image-20211206113237455"></p>
<p>从80H属性中可以看出文件 <code>0.png</code> 的属性体是非常驻的，其 RunList 中只有一个数据流，所以文件是连续的。</p>
<ul>
<li>数据区</li>
</ul>
<p><img src="https://image.im0o.top/files/202112061054637.png" alt="image-20211206105455532"></p>
<p><code>TextFile.txt</code> 是一个文本文件，打开后内容如图所示：</p>
<p><img src="https://image.im0o.top/files/202112061134070.png" alt="image-20211206113417030"></p>
<p>该文件的文件记录为：</p>
<p><img src="https://image.im0o.top/files/202112061135068.png" alt="image-20211206113517002"></p>
<p>从 80H 属性中可以看出，<code>TextFile.txt</code> 的属性体是常驻的。</p>
<p><img src="https://image.im0o.top/files/202112061136750.png" alt="image-20211206113613710"></p>
<p>80H 属性为数据属性，所以其属性体就是这个文件的数据。</p>
<h2 id="文件删除后的底层分析"><a href="#文件删除后的底层分析" class="headerlink" title="文件删除后的底层分析"></a>文件删除后的底层分析</h2><p>为了了解文件删除后恢复的方法，先从文件系统级别了解一下文件删除时在NTFS文件系统中发生的变化。</p>
<p>查看了 <code>0.png</code> 和 <code>TextFile.txt</code> 文件的各部分结构后，现在把此文件彻底删除（不是放入回收站），然后再对其各部分结构进行分析，并讲解恢复的思路。</p>
<p>删除文件后，<code>0.png</code> 的文件记录如下图所示：</p>
<p><img src="https://image.im0o.top/files/202112061142281.png" alt="image-20211206114254208"></p>
<p>从图中可以看出 <code>0.png</code> 的文件记录的状态字节变为了 00 （文件被删除），而其他所有信息都没有被改变。 </p>
<p>跳转到数据区后可以发现该文件的数据区没有改变。</p>
<p><img src="https://image.im0o.top/files/202112070924125.png" alt="image-20211207092426063"></p>
<p><code>TextFile.txt</code> 的文件记录如下图所示：</p>
<p><img src="https://image.im0o.top/files/202112070924523.png" alt="image-20211207092414453"></p>
<p>查看 80H 属性体部分，可以发现文件内容没有被更改，只有状态字节变为了 00 （文件被删除）。</p>
<h2 id="文件删除后的恢复"><a href="#文件删除后的恢复" class="headerlink" title="文件删除后的恢复"></a>文件删除后的恢复</h2><p>将被删除的 <code>0.png</code> 文件的数据区的内容全部选中，并右键选块——编辑——复制选块——至新文件，将文件另存为新的文件，打开后可以看到文件的内容如下图所示：</p>
<p><img src="https://image.im0o.top/files/202112070938368.png" alt="image-20211207093852266"></p>
<p>很显然，这个文件就是被删除的 <code>0.png</code>。</p>
<p>80H 属性为常驻的文件删除后更容易恢复，跳转到 <code>TextFile.txt</code> 的文件记录，选中 80H 属性的属性体部分。</p>
<p><img src="https://image.im0o.top/files/202112070940274.png" alt="image-20211207094056223"></p>
<p>将这个选块另存为一个 txt 文件，打开之后就可以看到内容为原来的 <code>TextFile.txt</code> 文件内容：</p>
<p><img src="https://image.im0o.top/files/202112070942894.png" alt="image-20211207094205853"></p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Winhex数据恢复教程</category>
      </categories>
      <tags>
        <tag>Winhex</tag>
        <tag>数据恢复</tag>
        <tag>NTFS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Winhex进行数据恢复（8）</title>
    <url>/posts/3d55069f.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇将分析 NTFS 分区下常见的元文件与计算分区大小的多种方法。</p>
<blockquote>
<p><strong>你可以在 <a href="https://im0o.top/winhex-tiku/">https://im0o.top/winhex-tiku/</a> 中查看所有例题文件</strong></p>
</blockquote>
<h1 id="知识点总览"><a href="#知识点总览" class="headerlink" title="知识点总览"></a>知识点总览</h1><ul>
<li>NTFS 常见元文件分析</li>
<li>多种方法计算 NTFS 分区大小</li>
<li>实例：恢复丢失 DBR 的 NTFS 分区</li>
<li>实例：从 NTFS 分区提取文件</li>
</ul>
<h1 id="NTFS-常见元文件分析"><a href="#NTFS-常见元文件分析" class="headerlink" title="NTFS 常见元文件分析"></a>NTFS 常见元文件分析</h1><h2 id="元文件-MFTMirr"><a href="#元文件-MFTMirr" class="headerlink" title="元文件 $MFTMirr"></a>元文件 $MFTMirr</h2><p>$MFTMirr 是系统以恢复为目的创建的文件，其内容为元文件 $MFT 的前 4 项记录的备份。</p>
<p>在 NTFS 的每簇扇区数大于 4KB 时，那么 $MFTMirr 文件则备份 $MFT 前一个簇的文件记录，而且是按照文件记录的顺序进行备份的。</p>
<h2 id="元文件-BitMap"><a href="#元文件-BitMap" class="headerlink" title="元文件 $BitMap"></a>元文件 $BitMap</h2><p>元文件 $Bitmap 用来管理卷中簇的使用情况，在簇位图中，每个字节表示8位，对应8个簇（LCN）。</p>
<h2 id="元文件-LogFile"><a href="#元文件-LogFile" class="headerlink" title="元文件 $LogFile"></a>元文件 $LogFile</h2><p>日志文件的数据区由一系列 4KB 大小的日志记录组成，记录头的固定标识是 <code>RCRD</code>，其重启页的头部标志是 <code>RSTR</code>，位于重启区域的开始部分。</p>
<p>在文件被写到磁盘上时会在日志文件中更新文件系统有关的一些数据（如文件创建时间）。日志文件会记录这些操作的成功与失败，在系统故障后第一次进入磁盘时，系统读取日志文件并使其恢复到最后一次操作开始前的状态。恢复时间与磁盘大小无关，只与失败任务的复杂程度有关。</p>
<p>日志文件的数据区位置起始通常在 NTFS 分区的中间部分。</p>
<h3 id="日志文件记录类型"><a href="#日志文件记录类型" class="headerlink" title="日志文件记录类型"></a>日志文件记录类型</h3><p>NTFS 文件系统会为以下事务写入更新记录：</p>
<p>① 创建文件</p>
<p>② 删除文件</p>
<p>③ 扩展（修改）文件</p>
<p>④ 截断文件</p>
<p>⑤ 设置文件信息</p>
<p>⑥ 重命名文件</p>
<p>⑦ 更改应用于文件的安全信息</p>
<h3 id="日志文件的文件记录"><a href="#日志文件的文件记录" class="headerlink" title="日志文件的文件记录"></a>日志文件的文件记录</h3><p>$LogFile 是 $MFT 中的第三个文件记录，其文件记录号为 02H。</p>
<h1 id="多种方法计算-NTFS-分区大小"><a href="#多种方法计算-NTFS-分区大小" class="headerlink" title="多种方法计算 NTFS 分区大小"></a>多种方法计算 NTFS 分区大小</h1><h2 id="通过-LogFile-的文件位置计算"><a href="#通过-LogFile-的文件位置计算" class="headerlink" title="通过 $LogFile 的文件位置计算"></a>通过 $LogFile 的文件位置计算</h2><p><img src="https://image.im0o.top/files/202112021051917.png" alt="image-20211202105110859"></p>
<p>日志文件的数据区位置起始通常在 NTFS <strong>分区的中间部分</strong></p>
<p>所以我们可以通过计算出 $LogFile 相对于 DBR 的位置，再乘2，就能推断出该分区的大致大小。</p>
<p>计算方式：<code>$LogFile的位置(扇区) * 2 = 分区的大致大小</code></p>
<h2 id="通过-BitMap-的文件记录计算"><a href="#通过-BitMap-的文件记录计算" class="headerlink" title="通过 $BitMap 的文件记录计算"></a>通过 $BitMap 的文件记录计算</h2><p>根据簇位图表示分区大小，我们可以从 $BitMap 文件记录的 80H 属性中找到该文件的数据区大小</p>
<p>用 <code>数据区大小（簇数）* 每簇扇区数</code> 可以得到 <code>数据区大小（扇区数）</code></p>
<p>用 <code>数据区大小（扇区数）* 每扇区字节数（512）</code> 可以得到 `数据区大小（字节数）``</p>
<p>由于每个字节有8位，也就可以表示8个簇的使用情况，可以用 <code>数据区大小（字节）* 8</code> 可以得到 <code>分区总簇数</code></p>
<p>用 <code>分区大小（簇数） * 每簇扇区数</code> 即可得出分区的扇区大小</p>
<h2 id="通过-BitMap-的数据区大小计算"><a href="#通过-BitMap-的数据区大小计算" class="headerlink" title="通过 $BitMap 的数据区大小计算"></a>通过 $BitMap 的数据区大小计算</h2><p>在文件记录被破坏等情况下，我们可以直接找到 $BitMap 的数据区，大致估算出数据区大小，再进行上述操作计算出分区大小。</p>
<h1 id="实例：恢复丢失-DBR-的-NTFS-分区"><a href="#实例：恢复丢失-DBR-的-NTFS-分区" class="headerlink" title="实例：恢复丢失 DBR 的 NTFS 分区"></a>实例：恢复丢失 DBR 的 NTFS 分区</h1><h2 id="附加虚拟磁盘文件"><a href="#附加虚拟磁盘文件" class="headerlink" title="附加虚拟磁盘文件"></a>附加虚拟磁盘文件</h2><p>导入题目后可以从 <strong>计算机管理——磁盘管理</strong> 中看到该虚拟磁盘显示位“没有初始化”，其大小为 20GB，均未分配分区，可以初步判断该虚拟磁盘的 MBR（主引导扇区）损坏。</p>
<p><img src="https://image.im0o.top/files/202112021504291.png" alt="image-20211202150436226"></p>
<h2 id="使用-Winhex-打开虚拟磁盘"><a href="#使用-Winhex-打开虚拟磁盘" class="headerlink" title="使用 Winhex 打开虚拟磁盘"></a>使用 Winhex 打开虚拟磁盘</h2><p>使用 Winhex 打开该虚拟磁盘后可以观察到，主引导扇区的分区表及结束标志损坏，故左上角的“分区类型”显示为<code>?</code>，首先填写位于最后两个字节的结束标志 <code>55 AA</code></p>
<p><img src="https://image.im0o.top/files/202112021508631.png" alt="image-20211202150815517"></p>
<h2 id="寻找分区"><a href="#寻找分区" class="headerlink" title="寻找分区"></a>寻找分区</h2><p>从 1 扇区开始，使用快捷键 <code>Ctrl+Alt+x</code> 向下查找16进制数值<code>!00</code>（非零），可以查找到 <code>B O O T M G R</code> 字样，判断出这个扇区为 NTFS 分区中 $Boot 元文件的第二个扇区，第一个扇区即为 DBR。</p>
<p><img src="https://image.im0o.top/files/202112021510788.png" alt="image-20211202151045678"></p>
<p><strong>记录下 DBR 的隐藏扇区数（位置）为 63 扇区。</strong></p>
<h2 id="计算分区大小"><a href="#计算分区大小" class="headerlink" title="计算分区大小"></a>计算分区大小</h2><p>通常情况下,$MFT 的位置位于该分区起始处向后偏移 <code>786432</code> 簇，每簇扇区数通常为 <code>8</code> 扇区/簇，换算成扇区数为 <code>6291456</code> 扇区。</p>
<p>本次计算使用“通过 $BitMap 的文件记录计算分区大小”方法。</p>
<p>向后跳转 <code>6291456</code> 个扇区，到达 $MFT。</p>
<p><img src="https://image.im0o.top/files/202112021514168.png" alt="image-20211202151421126"></p>
<p><img src="https://image.im0o.top/files/202112021515565.png" alt="image-20211202151500455"></p>
<p>已知 $BitMap 通常位于 6 号文件记录，每个文件记录占 2 个扇区。向后跳转 <code>6*2=12</code> 扇区，即可到达 $BitMap 的文件记录位置。</p>
<p><img src="https://image.im0o.top/files/202112021516349.png" alt="image-20211202151620288"></p>
<p>通过观察 <strong>80H</strong> 属性中的 <strong>RunList</strong>，可以得出：</p>
<p>该分区的 <strong>$BitMap</strong> 大小占 <strong>0xA0</strong> 个簇，换算成10进制为 <strong>160</strong> 个簇。</p>
<p>通过 <code>(160 * 8 - 1) * 512 * 8 * 8</code> 可计算出<strong>分区大小为 <code>41,910,272</code> 扇区</strong>。</p>
<h2 id="寻找该分区的备份，修复-DBR"><a href="#寻找该分区的备份，修复-DBR" class="headerlink" title="寻找该分区的备份，修复 DBR"></a>寻找该分区的备份，修复 DBR</h2><p>使用快捷键 <code>Ctrl + G</code> 跳转到分区 DBR 位置（63扇区），再向后跳转 <code>41,910,272</code> 扇区，至该分区尾部。</p>
<blockquote>
<p>由于计算分区大小时为了放置分区大小计算过大，通常会在 $BitMap 的扇区大小数 - 1 再进行后续的计算，这样计算出来的值会比实际分区大小略微小一点，不过不会影响数据恢复。</p>
</blockquote>
<p>向下查找 <code>!00</code>，找到该分区的备份。</p>
<p><img src="https://image.im0o.top/files/202112021522347.png" alt="image-20211202152250208"></p>
<p>选中整个扇区（分区备份），复制粘贴至该分区的 DBR 位置。</p>
<p><img src="https://image.im0o.top/files/202112021523767.png" alt="image-20211202152346650"></p>
<h2 id="填写-MBR"><a href="#填写-MBR" class="headerlink" title="填写 MBR"></a>填写 MBR</h2><p>跳转到 0 扇区后填写 MBR 的分区表。</p>
<p>NTFS 分区的标识为 <code>07</code></p>
<p>该分区所在位置为 <code>3F</code>（63）</p>
<p>该分区的大小为 <code>72 CB 7F 02</code>（41,929,586）</p>
<p><img src="https://image.im0o.top/files/202112021529499.png" alt="image-20211202152923455"></p>
<h2 id="保存更改后重新加载该磁盘"><a href="#保存更改后重新加载该磁盘" class="headerlink" title="保存更改后重新加载该磁盘"></a>保存更改后重新加载该磁盘</h2><p>保存后从 <strong>计算机管理——磁盘管理</strong> 处刷新该磁盘，可以看到该虚拟磁盘的分区恢复成功。</p>
<p><img src="https://image.im0o.top/files/202112021530201.png" alt="image-20211202153001162"></p>
<p>使用资源管理器打开分区后，文件显示正常。</p>
<p><img src="https://image.im0o.top/files/202112021530079.png" alt="image-20211202153029017"></p>
<p>至此，本题结束。</p>
<h1 id="实例：从-NTFS-分区提取文件"><a href="#实例：从-NTFS-分区提取文件" class="headerlink" title="实例：从 NTFS 分区提取文件"></a>实例：从 NTFS 分区提取文件</h1><blockquote>
<p>本题目标文件为：<code>site.png</code></p>
</blockquote>
<h2 id="附加虚拟磁盘文件-1"><a href="#附加虚拟磁盘文件-1" class="headerlink" title="附加虚拟磁盘文件"></a>附加虚拟磁盘文件</h2><p>导入题目后可以从 <strong>计算机管理——磁盘管理</strong> 中看到该虚拟磁盘显示位“没有初始化”，其大小为 20GB，均未分配分区，可以初步判断该虚拟磁盘的 MBR（主引导扇区）损坏。</p>
<p><img src="https://image.im0o.top/files/202112030949930.png" alt="image-20211203094902876"></p>
<h2 id="使用-Winhex-打开虚拟磁盘-1"><a href="#使用-Winhex-打开虚拟磁盘-1" class="headerlink" title="使用 Winhex 打开虚拟磁盘"></a>使用 Winhex 打开虚拟磁盘</h2><p><img src="https://image.im0o.top/files/202112030951095.png" alt="image-20211203095108974"></p>
<p>使用 Winhex 打开该虚拟磁盘何以观察到整个主引导扇区都为空，首先填写 MBR 的结束标志 <code>55 AA</code>，接着向下寻找分区。</p>
<h2 id="寻找分区-1"><a href="#寻找分区-1" class="headerlink" title="寻找分区"></a>寻找分区</h2><p>向下查找 16 进制数值 <code>!00</code>，如图所示，可以判断出该分区为 NTFS 分区。</p>
<p><img src="https://image.im0o.top/files/202112030953988.png" alt="image-20211203095346883"></p>
<p>分区位置为 63。</p>
<h2 id="前往-MFT，寻找文件"><a href="#前往-MFT，寻找文件" class="headerlink" title="前往 $MFT，寻找文件"></a>前往 $MFT，寻找文件</h2><p>向后跳转 <code>6291456</code> 扇区至元文件 $MFT。</p>
<p><img src="https://image.im0o.top/files/202112030955753.png" alt="image-20211203095517636"></p>
<p>使用快捷键 <code>Ctrl+F</code> 向下查找 Unicode 文本 <code>site.png</code>。</p>
<p><img src="https://image.im0o.top/files/202112030956751.png" alt="image-20211203095605699"></p>
<p>如图所示，该扇区为图片 site.png 的文件记录。</p>
<p><img src="https://image.im0o.top/files/202112030956075.png" alt="image-20211203095634975"></p>
<h2 id="计算文件属性，恢复文件"><a href="#计算文件属性，恢复文件" class="headerlink" title="计算文件属性，恢复文件"></a>计算文件属性，恢复文件</h2><p>找到该文件记录的 80H 属性，其 RunList 值为 <code>22 94 02 57 19</code></p>
<p>故该文件位置为 19 57H（簇），大小为 02 94H（簇）。</p>
<p>换算成 10 进制扇区数为：</p>
<p>文件位置：51896(簇)</p>
<p>文件大小：5280</p>
<p>从 DBR 处向后跳转 51896*8=415168 个扇区，到达文件数据区。</p>
<p><img src="https://image.im0o.top/files/202112030959962.png" alt="image-20211203095955848"></p>
<p>右键数据区开头，点击“选块起始位置”设定该位置为选块的起始。</p>
<p><img src="https://image.im0o.top/files/202112031000495.png" alt="image-20211203100031449"></p>
<p>向后跳转 5280 个扇区，到达文件数据末尾。</p>
<p>右键数据区末尾，点击“选块尾部”，建立选块。</p>
<p><img src="https://image.im0o.top/files/202112031001393.png" alt="image-20211203100159351"></p>
<p>右键选块，点击“编辑”——“复制选块”——“至新文件”，即可将文件手动恢复出来。</p>
<p><img src="https://image.im0o.top/files/202112031002755.png" alt="image-20211203100233705"></p>
<p><img src="https://image.im0o.top/files/202112031003964.png" alt="image-20211203100335904"></p>
<p>用资源管理器打开文件夹，即可看到该文件被恢复了出来。</p>
<p><img src="https://image.im0o.top/files/202112031004746.png" alt="image-20211203100411696"></p>
<p>至此，本题结束。</p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Winhex数据恢复教程</category>
      </categories>
      <tags>
        <tag>Winhex</tag>
        <tag>数据恢复</tag>
        <tag>NTFS</tag>
      </tags>
  </entry>
  <entry>
    <title>皮丘Bot - 基于 Pichubot 开发的定制化QQ机器人</title>
    <url>/posts/4701195e.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是基于 <a href="/posts/78bda4cc.html">Pichubot</a> 开发的QQ机器人，名为皮丘Bot。</p>
<p>文档地址：<a href="https://bot.im0o.top/">Pichubot - 皮丘Bot</a></p>
<h1 id="功能：青年大学习管理系统"><a href="#功能：青年大学习管理系统" class="headerlink" title="功能：青年大学习管理系统"></a>功能：青年大学习管理系统</h1><p>这个功能共有三个模块，分别为：</p>
<ul>
<li><p>网页面板</p>
</li>
<li><p>QQ群管理</p>
</li>
<li><p>网络API</p>
</li>
</ul>
<h2 id="网页面板"><a href="#网页面板" class="headerlink" title="网页面板"></a>网页面板</h2><p><img src="https://image.im0o.top/files/202111121901131.png"></p>
<p>在这个模块中，皮丘Bot会提供一个简单的网页面板，用于管理青年大学习系统。</p>
<p>该模块有响应式布局，对手机端适配。</p>
<img src="https://image.im0o.top/files/202111121901117.png" style="width: 30%">

<h2 id="QQ群管理"><a href="#QQ群管理" class="headerlink" title="QQ群管理"></a>QQ群管理</h2><p><img src="https://image.im0o.top/files/202111261721383.png" alt="image-20211126172117257"></p>
<p>在这个模块中，皮丘Bot会接收到群消息，并将消息解析处理，这个功能是皮丘Bot的核心功能。</p>
<h2 id="网络API"><a href="#网络API" class="headerlink" title="网络API"></a>网络API</h2><p>网页面板采用的是前后端分离的模式，这个模块是用于提供网络API的。</p>
<h1 id="踩过的坑-笔记"><a href="#踩过的坑-笔记" class="headerlink" title="踩过的坑/笔记"></a>踩过的坑/笔记</h1><h2 id="前端（Vue-js-Axios-elementui）"><a href="#前端（Vue-js-Axios-elementui）" class="headerlink" title="前端（Vue.js + Axios + elementui）"></a>前端（Vue.js + Axios + elementui）</h2><p>前端面板采用的是 vue2 + axios + element-ui 进行开发，在开发过程中遇到了一些问题，比如：</p>
<h3 id="在外部页面需要刷新内部组件的数据"><a href="#在外部页面需要刷新内部组件的数据" class="headerlink" title="在外部页面需要刷新内部组件的数据"></a>在外部页面需要刷新内部组件的数据</h3><p>此处我将“成员列表”，写作一个组件，在“成员管理”页面中使用到了这个组件，但是在外部无法直接调用组件内的函数，也就无法做到重新加载列表内的表格。</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>在使用组件的时候给组件加上<code>ref</code>标签，通过调用<code>this.$refs.内容.函数</code>即可调用组件内的函数。</p>
<h4 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">memberTable</span> <span class="attr">ref</span>=<span class="string">&quot;memberTable&quot;</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="keyword">import</span> memberTable <span class="keyword">from</span> <span class="string">&#x27;@/components/membertable.vue&#x27;</span></span></span><br><span class="line"><span class="javascript">    ...</span></span><br><span class="line"><span class="javascript">    <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    	...</span></span><br><span class="line"><span class="javascript">    	<span class="built_in">this</span>.$refs.memberTable.getMemberList()</span></span><br><span class="line"><span class="javascript">        ...</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="axios-初始化拦截器"><a href="#axios-初始化拦截器" class="headerlink" title="axios 初始化拦截器"></a>axios 初始化拦截器</h3><p>由于 API 每次请求都需要 Bearer Token 以及配置请求地址，于是我在 src/ 目录下新建了一个 <code>axios-init.js</code> 文件用于初始化 axios 并输出。</p>
<p>以下为文件源码</p>
<p><em>src/axios-init.js</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&#x27;@/router&#x27;</span>  <span class="comment">//引入router</span></span><br><span class="line"><span class="keyword">import</span> cookies <span class="keyword">from</span> <span class="string">&#x27;vue-cookies&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Notification &#125; <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> instance = axios.create(); <span class="comment">//创建Loading 的实例</span></span><br><span class="line">instance.defaults.baseURL = <span class="string">&quot;http://localhost/api/&quot;</span>; <span class="comment">// 配置axios请求的地址</span></span><br><span class="line">instance.defaults.headers.post[<span class="string">&#x27;Content-Type&#x27;</span>] = <span class="string">&#x27;application/json; charset=utf-8&#x27;</span>;</span><br><span class="line">axios.defaults.crossDomain = <span class="literal">true</span>;</span><br><span class="line">axios.defaults.withCredentials = <span class="literal">true</span>;  <span class="comment">//设置cross跨域 并设置访问权限 允许跨域携带cookie信息</span></span><br><span class="line">instance.defaults.headers.common[<span class="string">&#x27;Authorization&#x27;</span>] = <span class="string">&#x27;&#x27;</span>; <span class="comment">// 设置请求头为 Authorization</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">instance.interceptors.request.use(</span><br><span class="line">  <span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 每次发送请求之前判断vuex中是否存在token</span></span><br><span class="line">    <span class="keyword">const</span> token = cookies.get(<span class="string">&#x27;token&#x27;</span>);</span><br><span class="line">    token &amp;&amp; (config.headers.Authorization = <span class="string">&#x27;Bearer &#x27;</span>+ token);</span><br><span class="line">    <span class="keyword">return</span> config;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.error(error); <span class="comment">// 抛出错误</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">instance.interceptors.response.use(</span><br><span class="line">  <span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据</span></span><br><span class="line">    <span class="comment">// 否则的话抛出错误</span></span><br><span class="line">    <span class="comment">// 如果返回的状态码和body中的code不一致，说明接口请求失败，抛出错误</span></span><br><span class="line">    <span class="keyword">if</span> (response.status === <span class="number">200</span> &amp;&amp; response.data.code !== <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (response.data.code) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1001</span>:</span><br><span class="line">          cookies.remove(<span class="string">&#x27;token&#x27;</span>);</span><br><span class="line">          cookies.remove(<span class="string">&#x27;userId&#x27;</span>);</span><br><span class="line">          cookies.remove(<span class="string">&#x27;userName&#x27;</span>);</span><br><span class="line">          router.push(&#123;<span class="attr">path</span>: <span class="string">&#x27;/login&#x27;</span>&#125;);</span><br><span class="line">          Notification(&#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;登录超时&#x27;</span>,</span><br><span class="line">            <span class="attr">message</span>: <span class="string">&#x27;请尝试重新登录&#x27;</span>,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;warning&#x27;</span></span><br><span class="line">          &#125;);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">          Notification(&#123;</span><br><span class="line">            <span class="attr">title</span>: <span class="string">&#x27;提示&#x27;</span>,</span><br><span class="line">            <span class="attr">message</span>: response.data.message,</span><br><span class="line">            <span class="attr">type</span>: <span class="string">&#x27;error&#x27;</span></span><br><span class="line">          &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(response);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (response.status === <span class="number">200</span> &amp;&amp; response.data.code === <span class="number">200</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(response);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 如果请求失败，返回错误</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> instance</span><br></pre></td></tr></table></figure>

<p><em>src/main.js</em>（引入 axios-init 中导出的 instance）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> instance <span class="keyword">from</span> <span class="string">&quot;./axios-init&quot;</span>;</span><br><span class="line">Vue.prototype.$http = instance;</span><br></pre></td></tr></table></figure>

<h3 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h3><p>下图为网页结构</p>
<p><img src="https://image.im0o.top/files/image-20211129100954349.png" alt="image-20211129100954349"></p>
<p>响应式布局仅需设置 el-aside 与 headtable 的 display 属性即可。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.asidemenu</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.headmenu</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: visible;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">min-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.asidemenu</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: visible;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.headmenu</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="后端（API、数据库操作部分）"><a href="#后端（API、数据库操作部分）" class="headerlink" title="后端（API、数据库操作部分）"></a>后端（API、数据库操作部分）</h2><h3 id="检测-Bearer-token"><a href="#检测-Bearer-token" class="headerlink" title="检测 Bearer token"></a>检测 Bearer token</h3><p>新建函数 verifyToken，传入 Header 中的 Authorization。 </p>
<p>使用 strings.HasPrefix() 判断是否含有 token，将 token 与已有的 token 进行比对验证，通过后返回 true.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">verifyToken</span><span class="params">(qq <span class="keyword">string</span>, token <span class="keyword">string</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">	<span class="keyword">if</span> strings.HasPrefix(token, <span class="string">&quot;Bearer&quot;</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> _, ok := Cookies[qq]; ok &amp;&amp; Cookies[qq] == token[<span class="number">7</span>:] &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Golang-实现-16-32-位-MD5-加密"><a href="#Golang-实现-16-32-位-MD5-加密" class="headerlink" title="Golang 实现 16/32 位 MD5 加密"></a>Golang 实现 16/32 位 MD5 加密</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">&quot;crypto/md5&quot;</span></span><br><span class="line">	<span class="string">&quot;encoding/hex&quot;</span></span><br><span class="line">	<span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个32位md5加密后的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GetMD5Encode</span><span class="params">(data <span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line">	h := md5.New()</span><br><span class="line">	h.Write([]<span class="keyword">byte</span>(data))</span><br><span class="line">	<span class="keyword">return</span> hex.EncodeToString(h.Sum(<span class="literal">nil</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回一个16位md5加密后的字符串</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Get16MD5Encode</span><span class="params">(data <span class="keyword">string</span>)</span> <span class="title">string</span></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> GetMD5Encode(data)[<span class="number">8</span>:<span class="number">24</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	source:=<span class="string">&quot;hello&quot;</span></span><br><span class="line">	fmt.Println(GetMD5Encode(source))</span><br><span class="line">	fmt.Println(Get16MD5Encode(source))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Golang-http-包下-FileServer-的使用"><a href="#Golang-http-包下-FileServer-的使用" class="headerlink" title="Golang http 包下 FileServer 的使用"></a>Golang http 包下 FileServer 的使用</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将本地 &quot;/doc&quot; 路径下的文件绑定至 &quot;www.xxx.com/&quot; 下</span></span><br><span class="line">http.Handle(<span class="string">&quot;/&quot;</span>, http.FileServer(http.Dir(<span class="string">&quot;./doc&quot;</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将本地 &quot;/doc&quot; 路径下的文件绑定至 &quot;www.xxx.com/abc/&quot; 下</span></span><br><span class="line">http.Handle(<span class="string">&quot;/abc/&quot;</span>, http.StripPrefix(<span class="string">&quot;/abc&quot;</span>, http.FileServer(http.Dir(<span class="string">&quot;./doc&quot;</span>))))</span><br></pre></td></tr></table></figure>

<h3 id="Golang-CORS-跨域请求"><a href="#Golang-CORS-跨域请求" class="headerlink" title="Golang CORS 跨域请求"></a>Golang CORS 跨域请求</h3><p>在 http.ResponseWriter 中允许所有类型的请求，头，域名</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">writer.Header().Set(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>) <span class="comment">//允许访问所有域</span></span><br><span class="line">writer.Header().Set(<span class="string">&quot;Access-Control-Allow-Methods&quot;</span>, <span class="string">&quot;*&quot;</span>)</span><br><span class="line">writer.Header().Set(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;*&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Golang-打包文件夹为-zip-压缩文件"><a href="#Golang-打包文件夹为-zip-压缩文件" class="headerlink" title="Golang 打包文件夹为 zip 压缩文件"></a>Golang 打包文件夹为 zip 压缩文件</h3><p>打包函数：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Zip</span><span class="params">(src_dir <span class="keyword">string</span>, zip_file_name <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">	dir, err := ioutil.ReadDir(src_dir)</span><br><span class="line">	<span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">		logger.Log.Error(<span class="string">&quot;ioutil.ReadDir err:&quot;</span> + err.Error())</span><br><span class="line">		<span class="keyword">return</span> err</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(dir) == <span class="number">0</span> &#123;</span><br><span class="line">		logger.Log.Info(src_dir + <span class="string">&quot; is empty dir!&quot;</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 预防：旧文件无法覆盖</span></span><br><span class="line">	os.RemoveAll(zip_file_name)</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建：zip文件</span></span><br><span class="line">	zipfile, _ := os.Create(zip_file_name)</span><br><span class="line">	<span class="keyword">defer</span> zipfile.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 打开：zip文件</span></span><br><span class="line">	archive := zip.NewWriter(zipfile)</span><br><span class="line">	<span class="keyword">defer</span> archive.Close()</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 遍历路径信息</span></span><br><span class="line">	filepath.Walk(src_dir, <span class="function"><span class="keyword">func</span><span class="params">(path <span class="keyword">string</span>, info os.FileInfo, _ error)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 如果是源路径，提前进行下一个遍历</span></span><br><span class="line">		<span class="keyword">if</span> path == src_dir &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 获取：文件头信息</span></span><br><span class="line">		header, _ := zip.FileInfoHeader(info)</span><br><span class="line"></span><br><span class="line">		header.Name = strings.TrimPrefix(path, src_dir+<span class="string">`\`</span>)</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 判断：文件是不是文件夹</span></span><br><span class="line">		<span class="keyword">if</span> info.IsDir() &#123;</span><br><span class="line">			header.Name += <span class="string">`/`</span></span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// 设置：zip的文件压缩算法</span></span><br><span class="line">			header.Method = zip.Deflate</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 创建：压缩包头部信息</span></span><br><span class="line">		writer, _ := archive.CreateHeader(header)</span><br><span class="line">		<span class="keyword">if</span> !info.IsDir() &#123;</span><br><span class="line">			file, _ := os.Open(path)</span><br><span class="line">			<span class="keyword">defer</span> file.Close()</span><br><span class="line">			io.Copy(writer, file)</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">	&#125;)</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>需要注意的是：在传入字符串时的路径最好使用 filepath.Join 进行操作，直接使用字符串可能会造成打包错误的问题, <code>zipfile</code> 需要加上扩展名</p>
<h3 id="Golang-GORM-根据结构体结构建指定名字的表"><a href="#Golang-GORM-根据结构体结构建指定名字的表" class="headerlink" title="Golang GORM 根据结构体结构建指定名字的表"></a>Golang GORM 根据结构体结构建指定名字的表</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体</span></span><br><span class="line"><span class="keyword">type</span> user <span class="keyword">struct</span> &#123;</span><br><span class="line">	QQ   <span class="keyword">int64</span>  <span class="string">`json:&quot;qq&quot;`</span></span><br><span class="line">	Name <span class="keyword">string</span> <span class="string">`json:&quot;name&quot;`</span></span><br><span class="line">	Comp <span class="keyword">int</span>    <span class="string">`json:&quot;comptype&quot;`</span></span><br><span class="line">	Url  <span class="keyword">string</span> <span class="string">`json:&quot;url,omitempty&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// gorm 新建一个user结构的表</span></span><br><span class="line"><span class="comment">// database 为 *gorm.DB 类型</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createTable</span><span class="params">(groupId <span class="keyword">string</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">	err := database.Table(groupId).Migrator().CreateTable(&amp;user&#123;&#125;)</span><br><span class="line">	<span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="VuePress-文档"><a href="#VuePress-文档" class="headerlink" title="VuePress 文档"></a>VuePress 文档</h2><h3 id="部署文档后样式丢失"><a href="#部署文档后样式丢失" class="headerlink" title="部署文档后样式丢失"></a>部署文档后样式丢失</h3><p>将 <code>docs/.vuepress/config.js</code> 中的 <code>base</code> 字段由绝对地址 <code>/</code> 改为相对地址 <code>./</code> 即可</p>
<h3 id="在-VuePress-中使用-element-ui"><a href="#在-VuePress-中使用-element-ui" class="headerlink" title="在 VuePress 中使用 element-ui"></a>在 VuePress 中使用 element-ui</h3><p>在 <code>docs/.vuepress/</code> 目录下新建文件 <code>enhanceApp.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> Element <span class="keyword">from</span> <span class="string">&#x27;element-ui&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;element-ui/lib/theme-chalk/index.css&#x27;</span></span><br><span class="line"><span class="comment">// import ViewUI from &#x27;view-design&#x27;;</span></span><br><span class="line"><span class="comment">// import &#x27;view-design/dist/styles/iview.css&#x27;;</span></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line">Vue.use(Element);</span><br></pre></td></tr></table></figure>

<p>使用包管理安装对应的包（vue，element-ui）即可。</p>
<h2 id="让-Vuepress-支持图片放大功能"><a href="#让-Vuepress-支持图片放大功能" class="headerlink" title="让 Vuepress 支持图片放大功能"></a>让 Vuepress 支持图片放大功能</h2><p>使用包管理安装插件 <code>@vuepress/plugin-medium-zoom</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yarn add -D @vuepress/plugin-medium-zoom</span><br><span class="line"><span class="comment"># OR npm install -D @vuepress/plugin-medium-zoom</span></span><br></pre></td></tr></table></figure>

<p>在 <code>docs/.vuepress/config.js</code> 中添加</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [<span class="string">&quot;@vuepress/medium-zoom&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>杂谈/踩坑笔记</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>Pichubot</tag>
        <tag>QQ机器人</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Winhex进行数据恢复（7）</title>
    <url>/posts/653616c9.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇将了解到 NTFS 分区结构下文件记录中常见的属性，以及属性的结构。</p>
<h1 id="知识点总览"><a href="#知识点总览" class="headerlink" title="知识点总览"></a>知识点总览</h1><ul>
<li>NTFS 文件记录的常见属性</li>
<li>各类文件/文件夹的常用属性</li>
<li>各项属性详解<ul>
<li>10H 属性</li>
<li>30H 属性</li>
<li>80H 属性</li>
<li>90H 属性</li>
<li>A0H 属性</li>
<li>B0H 属性</li>
</ul>
</li>
</ul>
<h1 id="NTFS-文件记录的常见属性"><a href="#NTFS-文件记录的常见属性" class="headerlink" title="NTFS 文件记录的常见属性"></a>NTFS 文件记录的常见属性</h1><p>在 NTFS 分区下的文件或文件夹的文件记录中，经常使用的属性有：</p>
<ul>
<li>10H 属性（标准信息）</li>
<li>30H 属性（文件名属性）</li>
<li>80H 属性（$DATA 属性）</li>
<li>90H 属性（文件夹/根 索引属性）</li>
<li>A0H 属性（索引分配属性）</li>
<li>B0H 属性（位图属性）</li>
</ul>
<h1 id="各类文件-文件夹的常用属性"><a href="#各类文件-文件夹的常用属性" class="headerlink" title="各类文件/文件夹的常用属性"></a>各类文件/文件夹的常用属性</h1><h2 id="文件的文件记录经常使用的属性"><a href="#文件的文件记录经常使用的属性" class="headerlink" title="文件的文件记录经常使用的属性"></a><strong>文件</strong>的文件记录经常使用的属性</h2><ul>
<li>10H 属性（标准信息）</li>
<li>30H 属性（文件名属性）</li>
<li>80H 属性（$DATA 属性）</li>
</ul>
<h2 id="小文件夹的常用属性"><a href="#小文件夹的常用属性" class="headerlink" title="小文件夹的常用属性"></a><strong>小文件夹</strong>的常用属性</h2><ul>
<li>10H 属性（标准信息）</li>
<li>30H 属性（文件名属性）</li>
<li>90H 属性（文件夹/根 索引属性）</li>
</ul>
<h2 id="大文件夹的常用属性"><a href="#大文件夹的常用属性" class="headerlink" title="大文件夹的常用属性"></a><strong>大文件夹</strong>的常用属性</h2><ul>
<li>10H 属性（标准信息）</li>
<li>30H 属性（文件名属性）</li>
<li>90H 属性（文件夹/根 索引属性）</li>
<li>A0H 属性（索引分配属性）</li>
<li>B0H 属性（位图属性）</li>
</ul>
<h2 id="特殊情况"><a href="#特殊情况" class="headerlink" title="特殊情况"></a>特殊情况</h2><p>有些小文件夹也有可能有 A0H 属性和 B0H 属性，这是因为这类文件夹往往是小文件夹变成大文件夹后<strong>再变为小文件夹</strong>产生的。（即用户将文件夹中的文件删除后，文件夹中的剩余文件数量非常少（甚至是空的）而形成的小文件夹）</p>
<h1 id="各项属性详解"><a href="#各项属性详解" class="headerlink" title="各项属性详解"></a>各项属性详解</h1><h2 id="10H-属性"><a href="#10H-属性" class="headerlink" title="10H 属性"></a>10H 属性</h2><p>10H 属性的类名为 $STANDARD_INFORMATION（标准信息），是所有文件记录或文件夹都具有的<strong>常驻属性</strong>，它包含了文件或文件夹的基本信息。例如：日期、时间、有多少个目录指向文件或文件夹等。</p>
<p>这个属性一般位于属性头之后的第一个属性，偏移地址通常为 38H。</p>
<p><img src="https://image.im0o.top/files/202111230943554.png" alt="image-20211123094332501"></p>
<h2 id="30H-属性"><a href="#30H-属性" class="headerlink" title="30H 属性"></a>30H 属性</h2><p>30H 属性一般紧跟 10H 属性之后。30H 属性属于<strong>常驻</strong>无属性名属性，用于<strong>存储文件名</strong>。其大小为 68~578 字节（文件名最大为 255 个 Unicode 字符），如果一个文件或文件夹的名字<strong>超过8个字符</strong>时，在文件记录中就会有两个 30H 属性，一个 30H 属性描述的是短文件名，另一个描述的则是长文件名。</p>
<p><img src="https://image.im0o.top/files/202111231058300.png" alt="image-20211123105856247"></p>
<h2 id="80H-属性"><a href="#80H-属性" class="headerlink" title="80H 属性"></a>80H 属性</h2><p>80H 属性即 $DATA 属性，80H 属性主要用于存储文件。该属性一般情况下可分为三种结构：</p>
<ul>
<li>有属性头而无属性体</li>
<li>常驻无属性名</li>
<li>非常驻无属性</li>
</ul>
<p><img src="https://image.im0o.top/files/202111241601798.png" alt="image-20211124160123744"></p>
<h3 id="有属性头无属性体"><a href="#有属性头无属性体" class="headerlink" title="有属性头无属性体"></a>有属性头无属性体</h3><p>这种属性主要针对没有内容（0字节）的文本文件的情况。</p>
<p> <img src="https://image.im0o.top/files/202111241610840.png" alt="image-20211124161048806"></p>
<h3 id="常驻无属性名"><a href="#常驻无属性名" class="headerlink" title="常驻无属性名"></a>常驻无属性名</h3><p>80H 常驻无属性名分为 80H 属性头和 80H 属性体（即文件内容）两部分。文件内容的长度为8的倍数，当文件内容结束时并没有达到8的倍数时，多余的字节用 00 来填充。</p>
<table>
<thead>
<tr>
<th align="center">字节偏移</th>
<th align="center">长度/字节</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">00H</td>
<td align="center">4</td>
<td align="center">属性类型（80H，对象ID属性）</td>
</tr>
<tr>
<td align="center">04H</td>
<td align="center">4</td>
<td align="center">该属性长度（包括文件属性头头部本身）</td>
</tr>
<tr>
<td align="center">08H</td>
<td align="center">1</td>
<td align="center">是否为常驻标志，此处为00，表示常驻</td>
</tr>
<tr>
<td align="center">09H</td>
<td align="center">1</td>
<td align="center">属性名的名称长度，00表示没有属性名</td>
</tr>
<tr>
<td align="center">0AH</td>
<td align="center">2</td>
<td align="center">属性名的名称偏移</td>
</tr>
<tr>
<td align="center">0CH</td>
<td align="center">2</td>
<td align="center">标准（压缩、加密、稀疏等）</td>
</tr>
<tr>
<td align="center">0EH</td>
<td align="center">2</td>
<td align="center">属性ID标识</td>
</tr>
<tr>
<td align="center">010H</td>
<td align="center">4</td>
<td align="center">属性体长度（L）</td>
</tr>
<tr>
<td align="center">014H</td>
<td align="center">2</td>
<td align="center">属性内容起始偏移</td>
</tr>
<tr>
<td align="center">016H</td>
<td align="center">1</td>
<td align="center">索引标志</td>
</tr>
<tr>
<td align="center">017H</td>
<td align="center">1</td>
<td align="center">填充</td>
</tr>
<tr>
<td align="center">018H</td>
<td align="center">L</td>
<td align="center">文件内容</td>
</tr>
</tbody></table>
<h3 id="非常驻无属性名"><a href="#非常驻无属性名" class="headerlink" title="非常驻无属性名"></a>非常驻无属性名</h3><p>非常驻的属性一般以数据流（Run List）的形式表示，此处以一个 $LogFile 文件的 80H 属性进行分析，具体的数据流列表如下：</p>
<center>32 <u>98 1B</u> <u>A6 C8 03</u></center>

<p>这个数据流的具体含义如下：</p>
<ol>
<li>该属性共有 1 个数据流列表</li>
<li>这个数据流列表占 6 字节，即<code>32 98 1B A6 C8 03</code>，数值<code>32</code>表示该数据流列表的起始簇号占 3 字节，簇数占 1 字节；即该数据流列表起始簇号为 0x03C8A6（即 247974），共占 0x1B98（即 7064）个簇。</li>
</ol>
<h3 id="数据流（数据运行列）"><a href="#数据流（数据运行列）" class="headerlink" title="数据流（数据运行列）"></a>数据流（数据运行列）</h3><p>80H 属性下的第一个未命名数据流也就是文件真正的数据，由 Data Run 来记录其属性体（即文件数据）的具体位置。</p>
<h4 id="结构含义"><a href="#结构含义" class="headerlink" title="结构含义"></a>结构含义</h4><p><img src="https://image.im0o.top/files/image-20211124145935103.png" alt="image-20211124145935103"></p>
<h4 id="对应关系"><a href="#对应关系" class="headerlink" title="对应关系"></a>对应关系</h4><p><img src="https://image.im0o.top/files/202111251037711.png" alt="image-20211125103754674"></p>
<h4 id="计算方式"><a href="#计算方式" class="headerlink" title="计算方式"></a>计算方式</h4><p>通过数据流计算出文件的位置与大小（此处以上图的数据进行计算）</p>
<p>通过解析数据流，我们知道了该文件的位置大小信息为下表：</p>
<blockquote>
<p>此处每簇扇区数定义为 <code>8 （扇区/簇）</code></p>
</blockquote>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">簇数（16进制）</th>
<th align="center">簇数（10进制）</th>
<th align="center">扇区数</th>
</tr>
</thead>
<tbody><tr>
<td align="center">位置（隐藏扇区数）</td>
<td align="center">03 C8 A6</td>
<td align="center">247974</td>
<td align="center">1983792</td>
</tr>
<tr>
<td align="center">大小</td>
<td align="center">1B 98</td>
<td align="center">7064</td>
<td align="center">56512</td>
</tr>
</tbody></table>
<p>有了文件的位置与大小参数，即可从 <strong>NTFS 的 DBR 处</strong>向后跳转 <code>1983792 扇区</code> （隐藏扇区数），选中个 <code>56512 </code>扇区（文件大小），即可复制选块至新文件，从底层恢复该文件。</p>
<h2 id="90H-属性"><a href="#90H-属性" class="headerlink" title="90H 属性"></a>90H 属性</h2><p>90H 属性即 $INDEX_ROOT，是索引根属性，该属性是实现 NTFS 的 B+ 树索引的根节点，它总是常驻属性。</p>
<p>该属性没有最大最小长度性质，属性结构如下：</p>
<div style="text-align:center">
    <p>
        标准属性头
    </p>
    <p>
        索引根
    </p>
    <p>
        索引头
    </p>
    <p>
        索引项
    </p>
    <p>
        索引项
    </p>
    <p>
        ...
    </p>
</div>

<p><img src="https://image.im0o.top/files/202111251449202.jpeg" alt="90H"></p>
<h3 id="索引根"><a href="#索引根" class="headerlink" title="索引根"></a>索引根</h3><table>
<thead>
<tr>
<th>字节偏移</th>
<th>字段长度（字节）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>～</td>
<td>～</td>
<td>标准属性头（已分析过）</td>
</tr>
<tr>
<td>0x00</td>
<td>4</td>
<td>属性类型</td>
</tr>
<tr>
<td>0x04</td>
<td>4</td>
<td>校对规则</td>
</tr>
<tr>
<td>0x08</td>
<td>4</td>
<td>每个索引缓冲区的分配大小（字节数）</td>
</tr>
<tr>
<td>0x0C</td>
<td>1</td>
<td>每个索引缓冲区的簇数</td>
</tr>
<tr>
<td>0x0D</td>
<td>3</td>
<td>无意义（填充到属性长度能被8整除）</td>
</tr>
</tbody></table>
<h3 id="索引头"><a href="#索引头" class="headerlink" title="索引头"></a>索引头</h3><table>
<thead>
<tr>
<th>字节偏移</th>
<th>字段长度（字节）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0x00</td>
<td>4</td>
<td>第一个索引项的偏移</td>
</tr>
<tr>
<td>0x04</td>
<td>4</td>
<td>索引项的总大小</td>
</tr>
<tr>
<td>0x08</td>
<td>4</td>
<td>索引项的分配大小</td>
</tr>
<tr>
<td>0x0C</td>
<td>1</td>
<td>标志：当该字节为00时，表示其为小索引（适合于索引根）；当该字节为01时，表示其为大索引（适合于索引分配）</td>
</tr>
<tr>
<td>0x0D</td>
<td>3</td>
<td>无意义（填充到属性长度能被8整除）</td>
</tr>
</tbody></table>
<h3 id="索引项"><a href="#索引项" class="headerlink" title="索引项"></a>索引项</h3><p>索引头后面有着不同长度的索引项的序列，由一个带有最后一个索引项标志的特殊索引项来结束。当一个目录比较小，可以全部存储在索引根属性中时，该目录就只需要这一个属性来描述。而如果目录太大不能全部存储在索引根中时，就会有两个附加的属性出现：一个是索引分配属性，描述B＋树目录的子节点；另一个是索引位图属性，描述索引块的索引分配属性使用的虚拟簇号。根目录$Root包含它自身的一个索引项。</p>
<p><img src="https://image.im0o.top/files/202111251229499.jpeg" alt="90H（$INDEX_ROOT）"></p>
<p><strong>索引项描述</strong></p>
<table>
<thead>
<tr>
<th>字节偏移</th>
<th>字段长度（字节）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0x00</td>
<td>8</td>
<td>该文件的MFT参考号</td>
</tr>
<tr>
<td>0x08</td>
<td>2</td>
<td>索引项的大小（相对索引项开始的偏移）</td>
</tr>
<tr>
<td>0x0A</td>
<td>2</td>
<td>文件名属性体大小</td>
</tr>
<tr>
<td>0x0C</td>
<td>2</td>
<td>索引标志：此处为1表示这个索引项包含子节点；为2表示这是最后一个项</td>
</tr>
<tr>
<td>0x0E</td>
<td>2</td>
<td>用0填充，无意义</td>
</tr>
<tr>
<td>0x10</td>
<td>8</td>
<td>父目录的MFT文件参考号</td>
</tr>
<tr>
<td>0x18</td>
<td>8</td>
<td>文件创建时间</td>
</tr>
<tr>
<td>0x20</td>
<td>8</td>
<td>文件最后修改时间</td>
</tr>
<tr>
<td>0x28</td>
<td>8</td>
<td>文件记录最后修改时间</td>
</tr>
<tr>
<td>0x30</td>
<td>8</td>
<td>文件最后访问时间</td>
</tr>
<tr>
<td>0x38</td>
<td>8</td>
<td>文件的分配大小</td>
</tr>
<tr>
<td>0x40</td>
<td>8</td>
<td>文件的实际大小</td>
</tr>
<tr>
<td>0x48</td>
<td>8</td>
<td>文件标志</td>
</tr>
<tr>
<td>0x50</td>
<td>1</td>
<td>文件名的长度</td>
</tr>
<tr>
<td>0x51</td>
<td>1</td>
<td>文件名的命名空间</td>
</tr>
<tr>
<td>0x52</td>
<td>2F</td>
<td>文件名</td>
</tr>
<tr>
<td>2F＋0x52</td>
<td>P</td>
<td>填充到能被8整除（无意义）</td>
</tr>
<tr>
<td>P＋2F＋0x52</td>
<td>8</td>
<td>子节点的索引所在的VCN（需要有子节点时才有）</td>
</tr>
</tbody></table>
<h2 id="A0H-属性"><a href="#A0H-属性" class="headerlink" title="A0H 属性"></a>A0H 属性</h2><p>A0H 类型属性，即 INDEX_ALLOCATION，它是索引分配属性，也是一个索引（如目录）的基本结构，存储着组成索引的B＋树目录所有子节点的定位信息。它总是非常驻属性，没有最大最小值限制。</p>
<p>A0H属性结构描述：</p>
<table>
<thead>
<tr>
<th>字节偏移</th>
<th>字段长度（字节）</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>~</td>
<td>~</td>
<td>标准属性头（已分析过）</td>
</tr>
<tr>
<td>0x00</td>
<td>…</td>
<td>Data Run列表</td>
</tr>
</tbody></table>
<p><img src="https://image.im0o.top/files/202111251459832.jpeg" alt="202111251459832.jpeg"></p>
<p>A0H属性的Run List所描述的数据流，也就是NTFS的B＋树结构的索引缓冲区。</p>
<h2 id="B0H-属性"><a href="#B0H-属性" class="headerlink" title="B0H 属性"></a>B0H 属性</h2><p>B0H 类型属性即 $BITMAP，也就是位图属性，该属性是由一系列的位构成的虚拟簇（VCN）使用情况表，它没有最大最小限制。该属性目前用在两个地方：索引和 $MFT 中。在索引中，每一位代表索引分配中的一个 VCN；在 $MFT 中，每一位代表一个文件记录的使用情况。</p>
<p><img src="https://image.im0o.top/files/202111251500915.jpeg" alt="202111251500915.jpeg"></p>
<p>下图为一个 $MFT 自带的 B0H 属性</p>
<p><img src="https://image.im0o.top/files/202111251501301.jpeg" alt="202111251501301.jpeg"></p>
<p>上图中 B0H 属性的 Run List 所描述的数据流，就是 $MFT 的文件记录使用情况表。</p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Winhex数据恢复教程</category>
      </categories>
      <tags>
        <tag>Winhex</tag>
        <tag>数据恢复</tag>
        <tag>NTFS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Winhex进行数据恢复（6）</title>
    <url>/posts/dd8a71ac.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本篇将继续学习 NTFS 分区结构下的文件记录结构。</p>
<h1 id="知识点总览"><a href="#知识点总览" class="headerlink" title="知识点总览"></a>知识点总览</h1><ul>
<li>NTFS 分区结构文件记录分析</li>
<li>NTFS 文件记录头的结构</li>
<li>NTFS 文件记录中属性的结构</li>
</ul>
<h1 id="NTFS-分区结构文件记录的分析"><a href="#NTFS-分区结构文件记录的分析" class="headerlink" title="NTFS 分区结构文件记录的分析"></a>NTFS 分区结构文件记录的分析</h1><h2 id="文件记录的结构"><a href="#文件记录的结构" class="headerlink" title="文件记录的结构"></a>文件记录的结构</h2><p>$MFT 以文件记录来实现对文件的管理，相对于 FAT32 分区结构以 32 字节储存每条文件记录，NTFS 分区结构的文件记录大小固定为 <strong>1024 字节</strong>，也就是<strong>两个扇区</strong>。</p>
<p>如果一个文件有很多属性或者是分散成很多碎片，就很可能需要多个文件记录。此时，存放其文件记录的第一个记录就被称为“基本文件记录”。文件记录在 $MFT 中物理上是连续的，从 <strong>0</strong> 开始依次按顺序编号。</p>
<p>文件记录由两部分组成，一部分是文件记录头，另一部分是属性列表。</p>
<p><img src="https://image.im0o.top/files/202111221552241.png" alt="image-20211122155241177"></p>
<p><strong>文件属性结构表：</strong></p>
<p><img src="https://image.im0o.top/files/202111230930895.png" alt="img"></p>
<h2 id="文件记录头的结构"><a href="#文件记录头的结构" class="headerlink" title="文件记录头的结构"></a>文件记录头的结构</h2><p>文件记录头的长度和具体偏移位置的数据含义是不变的，而属性列表是可变的，其不同的属性有着不同的含义。</p>
<p><img src="https://image.im0o.top/files/202111221055511.png" alt="image-20211122105521469"></p>
<p>NTFS 文件记录头的信息：</p>
<table>
<thead>
<tr>
<th align="center">字节偏移</th>
<th align="center">字段长度（字节）</th>
<th align="center">字段名和含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x00</td>
<td align="center">4</td>
<td align="center"><strong>MFT标志，一定为字符串“FILE”</strong></td>
</tr>
<tr>
<td align="center">0x04</td>
<td align="center">2</td>
<td align="center">更新序列号（Update Sequence Number）的偏移</td>
</tr>
<tr>
<td align="center">0x06</td>
<td align="center">2</td>
<td align="center">更新序列号的大小与数组，包括第一个字节</td>
</tr>
<tr>
<td align="center">0x08</td>
<td align="center">8</td>
<td align="center">日志文件序列号（$LogFile Sequence Number，LSN）</td>
</tr>
<tr>
<td align="center">0x10</td>
<td align="center">2</td>
<td align="center">序列号（Sequence Number）</td>
</tr>
<tr>
<td align="center">0x12</td>
<td align="center">2</td>
<td align="center">硬连接数（Hard Link Count），即有多少目录指向该文件</td>
</tr>
<tr>
<td align="center">0x14</td>
<td align="center">2</td>
<td align="center">第一个属性的偏移地址</td>
</tr>
<tr>
<td align="center">0x16</td>
<td align="center">2</td>
<td align="center"><strong>标志（Flag），00H表示文件被删除，01H表示文件正在使用，02H表示目录被删除，03H表示目录正在使用</strong></td>
</tr>
<tr>
<td align="center">0x18</td>
<td align="center">4</td>
<td align="center"><strong>文件记录的实际长度</strong></td>
</tr>
<tr>
<td align="center">0x1C</td>
<td align="center">4</td>
<td align="center">文件记录的分配长度</td>
</tr>
<tr>
<td align="center">0x20</td>
<td align="center">8</td>
<td align="center">基本文件记录中的文件索引号</td>
</tr>
<tr>
<td align="center">0x28</td>
<td align="center">2</td>
<td align="center">下一属性ID，当增加新的属性时，将该值分配给新属性，然后该值增加，如果MFT记录重新使用，则将它置0，第一个实例总是0</td>
</tr>
<tr>
<td align="center">0x2A</td>
<td align="center">2</td>
<td align="center">边界，Windows XP中为偏移0x30处</td>
</tr>
<tr>
<td align="center">0x2C</td>
<td align="center">4</td>
<td align="center"><strong>文件记录号</strong></td>
</tr>
<tr>
<td align="center">0x30</td>
<td align="center">2</td>
<td align="center">更新序列号</td>
</tr>
<tr>
<td align="center">0x32</td>
<td align="center">4</td>
<td align="center">更新数组</td>
</tr>
</tbody></table>
<p><strong>偏移00H～03H为MFT的标志字符串，它总为“FILE”。</strong></p>
<p>每次记录被修改都将导致偏移08H～09H处的日志文件序列号$LogFile Sequence Number（LSN）发生变化。</p>
<p>偏移10H～11H处序列号Sequence Number（SN）用于记录主文件表记录被重复使用的次数。</p>
<p>偏移12H～13H处为硬连接数记录硬连接的数目，只出现在基本文件记录中。</p>
<p>偏移18H～1BH处文件记录的实际长度也即文件记录在磁盘上实际占用的字节空间。</p>
<p>偏移1CH～1FH为系统分配给文件记录的长度，一般为“00 04 00 00”，也就是1KB的长度。</p>
<p>偏移20H～27H处为基本文件记录中的文件索引号，基本文件记录在此的值总为0。如果不为0，则是一个主文件表的文件索引号，指向所属的基本文件记录中的文件记录号。在基本文件记录中包含有扩展文件记录的信息，存储在“属性列表ATTRIBUTE_LIST”属性中。</p>
<p><strong>偏移2CH～2FH处为文件记录编号，从0开始编号。</strong></p>
<p>偏移30H～31H处为更新序列号，这两个字节同时会出现在该文件记录第一个扇区最后两个字节处及该文件记录第二个扇区最后两个字节处，如下图所示。</p>
<p><img src="https://image.im0o.top/files/202111221457765.png" alt="image-20211122145730701"></p>
<p><img src="https://image.im0o.top/files/202111221457474.png" alt="image-20211122145722409"></p>
<p><strong>偏移32H～35H处为更新数组</strong>，这4个字节很重要，它的作用如下：</p>
<p>因为上述的“更新序列号”的两个字节同时会出现在该文件记录<strong>第一个扇区最后两个字节处</strong>及该<strong>文件记录第二个扇区最后两个字节处</strong>，也就是事先占用了文件记录的4个字节，当文件记录中的信息需要往这4个字节处写入时，就跳转到了32H～35H处来写。</p>
<p>具体对应关系是：文件记录第一个扇区最后两个字节对应32H～33H处，文件记录第二个扇区最后两个字节对应34H～35H处</p>
<p><img src="https://image.im0o.top/files/202111221508707.png" alt="image-20211122150836628"></p>
<p>当信息还没有写入该文件记录第一个扇区最后两个字节处及该文件记录第二个扇区最后两个字节处时，更新数组处的4个字节就为0。</p>
<h2 id="文件记录中属性的结构"><a href="#文件记录中属性的结构" class="headerlink" title="文件记录中属性的结构"></a>文件记录中属性的结构</h2><h3 id="属性的类型"><a href="#属性的类型" class="headerlink" title="属性的类型"></a>属性的类型</h3><p>文件记录由两部分构成，一部分是文件记录头，另一部分是属性列表。在 NTFS 文件系统中所有与文件相关的数据均被认为是属性，包括文件的内容。文件记录是一个文件相对应的文件属性数据库，它记录了文件数据的所有属性。</p>
<p>每个文件记录中都有多个属性，它们相对独立，它们相对独立，有各自的类型和名称。一个属性开头的4个字节，为该属性的类型标志，不同的属性其结构和含义各不相同，下表为所有属性的类型和含义。</p>
<table>
<thead>
<tr>
<th align="center">属性类型（Little-Endian）</th>
<th align="center">属性类型名</th>
<th align="center">属性描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10 00 00 00</td>
<td align="center">$STANDARD_INFORMATION</td>
<td align="center">标准信息：包括一些基本文件属性，如只读、系统、存档；时间属性，如文件的创建时间和最后修改时间；有多少目录指向该文件（即其硬连接数（hard link count））</td>
</tr>
<tr>
<td align="center">20 00 00 00</td>
<td align="center">$ATTRIBUTE_LIST</td>
<td align="center">属性列表：当一个文件需要多个文件记录时，用来描述文件的属性列表</td>
</tr>
<tr>
<td align="center">30 00 00 00</td>
<td align="center">$FILE_NAME</td>
<td align="center">文件名：用Unicode字符表示的文件名，由于MS-DOS不能识别长文件名，所以NTFS系统会自动生成一个8.3文件名</td>
</tr>
<tr>
<td align="center">40 00 00 00</td>
<td align="center">$VOLUME_VERSION</td>
<td align="center">在早期的NTFS v1.2中为卷版本</td>
</tr>
<tr>
<td align="center">40 00 00 00</td>
<td align="center">$OBJECT_ID</td>
<td align="center">对象ID：一个具有64字节的标识符，其中最低的16字节对卷来说是唯一的（链接跟踪服务为外壳快捷方式，即OLE链接源文件赋予对象ID；NTFS提供的API是直接通过这些对象的ID而不是文件名来打开文件的）</td>
</tr>
<tr>
<td align="center">50 00 00 00</td>
<td align="center">$SECURITY_DESCRIPTOR</td>
<td align="center">安全描述符：这是为向后兼容而保留的，主要用于保护文件以防止没有授权的访问，但Windows 2000/XP中已将安全描述符存放在$Secure元数据中，以便于共享（早期的NTFS将其与文件目录一起存放，不便于共享）</td>
</tr>
<tr>
<td align="center">60 00 00 00</td>
<td align="center">$VOLUME_NAME</td>
<td align="center">卷名（卷标识）：该属性仅存在于$Volume元文件中</td>
</tr>
<tr>
<td align="center">70 00 00 00</td>
<td align="center">$VOLUME_INFORMATION</td>
<td align="center">卷信息：该属性仅存在于$Volume元文件中</td>
</tr>
<tr>
<td align="center">80 00 00 00</td>
<td align="center">$DATA</td>
<td align="center">文件数据：该属性为文件的数据内容</td>
</tr>
<tr>
<td align="center">90 00 00 00</td>
<td align="center">$INDEX_ROOT</td>
<td align="center">索引根</td>
</tr>
<tr>
<td align="center">A0 00 00 00</td>
<td align="center">$INDEX_ALLOCATION</td>
<td align="center">索引分配</td>
</tr>
<tr>
<td align="center">B0 00 00 00</td>
<td align="center">$BITMAP</td>
<td align="center">位图</td>
</tr>
<tr>
<td align="center">C0 00 00 00</td>
<td align="center">$SYMBOLIC_LINK</td>
<td align="center">在早期的NTFS v1.2中为符号链接</td>
</tr>
<tr>
<td align="center">C0 00 00 00</td>
<td align="center">$REPARSE_POINT</td>
<td align="center">重解析点</td>
</tr>
<tr>
<td align="center">D0 00 00 00</td>
<td align="center">$EA_INFORMATION</td>
<td align="center">扩充属性信息</td>
</tr>
<tr>
<td align="center">E0 00 00 00</td>
<td align="center">$EA</td>
<td align="center">扩充属性</td>
</tr>
<tr>
<td align="center">F0 00 00 00</td>
<td align="center">$PROPERTY_SET</td>
<td align="center">早期的NTFS v1.2中才有</td>
</tr>
<tr>
<td align="center">00 10 00 00</td>
<td align="center">$LOGGED_UTILITY_STREAM</td>
<td align="center">EFS加密属性：该属性主要用于存储实现EFS加密的有关加密信息，如合法用户列表、解码密钥等</td>
</tr>
</tbody></table>
<p>需要注意的是，上表中不是所有属性都会在一个文件记录中出现，属性有<strong>常驻和非常驻之分</strong>。当一个文件很小时，它的所有属性体都可以存放在$MFT的文件记录中，该属性就称为<strong>常驻属性</strong>。</p>
<p>有些属性总是常驻的，这样NTFS才可以确定其他非常驻属性，例如：标准信息属性和根索引属性就是常驻属性。</p>
<p>如果属性体能直接存放在$MFT中，那么访问该文件所需的时间将大大缩短，系统只需要访问磁盘一次即可获得数据；也就是文件的数据直接存放在文件记录的 $DATA 属性中（如果这个文件的数据大小+属性大小小于1KB的话）。</p>
<h3 id="属性的结构"><a href="#属性的结构" class="headerlink" title="属性的结构"></a>属性的结构</h3><p>每一个属性都可以分为两个部分，属性头和属性体。</p>
<p><img src="https://image.im0o.top/files/202111221522087.jpeg" alt="NTFS文件系统文件记录分析"></p>
<h4 id="属性头"><a href="#属性头" class="headerlink" title="属性头"></a>属性头</h4><p>每一个属性都有一个属性头，这个属性头包含了该属性的基本信息：</p>
<ul>
<li>属性类型</li>
<li>属性大小</li>
<li>属性名字（不是一定有的）</li>
<li>是否为常驻属性</li>
</ul>
<p>以下为常驻属性和非常驻属性的结构</p>
<ul>
<li>常驻属性：<br><img src="https://image.im0o.top/files/202111221539579.png" alt="image-20211122153959535"></li>
</ul>
<table>
<thead>
<tr>
<th align="center">字节偏移</th>
<th align="center">字段长度（字节）</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x00</td>
<td align="center">4</td>
<td align="center">属性类型（如90H、B0H等类型）</td>
</tr>
<tr>
<td align="center">0x04</td>
<td align="center">4</td>
<td align="center">包括属性头在内的本属性的长度（字节）</td>
</tr>
<tr>
<td align="center">0x08</td>
<td align="center">1</td>
<td align="center">是否为常驻属性（<strong>00表示常驻</strong>，<strong>01H表示非常驻</strong>）</td>
</tr>
<tr>
<td align="center">0x09</td>
<td align="center">1</td>
<td align="center">属性名长度（N）</td>
</tr>
<tr>
<td align="center">0x0A</td>
<td align="center">2</td>
<td align="center">属性名开始的偏移</td>
</tr>
<tr>
<td align="center">0x0C</td>
<td align="center">2</td>
<td align="center">压缩、加密、稀疏标志</td>
</tr>
<tr>
<td align="center">0x0E</td>
<td align="center">2</td>
<td align="center">属性ID</td>
</tr>
<tr>
<td align="center">0x10</td>
<td align="center">4</td>
<td align="center">属性体的长度（L）</td>
</tr>
<tr>
<td align="center">0x14</td>
<td align="center">2</td>
<td align="center">属性体的开始偏移</td>
</tr>
<tr>
<td align="center">0x16</td>
<td align="center">1</td>
<td align="center">索引标志</td>
</tr>
<tr>
<td align="center">0x17</td>
<td align="center">1</td>
<td align="center">无意义</td>
</tr>
<tr>
<td align="center">0x18</td>
<td align="center">2N</td>
<td align="center">属性的名字（如果没有名字 N=0，则该位置为属性体的内容）</td>
</tr>
<tr>
<td align="center">2N＋0x18</td>
<td align="center">L</td>
<td align="center">属性体的内容</td>
</tr>
</tbody></table>
<ul>
<li>非常驻属性</li>
</ul>
<p><img src="https://image.im0o.top/files/202111221540005.png" alt="image-20211122154051967"></p>
<table>
<thead>
<tr>
<th align="center">字节偏移</th>
<th align="center">字段长度（字节）</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x00</td>
<td align="center">4</td>
<td align="center">属性类型（如80H、A0H等类型）</td>
</tr>
<tr>
<td align="center">0x04</td>
<td align="center">4</td>
<td align="center">包括属性头在内的本属性的长度（字节）</td>
</tr>
<tr>
<td align="center">0x08</td>
<td align="center">1</td>
<td align="center">是否为常驻属性（为01表示该属性为非常驻属性）</td>
</tr>
<tr>
<td align="center">0x09</td>
<td align="center">1</td>
<td align="center">属性名长度（N）</td>
</tr>
<tr>
<td align="center">0x0A</td>
<td align="center">2</td>
<td align="center">属性名开始的偏移</td>
</tr>
<tr>
<td align="center">0x0C</td>
<td align="center">2</td>
<td align="center">压缩、加密、稀疏标志</td>
</tr>
<tr>
<td align="center">0x0E</td>
<td align="center">2</td>
<td align="center">属性ID</td>
</tr>
<tr>
<td align="center">0x10</td>
<td align="center">8</td>
<td align="center">属性体的起始虚拟簇号（VCN）</td>
</tr>
<tr>
<td align="center">0x18</td>
<td align="center">8</td>
<td align="center">属性体的结束虚拟簇号</td>
</tr>
<tr>
<td align="center">0x20</td>
<td align="center">2</td>
<td align="center">Run List（Run即Data Run，是一个在逻辑簇号上连续的区域，它是不存储在MFT中的数据）信息的偏移地址</td>
</tr>
<tr>
<td align="center">0x22</td>
<td align="center">2</td>
<td align="center">压缩单位大小（2x簇，如果为0表示未压缩）</td>
</tr>
<tr>
<td align="center">0x24</td>
<td align="center">4</td>
<td align="center">无意义</td>
</tr>
<tr>
<td align="center">0x28</td>
<td align="center">8</td>
<td align="center">属性体的分配大小［该属性体占的大小，这个属性体大小是该属性体所有的簇所占的空间大小（字节）］</td>
</tr>
<tr>
<td align="center">0x30</td>
<td align="center">8</td>
<td align="center">属性体的实际大小（因为属性体长度不一定正好占满所有簇）</td>
</tr>
<tr>
<td align="center">0x38</td>
<td align="center">8</td>
<td align="center">属性体的初始大小</td>
</tr>
<tr>
<td align="center">0x40</td>
<td align="center">2N</td>
<td align="center">该属性的属性名（如果没有名字 N=0，则该位置为属性体的内容）</td>
</tr>
<tr>
<td align="center">2N＋0x40</td>
<td align="center"></td>
<td align="center">属性的Run List信息，它记录了属性体开始的簇号、簇数等信息</td>
</tr>
</tbody></table>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Winhex数据恢复教程</category>
      </categories>
      <tags>
        <tag>数据恢复</tag>
        <tag>NTFS</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Vercel + github 部署 hexo 博客</title>
    <url>/posts/2ace8b97.html</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>本站已迁移至 Vercel 页面托管服务，博客链接更新为 <a href="https://blog.im0o.top/">blog.im0o.top</a>。</p>
<h1 id="什么是-Vercel"><a href="#什么是-Vercel" class="headerlink" title="什么是 Vercel"></a>什么是 Vercel</h1><p>Vercel 类似于 github page，但远比 github page 强大，速度也快得多得多，而且将 Github 授权给 Vercel 后，可以达到最优雅的发布体验，只需将代码轻轻一推，项目就自动更新部署了。</p>
<p>这意味着，你无需配置繁琐的 Github Actions，只需要将代码推送至你的仓库（可以是私有的），Vercel 会自动克隆代码并按照设定的方式部署。</p>
<h1 id="什么是-Hexo"><a href="#什么是-Hexo" class="headerlink" title="什么是 Hexo"></a>什么是 Hexo</h1><p>Hexo 是一个基于 Node.js 的博客框架，它可以轻松地创建博客，并且支持 Markdown 语法。</p>
<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><p>在开始部署之前，需要先安装 Node.js、Git、yarn(如果需要)、hexo，并且拥有一个有效的 Github 账户。</p>
<p>如果你使用的是 Windows 系统，需要安装 <a href="https://gitforwindows.org/">Git for Windows</a>。</p>
<h2 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h2><p>你可以通过以下方式安装 Node.js：</p>
<ul>
<li><p><a href="https://nodejs.org/en/download/">官方安装方式</a></p>
<p>直接下载安装 Node.js。</p>
</li>
<li><p>使用 scoop 包管理器安装 Node.js</p>
<p>如果你使用 scoop 包管理器，需要先安装 scoop 包管理器，然后在命令行中执行 <code>scoop install nodejs</code> 命令即可。</p>
</li>
<li><p>使用其他包管理器安装 Node.js</p>
</li>
</ul>
<p><img src="https://image.im0o.top/files/202111192000747.png" alt="image-20211119200043508"></p>
<h2 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h2><p>你可以参考 <a href="https://hexo.io/zh-cn/docs/#%E5%AE%89%E8%A3%85">文档 | Hexo</a> 中的步骤进行安装。</p>
<p>使用以下指令，即可通过 Yarn 包管理，进行全局安装 hexo 脚手架。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Yarn</span></span><br><span class="line">yarn global add hexo-cli</span><br><span class="line"><span class="meta">#</span><span class="bash"> Npm</span></span><br><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p>以下为安装日志，安装成功后使用 <code>hexo -v</code> 即可查看安装好的 hexo-cli 的版本。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> -&gt;yarn global add hexo<span class="literal">-cli</span></span><br><span class="line">yarn global v1.<span class="number">22.17</span></span><br><span class="line">[<span class="number">1</span>/<span class="number">4</span>] Resolving packages...</span><br><span class="line">[<span class="number">2</span>/<span class="number">4</span>] Fetching packages...</span><br><span class="line">[<span class="number">3</span>/<span class="number">4</span>] Linking dependencies...</span><br><span class="line">[<span class="number">4</span>/<span class="number">4</span>] Building fresh packages...</span><br><span class="line"></span><br><span class="line">success Installed <span class="string">&quot;hexo-cli@4.3.0&quot;</span> with binaries:</span><br><span class="line">      - hexo</span><br><span class="line">Done <span class="keyword">in</span> <span class="number">11.01</span>s.</span><br><span class="line"></span><br><span class="line"><span class="built_in">PS</span> -&gt;hexo <span class="literal">-v</span></span><br><span class="line">hexo<span class="literal">-cli</span>: <span class="number">4.3</span>.<span class="number">0</span></span><br><span class="line">os: win32 <span class="number">10.0</span>.<span class="number">19041</span></span><br><span class="line">node: <span class="number">16.13</span>.<span class="number">0</span></span><br><span class="line">v8: <span class="number">9.4</span>.<span class="number">146.19</span><span class="literal">-node</span>.<span class="number">13</span></span><br><span class="line">uv: <span class="number">1.42</span>.<span class="number">0</span></span><br><span class="line">zlib: <span class="number">1.2</span>.<span class="number">11</span></span><br><span class="line">brotli: <span class="number">1.0</span>.<span class="number">9</span></span><br><span class="line">ares: <span class="number">1.17</span>.<span class="number">2</span></span><br><span class="line">modules: <span class="number">93</span></span><br><span class="line">nghttp2: <span class="number">1.45</span>.<span class="number">1</span></span><br><span class="line">napi: <span class="number">8</span></span><br><span class="line">llhttp: <span class="number">6.0</span>.<span class="number">4</span></span><br><span class="line">openssl: <span class="number">1.1</span>.<span class="number">1</span>l+quic</span><br><span class="line">cldr: <span class="number">39.0</span></span><br><span class="line">icu: <span class="number">69.1</span></span><br><span class="line">tz: <span class="number">2021</span>a</span><br><span class="line">unicode: <span class="number">13.0</span></span><br><span class="line">ngtcp2: <span class="number">0.1</span>.<span class="number">0</span><span class="literal">-DEV</span></span><br><span class="line">nghttp3: <span class="number">0.1</span>.<span class="number">0</span><span class="literal">-DEV</span></span><br></pre></td></tr></table></figure>

<h1 id="初始化-Hexo-项目"><a href="#初始化-Hexo-项目" class="headerlink" title="初始化 Hexo 项目"></a>初始化 Hexo 项目</h1><p>新建一个文件夹，用于存放你 Hexo 博客的所有内容。</p>
<p>输入以下指令，初始化该文件夹为一个 Hexo 博客项目。</p>
<blockquote>
<p>首先使用 <code>git init</code> 将其初始化为一个 Git 项目，便于后续上传到仓库进行自动构建。</p>
</blockquote>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> &gt; git init</span><br><span class="line"><span class="built_in">PS</span> &gt; hexo init</span><br></pre></td></tr></table></figure>

<p>你可以使用指令  <code>hexo s</code> 或 <code>hexo server</code> 在本地运行你的博客，默认地址为 <code>localhost:4000</code> ，用浏览器打开即可看到你的博客，与一篇默认的 <strong>Hello World</strong> 文章。</p>
<p><img src="https://image.im0o.top/files/202111192024878.png" alt="image-20211119202401759"></p>
<div class="note modern"><p>本篇的重点不在搭建 Hexo 博客上，与本地的 Hexo 有关内容到此结束</p>
</div>

<h1 id="新建-Github-仓库"><a href="#新建-Github-仓库" class="headerlink" title="新建 Github 仓库"></a>新建 Github 仓库</h1><p>新建一个 Github 仓库，用于存放博客源码，这个仓库可以是私有（Private）的，也可以是公开（public）的。</p>
<p><img src="https://image.im0o.top/files/202111201808414.png" alt="image-20211120180825316"></p>
<p>将本地博客 push 到你刚刚新建的 Github 仓库中。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="built_in">PS</span> &gt; git add .</span><br><span class="line"><span class="built_in">PS</span> &gt; git commit <span class="literal">-m</span> <span class="string">&quot;first commit&quot;</span></span><br><span class="line"><span class="built_in">PS</span> &gt; git branch <span class="literal">-M</span> main</span><br><span class="line"><span class="built_in">PS</span> &gt; git remote add origin https://github.com/你的仓库地址.git</span><br><span class="line"><span class="built_in">PS</span> &gt; git push <span class="literal">-u</span> origin main</span><br></pre></td></tr></table></figure>

<p>部署好后即可在仓库中看到你的 hexo 源码</p>
<p><img src="https://image.im0o.top/files/202111201815943.png" alt="image-20211120181518872"></p>
<h1 id="将源码部署至-Vercel"><a href="#将源码部署至-Vercel" class="headerlink" title="将源码部署至 Vercel"></a>将源码部署至 Vercel</h1><p>从 <a href="https://vercel.com/login">Login – Vercel</a> 登录你的 Vercel（推荐选择 Continue with Github，使用 Github 登录）</p>
<p><img src="https://image.im0o.top/files/202111201816069.png" alt="image-20211120181623985"></p>
<p>点击 dashboard 中的 New Project 即可新建一个 Vercel 项目。</p>
<p><img src="https://image.im0o.top/files/202111201827112.png" alt="image-20211120182745063"></p>
<p><img src="https://image.im0o.top/files/202111201828122.png" alt="image-20211120182804041"></p>
<p>你可以在这里看到你最近新建的仓库，点击仓库右边的 Import 按钮，导入仓库至 Vercel。</p>
<p><img src="https://image.im0o.top/files/202111201829826.png" alt="image-20211120182903730"></p>
<p>Vercel 自动识别了这个仓库是一个 Hexo 项目，如果你没有对你的 Hexo 项目做更改，可以直接使用默认配置，直接点击 Deploy 按钮部署。</p>
<p>成功部署后的页面如下。</p>
<p><img src="https://image.im0o.top/files/202111201831135.png" alt="image-20211120183109037"></p>
<p>点击 Go to Dashboard，即可前往该项目的控制面板。</p>
<p><img src="https://image.im0o.top/files/202111201831345.png" alt="image-20211120183158265"></p>
<p>DOMAINS 下的链接即为你的博客的访问链接，左边为该网站的预览图片。</p>
<h1 id="解析域名至-Vercel"><a href="#解析域名至-Vercel" class="headerlink" title="解析域名至 Vercel"></a>解析域名至 Vercel</h1><p>你可以点击 Vercel 项目中的 Settings -&gt; Domains，将你的域名解析至 Vercel 部署的网页上。</p>
<p><img src="https://image.im0o.top/files/202111201833047.png" alt="image-20211120183351987"></p>
<p>输入你的域名（可以是二级域名）后点击右方的 Add 按钮，即可绑定域名至该项目.</p>
<p><img src="https://image.im0o.top/files/202111201835591.png" alt="image-20211120183529536"></p>
<p>此时，页面提示了 Invaild Configuration，原因是域名没有解析至 Vercel。</p>
<p>推荐使用 CNAME 记录进行解析。</p>
<p>按图中样式，添加一个 CNAME 记录，记录名为 testblogproject（本例为这个），记录值为 cname.Vercel-dns.com。</p>
<p>如果是 CloudFlare DNS，不要使用 CF 代理（因为 Vercel 本身速度足够快了，如果用 CF 代理，访问速度反而会变慢）。</p>
<p><img src="https://image.im0o.top/files/202111201839707.png" alt="image-20211120183907656"></p>
<p>保存后刷新 Dashboard-Settings-Domains 页面，你可以看到该域名不再报错，且正在生成 SSL证书。</p>
<p><img src="https://image.im0o.top/files/202111201840258.png" alt="image-20211120184014215"></p>
<p>访问 testblogproject.im0o.top，看到先前测试时的页面，证明部署成功了。</p>
<p><img src="https://image.im0o.top/files/202111201841803.png" alt="image-20211120184115590"></p>
<h1 id="更新博客内容"><a href="#更新博客内容" class="headerlink" title="更新博客内容"></a>更新博客内容</h1><p>以后更新博客，只需要在本地写好内容，将代码推到 Github 仓库，Vercel 会自动编译部署最新的代码（在默认分支）。</p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>一些教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Github</tag>
        <tag>Vercel</tag>
      </tags>
  </entry>
  <entry>
    <title>ClipboardBypass - 绕过超星学习通粘贴限制</title>
    <url>/posts/b84fa704.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在网页版超星学习通中进行答题时，填空题被限制不允许从剪贴板粘贴，防止关闭 Javascript 会影响到其他功能，于是使用 AutoHotKey 编写了一个简单的粘贴脚本</p>
<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p><img src="https://image.im0o.top/files/202111021220119.png" alt="image-20211102122043065"></p>
<h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p>在使用快捷键 <code>Ctrl+V</code> 粘贴时，将以键入形式逐字输出剪贴板内复制的文本</p>
<div class="note warning modern"><p>该功能仅替换 <code>Ctrl+V</code> 快捷键，且不支持文字以外的数据</p>
<p>但不替换 <code>右键-粘贴</code> 方式进行粘贴。</p>
</div>

<h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p><a href="https://im0o-1254018364.cos.ap-nanjing.myqcloud.com/blog/ClipboardBypass.exe">国内加速下载</a> | <a href="im0o-1254018364.cos.accelerate.myqcloud.com">全球加速下载</a> | <a href="https://www.dropbox.com/s/7b8egod7d43p2qe/ClipboardBypass.exe?dl=0">Dropbox</a></p>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><blockquote class="pullquote mindmap mindmap-md mdmap"><ul>
<li>ClipBoardBypass<ul>
<li>按下 Ctrl + V 时<ul>
<li>（以键入形式）输出剪贴板的内容</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>

<h1 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h1><figure class="highlight ahk"><table><tr><td class="code"><pre><span class="line"><span class="built_in">MsgBox,</span> <span class="number">64</span>, Little Tool, 绕过网页版学习通阻止剪贴板功能开启`n尝试直接复制粘贴数据即可`n注意：不支持粘贴图片</span><br><span class="line"></span><br><span class="line"><span class="title">^v::</span>Send <span class="variable">%clipboard%</span></span><br></pre></td></tr></table></figure>

<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
  </entry>
  <entry>
    <title>使用Winhex进行数据恢复（5）</title>
    <url>/posts/cf3fde42.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本节我们将了解 <strong>NTFS</strong> 格式分区的结构、引导扇区、以及元文件 <strong>$MFT</strong>。</p>
<blockquote>
<p><strong>你可以在 <a href="https://im0o.top/winhex-tiku/">https://im0o.top/winhex-tiku/</a> 中查看所有例题文件</strong></p>
</blockquote>
<h1 id="知识点总览"><a href="#知识点总览" class="headerlink" title="知识点总览"></a>知识点总览</h1><ul>
<li>NTFS 文件系统的大致结构</li>
<li>NTFS 文件系统的 DBR 恢复</li>
<li>NTFS 文件系统的元文件 $MFT </li>
</ul>
<h1 id="NTFS-文件系统的结构"><a href="#NTFS-文件系统的结构" class="headerlink" title="NTFS 文件系统的结构"></a>NTFS 文件系统的结构</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>NTFS 文件系统与 FAT32 文件系统一样，都是以<strong>簇</strong>为基本单位对磁盘空间和文件存储进行管理。一个文件总是占有若干个簇，即使在最后一个簇没有完全使用完的情况下，也会占用整个簇的空间。</p>
<p><img src="https://image.im0o.top/files/202110270902771.png" alt="image-20211027090228717"></p>
<p>这也能解释为何文件的占用空间总是大于文件大小，也是造成磁盘空间浪费的主要原因。</p>
<blockquote>
<p>文件系统通过簇来管理磁盘，并不需要知道磁盘扇区的大小，这样就使 NTFS 保持了与磁盘扇区大小的独立性，从而使不同大小的磁盘选择合适的簇。</p>
</blockquote>
<h2 id="簇的大小与卷大小的关系"><a href="#簇的大小与卷大小的关系" class="headerlink" title="簇的大小与卷大小的关系"></a>簇的大小与卷大小的关系</h2><p>在 NTFS 文件系统中，当一个簇占用的空间太小时，会出现太多的磁盘碎片，这样在空间和访问文件的时间会造成浪费；而相反的当一个簇占用的空间太大时，直接造成了磁盘空间的浪费。因此，最大限度地优化系统对文件的访问速度和最大限度地减少磁盘地浪费是确定簇大小地主要因素。<strong>簇地大小一定是扇区大小地整数倍</strong>，通常是 2^n（n为整数）。</p>
<p>下表为 NTFS 文件系统中不同卷地大小和簇地一般关系（大都数情况下都是这样，并不是完全一定的，为系统格式化磁盘地默认情况）</p>
<table>
<thead>
<tr>
<th align="center">卷大小（MB）</th>
<th align="center">每簇扇区数</th>
<th align="center">默认簇大小</th>
</tr>
</thead>
<tbody><tr>
<td align="center">≤512</td>
<td align="center">1</td>
<td align="center">512字节</td>
</tr>
<tr>
<td align="center">513~1024</td>
<td align="center">2</td>
<td align="center">1024字节（1KB）</td>
</tr>
<tr>
<td align="center">1025~2048</td>
<td align="center">4</td>
<td align="center">2048个字节（2KB）</td>
</tr>
<tr>
<td align="center">≥2049</td>
<td align="center">8</td>
<td align="center">4KB</td>
</tr>
</tbody></table>
<blockquote>
<p>通常情况下，只要分区大于2GB，每簇扇区数为 8</p>
</blockquote>
<h2 id="DBR-引导扇区"><a href="#DBR-引导扇区" class="headerlink" title="DBR 引导扇区"></a>DBR 引导扇区</h2><p>和 FAT 文件系统一样，NTFS 的第一个扇区为<strong>引导扇区</strong>，即 DBR 扇区。其中有 NTFS 分区的引导程序和一些 BPB 参数，系统根据这些 BPB 参数来得到分区的重要信息。如果没有这些信息，分区将不能正常使用。</p>
<h2 id="BOOT-文件"><a href="#BOOT-文件" class="headerlink" title="$BOOT 文件"></a>$BOOT 文件</h2><p>在 DBR 后15个扇区为 NTLDR 区域，这16个扇区共同构成了 $BOOT 文件。</p>
<h2 id="MFT-文件"><a href="#MFT-文件" class="headerlink" title="$MFT 文件"></a>$MFT 文件</h2><p>在 NTLDR 后（不一定是物理上相连的）是主文件表（Master File Table，MFT）区域，主文件表由文件记录构成，每个文件记录占2个扇区，文件记录简称为FR（File Record）。</p>
<p>在 NTFS 文件系统中，文件名、扩展名、建立时间、访问时间、修改时间、文件属性、文件大小、文件在磁盘中所占用的簇等信息称之为属性，各种属性被放入文件记录中进行管理。当一个属性太大，文件记录中存放不下时，就会<strong>分配多个文件记录进行存放</strong>；而当一个文件非常小时，可能这个文件的所有属性都包含在一个文件记录中了，甚至<strong>包括了这个文件的数据</strong>，这样做的好处是节约了磁盘空间并提高了文件访问效率。</p>
<h2 id="其他元文件"><a href="#其他元文件" class="headerlink" title="其他元文件"></a>其他元文件</h2><p>NTFS 文件系统中的主文件表（$MFT）中还记录了一些非常重要的数据，这些数据被称为元数据文件（metadata file），简称为<strong>“元文件”</strong>，其中包括了用于文件定位和恢复的数据结构、引导程序数据及整个卷的分配位图等信息。</p>
<p>在 NTFS 文件系统中，这样的文件主要有16个：</p>
<ul>
<li><strong>$MFT</strong>（主文件表，是每个文件的索引）</li>
<li><strong>$MFTMirr</strong>（主文件表镜像）</li>
<li><strong>$LogFile</strong>（日志文件）</li>
<li><strong>$Volume</strong>（卷文件）</li>
<li><strong>$AttrDef</strong>（属性定义表）</li>
<li><strong>$Root</strong>（根目录）</li>
<li><strong>$Bitmap</strong>（位图文件）</li>
<li><strong>$Boot</strong>（引导文件）</li>
<li><strong>$BadClus</strong>（坏簇文件）</li>
<li><strong>$Secure</strong>（安全文件）</li>
<li><strong>$UpCase</strong>（大写文件）</li>
<li><strong>$Extended metadata directory</strong>（扩展元数据文件）<ul>
<li><strong>$Extend\$Reparse</strong>（重解析点文件）</li>
<li><strong>$Extend\$UsnJrnl</strong>（变更日志文件）</li>
<li><strong>$Extend\$Quota</strong>（配额管理文件）</li>
<li>**$Extend\$ObjId$**（对象ID文件）</li>
</ul>
</li>
</ul>
<p>在这16项记录之后就是用户建立的文件和文件夹的记录了。</p>
<h2 id="NTFS文件系统大致结构"><a href="#NTFS文件系统大致结构" class="headerlink" title="NTFS文件系统大致结构"></a>NTFS文件系统大致结构</h2><p><img src="https://image.im0o.top/files/202110271446914.jpeg" alt="image-20211027143633341"></p>
<div class="note modern"><p>上图的结构只是 NTFS 文件系统的示意图，并不成完全比例；</p>
<p>元文件在图中只体现了一部分，没有画完整，并且除了$BOOT文件以外，其他元文件的位置不是固定的，例如$MFT文件也可以在$MFTMirr文件之后。</p>
<p>在NTFS文件系统所在分区的最后一个扇区是DBR的备份，但该扇区并不属于NTFS文件系统。</p>
</div>

<h1 id="NTFS-文件系统的-DBR-恢复"><a href="#NTFS-文件系统的-DBR-恢复" class="headerlink" title="NTFS 文件系统的 DBR 恢复"></a>NTFS 文件系统的 DBR 恢复</h1><p>NTFS文件系统的引导扇区是**$Boot<strong>的</strong>第一个扇区**，它的结构与FAT文件系统的DBR类似，所以习惯上也称该扇区为DBR扇区。DBR扇区在操作系统的引导过程起着非常重要的作用，如果这个扇区遭到破坏，系统将不能正常启动。</p>
<p>NTFS文件系统的DBR扇区与FAT文件系统的结构一样，也包括跳转指令、OEM代号、BPB参数、引导程序和结束标志。</p>
<p><img src="https://image.im0o.top/files/202110271813498.jpeg" alt="NTFS文件系统引导扇区分析"></p>
<ol>
<li><h2 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a><strong>跳转指令</strong></h2></li>
</ol>
<p>跳转指令本身2字节，它将程序执行流程跳转到引导程序处。例如，当前DBR中的“EB 52”，就是代表汇编语言的“JMP 52”。</p>
<div class="note modern"><p>注意：该指令本身占用2字节，计算跳转目标地址时以该指令的下一字节为基准，所以实际执行的下一条指令应该位于54H。紧接着跳转指令的是一条空指令NOP（90H）。</p>
</div>

<ol start="2">
<li><h2 id="OEM代号"><a href="#OEM代号" class="headerlink" title="OEM代号"></a>OEM代号</h2></li>
</ol>
<p>这部分占8个字节，其内容有创建该文件系统的OEM厂商具体安排。例如，微软的Windows系统将此处直接设置为“NTFS”，在NTFS文件系统中也称为“文件系统ID”。</p>
<ol start="3">
<li><h2 id="BPB（BIOS-Parameter-Block，BPB参数）"><a href="#BPB（BIOS-Parameter-Block，BPB参数）" class="headerlink" title="BPB（BIOS Parameter Block，BPB参数）"></a>BPB（BIOS Parameter Block，BPB参数）</h2></li>
</ol>
<p>BPB 从 DBR 的第12（0BH偏移处）个字节开始，到偏移53H结束，共占用73个字节，记录了有关该文件系统的重要信息。</p>
<p><img src="https://image.im0o.top/files/202110271835264.jpeg" alt="NTFS文件系统引导扇区分析"></p>
<p>（1）<strong>0BH～0CH：每扇区字节数</strong></p>
<p>每扇区字节数记录每个逻辑扇区的大小，其常见值为512字节，但512并不是固定值，该值可以由程序定义，合法值包括512字节、1024字节、2048字节和4096字节。</p>
<p>（2）<strong>0DH～0DH：每簇扇区数</strong></p>
<p>每簇扇区数记录着文件系统的簇大小，即由多少个扇区组成一个簇。</p>
<p>如果这个分区是在系统安装前被格式化而来的，一般大于2GB的分区每簇默认占用8个扇区，也就是每簇大小为4KB，这个字节的内容就为十六进制值“08”。如果这个分区是由一个FAT分区转换而来，则每个簇一般占用1个扇区的空间，也就是每簇大小为512字节，这个字节的内容就是“01H”。</p>
<p>在NTFS文件系统中所有的簇从0开始进行编号，每个簇都有一个自己的地址编号，并且从分区的第一个扇区就开始编簇。</p>
<p>（3）<strong>0EH～0FH：DBR保留扇区数</strong></p>
<p>NTFS文件系统中DBR没有保留扇区，该值常为“0000”。</p>
<p>（4）10H～12H：总是0</p>
<p>这3个字节总是“00 00 00”。</p>
<p>（5）13H～14H：未用</p>
<p>这两个字节不用。</p>
<p>（6）15H～15H：介质描述符</p>
<p>这个字节为介质描述字节，一般硬盘为“F8H”；双面5.25英寸软盘为“F9H”；双面3.5英寸软盘RAM虚拟盘为“FAH”；3.5英寸、1.44MB的软盘一般为“F0H”。因为NTFS分区一定在硬盘上，所以此处常为16进制数“F8”。</p>
<p>（7）16H～17H：未用</p>
<p>这两个字节不用。</p>
<p>（8）18H～19H：每磁道扇区数</p>
<p>这是逻辑C/H/S中的一个参数，其值一般为63，NTFS已经不用此参数。</p>
<p>（9）1AH～1BH：磁头数</p>
<p>这是逻辑C/H/S中的一个参数，其值一般为255，NTFS已经不用此参数。</p>
<p>（10）<strong>1CH～1FH：隐藏扇区数</strong></p>
<p>隐藏扇区数是指本分区之前使用的扇区数，该值与分区表中所描述的该分区的起始扇区号一致。对于主磁盘分区来讲，是MBR到该分区DBR之间的扇区数；对于扩展分区中的逻辑驱动器来讲，是其EBR到该分区DBR之间的扇区数。</p>
<p>（11）20H～23H：未用</p>
<p>这4字节不用。</p>
<p>（12）24H～27H：未用</p>
<p>这4字节不用，但总为80008000。</p>
<p>（13）<strong>28H～2FH：扇区总数</strong></p>
<p>扇区总数是指分区的总扇区数。NTFS的BPB中记录的分区大小比分区表中记录的少一个扇区，因为分区最后一个扇区留给DBR备份使用了。</p>
<p>（14）<strong>30H～37H：$MFT的起始簇号</strong></p>
<p>这8字节为$MFT的起始簇号，注意这个位置使用簇号定义的，而不是扇区号，并且该地址不是固定值。</p>
<p>（15）<strong>38H～3FH：$MFTMirr的起始簇号</strong></p>
<p>这8字节为$MFTMirr的起始簇号，这个位置也使用簇号定义，而不是扇区号。$MFTMirr的地址也不是固定值的，可以在$MFT之后，也可以在$MFT之前。本例中，$MFTMirr的地址就在$MFT之前。</p>
<p>（16）40H～40H：文件记录的大小描述</p>
<p>这一个字节描述每个文件记录的簇数。注意该参数为带符号数，当其是负数时，说明每个文件记录的大小要小于每簇扇区数，在这种情况下，文件记录的大小用字节数表示，计算方法为：2-1×每个文件记录的簇数。例如，图4-401的DBR中该参数值为“F6H”，换算为十进制等于“-10”，所以每个文件记录的大小是2-1×-10＝210＝1024字节。</p>
<p>（17）41H～43H：未用</p>
<p>这3字节不用。</p>
<p>（18）44H～44H：索引缓冲的大小描述</p>
<p>这一个字节描述每个索引缓冲的簇数。注意该参数也是带符号数，当其是负数时，说明每个索引缓冲的大小要小于每簇扇区数，在这种情况下，索引缓冲的大小用字节数表示，计算方法为：2-1×每个索引缓冲的簇数。</p>
<p>（19）45H～47H：未用</p>
<p>这3字节不用。</p>
<p>（20）48H～4FH：卷序列号</p>
<p>这8字节为分区的逻辑序列号，也就是在命令行下输入DIR命令后显示的一排数据，这个序列号是硬盘格式化时随机产生的。</p>
<p>（21）50H～51H：校验和</p>
<p>BPB的最后四个字节是其校验和，一般都为0。</p>
<ol start="4">
<li><h2 id="引导程序"><a href="#引导程序" class="headerlink" title="引导程序"></a>引导程序</h2></li>
</ol>
<p>NTFS的DBR引导程序占用426字节（54H～1FDH），其负责完成将系统文件NTLDR装入。对于一个没有安装操作系统的分区来讲，这段程序没有用处。</p>
<ol start="5">
<li><h2 id="结束标志"><a href="#结束标志" class="headerlink" title="结束标志"></a>结束标志</h2></li>
</ol>
<p>DBR的结束标志与MBR、EBR的结束标志都相同，为<code>55 AA</code>。</p>
<div class="note info modern"><p>以上5个部分共占用512字节，正好是1个扇区，这个扇区属于$BOOT文件的组成部分。该部分的内容中除了第5部分结束标志是固定不变之外，其余4部分都是不完全确定的，都因操作系统版本的不同而不同，也因硬盘的逻辑盘参数的变化而变化。</p>
</div>

<h2 id="恢复-NTFS-DBR"><a href="#恢复-NTFS-DBR" class="headerlink" title="恢复 NTFS DBR"></a>恢复 NTFS DBR</h2><p>如果 $BOOT 的第一个扇区（引导扇区）损坏，我们可以进行参数的填写，以恢复 NTFS DBR。</p>
<h3 id="从备份复制"><a href="#从备份复制" class="headerlink" title="从备份复制"></a>从备份复制</h3><p>通过解析元文件，计算出分区大小，从 DBR 位置跳转大小后找到该分区的备份，复制备份至DBR即可。</p>
<h3 id="手动填写"><a href="#手动填写" class="headerlink" title="手动填写"></a>手动填写</h3><p>计算BPB参数，进行手工填写<strong>跳转指令、BPB参数、结束标志</strong>以恢复NTFS分区</p>
<h3 id="从别的NTFS-DBR复制"><a href="#从别的NTFS-DBR复制" class="headerlink" title="从别的NTFS DBR复制"></a>从别的NTFS DBR复制</h3><p>在分区大小≥2GB时，我们可以直接复制一个现有的 NTFS DBR 至需要恢复的引导扇区处，修改位置、大小参数（有些需要修改每簇扇区数、MFT、MFTMirr位置等）即可恢复其DBR。</p>
<h1 id="NTFS-文件系统的元文件-MFT"><a href="#NTFS-文件系统的元文件-MFT" class="headerlink" title="NTFS 文件系统的元文件 $MFT"></a>NTFS 文件系统的元文件 $MFT</h1><p>将一个分区格式化为NTFS后，格式化程序会往该分区中写入很多重要的系统信息，这些系统信息在NTFS文件系统中称为<strong>元文件</strong>。这些元文件用户是不能访问的，它们的文件名的第一个字符都是<strong>“$”</strong>，表示该文件是隐藏的，用户无法访问和修改。</p>
<p>在 NTFS 文件系统中，元文件主要有16个。</p>
<table>
<thead>
<tr>
<th align="center">序号</th>
<th>元文件</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0</td>
<td>$MFT</td>
<td>主文件表本身，是每个文件的索引</td>
</tr>
<tr>
<td align="center">1</td>
<td>$MFTMirr</td>
<td>主文件表的部分镜像</td>
</tr>
<tr>
<td align="center">2</td>
<td>$LogFile</td>
<td>事务型日志文件</td>
</tr>
<tr>
<td align="center">3</td>
<td>$Volume</td>
<td>卷文件，记录卷标等信息</td>
</tr>
<tr>
<td align="center">4</td>
<td>$AttrDef</td>
<td>属性定义列表文件</td>
</tr>
<tr>
<td align="center">5</td>
<td>$Root</td>
<td>根目录文件，管理根目录</td>
</tr>
<tr>
<td align="center">6</td>
<td>$Bitmap</td>
<td>位图文件，记录了分区中簇的使用情况</td>
</tr>
<tr>
<td align="center">7</td>
<td>$Boot</td>
<td>引导文件，记录了用于系统引导的数据情况</td>
</tr>
<tr>
<td align="center">8</td>
<td>$BadClus</td>
<td>坏簇列表文件</td>
</tr>
<tr>
<td align="center">9</td>
<td>$Quota（NTFS4）</td>
<td>在早期的Windows NT系统中此文件为磁盘配额信息</td>
</tr>
<tr>
<td align="center">10</td>
<td>$Secure</td>
<td>安全文件</td>
</tr>
<tr>
<td align="center">11</td>
<td>$UpCase</td>
<td>大小写字符转换表文件</td>
</tr>
<tr>
<td align="center">12</td>
<td>$Extend metadata directory</td>
<td>扩展元数据目录</td>
</tr>
<tr>
<td align="center">13</td>
<td>$Extend$Reparse</td>
<td>重解析点文件</td>
</tr>
<tr>
<td align="center">14</td>
<td>$Extend$UsnJrnl</td>
<td>加密日志文件</td>
</tr>
<tr>
<td align="center">15</td>
<td>$Extend$Quota</td>
<td>配额管理文件</td>
</tr>
<tr>
<td align="center">16</td>
<td>$Extend$ObjId</td>
<td>对象ID文件</td>
</tr>
</tbody></table>
<h2 id="MFT文件介绍"><a href="#MFT文件介绍" class="headerlink" title="$MFT文件介绍"></a>$MFT文件介绍</h2><p>每个文件都有一个文件记录，包括元文件本身，而主文件表（$MFT）就是专门用来存储文件记录的一个元文件，在$MFT中前16个文件记录总是元文件的纪录。16个元文件中主文件表（$MFT）是一个非常重要的元文件，它由文件记录构成，每个文件记录占用2个扇区。</p>
<p>由于$MFT文件本身的重要性，为了确保文件系统结构的可靠性，系统专门为它准备了一个镜像文件（**$MFTMirr<strong>），也就是$MFT中的第2个记录。不过这并</strong>不是$MFT的完整镜像<strong>，而是一个</strong>小部分镜像<strong>，一般只镜像$MFT中的</strong>前四个**文件记录。</p>
<p>$MFT中前16个文件记录总是元文件的记录，并且这16个文件记录的顺序是<strong>固定</strong>的，下面对这16个记录简单做一个介绍：</p>
<ul>
<li><p>第1个记录就是**<u>$MFT自身的记录</u>**，也就是说$MFT首先对自己进行管理。</p>
</li>
<li><p>第2个记录是**<u>$MFTMirr的记录</u><strong>，也就是$MFT</strong>前4个文件记录的镜像**。</p>
</li>
<li><p>第3个记录是<u><strong>日志文件（$LogFile）</strong></u>的记录，该文件是NTFS为实现可恢复性和安全性而设计的。当系统运行时，NTFS就会在日志文件中记录所有影响NTFS卷结构的操作，包括文件的创建和改变目录结构的命令，从而可在系统失败时能够恢复NTFS卷。</p>
</li>
<li><p>第4个记录是卷文件（$Volume）的记录，它包含卷名、NTFS的版本和一个标明该磁盘是否损坏的标志位，NTFS文件系统以此决定是否需要调用Chkdsk程序来进行修复。</p>
</li>
<li><p>第5个记录是属性定义表（$AttrDef，attribute definition table）的记录，其中存放着卷所支持的所有文件属性，并指出它们是否可以被索引和恢复等。</p>
</li>
<li><p>第6个记录是根目录（$ROOT）的记录，其中保存着该卷<strong>根目录下的所有文件和目录的索引</strong>。在访问一个文件后，NTFS就保留该文件的MFT引用，第二次就能够直接访问该文件。</p>
</li>
<li><p>第7个记录是<u><strong>位图文件（$Bitmap）</strong></u>的记录，NTFS卷的簇使用情况都保存在这个位图文件中，其中每一位（bit）代表卷中的一簇，标识该簇是空闲还是已分配。</p>
</li>
<li><p>第8个记录是<u><strong>引导文件（$Boot）</strong></u>的记录，该文件中存放着操作系统的引导程序代码。该文件必须位于特定的磁盘位置才能够正确地引导系统，一般都是位于卷的最前面。</p>
</li>
<li><p>第9个记录是坏簇文件（$BadClus）的记录，它记录着该卷中所有损坏的簇号，防止系统对其进行分配使用。</p>
</li>
<li><p>第10个记录是安全文件（$Secure）的记录，它存储着整个卷的安全描述符数据库。NTFS文件和目录都有各自的安全描述符，为节省空间，NTFS将文件和目录的相同描述符存放在此公共文件中。</p>
</li>
<li><p>第11个记录为大写文件（$UpCase，upper case file）的记录，该文件包含一个大小写字符转换表。</p>
</li>
<li><p>第12个记录是扩展元数据目录（$Extended metadata directory）的记录。</p>
</li>
<li><p>第13个记录是重解析点文件（$Extend$Reparse）的记录。</p>
</li>
<li><p>第14个记录是变更日志文件（$Extend$UsnJrnl）的记录。</p>
</li>
<li><p>第15个记录是配额管理文件（$Extend$Quota）的记录。</p>
</li>
<li><p>第16个记录是对象ID文件（$Extend$ObjId）的记录。</p>
</li>
<li><p>第17～23记录是系统保留的记录，暂时不用，用于将来扩展。</p>
</li>
<li><p>从第24个记录开始存放用户文件的记录。</p>
</li>
</ul>
<blockquote>
<p>$MFT文件在文件系统中的存放地址，可以通过BPB中的“$MFT开始簇号”之一参数值获得。</p>
</blockquote>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Winhex数据恢复教程</category>
      </categories>
      <tags>
        <tag>Winhex</tag>
        <tag>数据恢复</tag>
        <tag>FAT32</tag>
      </tags>
  </entry>
  <entry>
    <title>新Winhex数据恢复题库</title>
    <url>/posts/winhex-tiku.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>由于 Baklib 停止了题库服务的支持，故弃用其服务，改用 VuePress + GithubPages 服务搭建新的题库。</p>
<p>新的题库地址：<a href="https://im0o.top/winhex-tiku/">https://im0o.top/winhex-tiku/</a></p>
<p>题库中所有题目均可被转载使用，但请<strong>注明转载出处</strong> <code>im0o.top/winhex</code> 或 <code>im0o.top</code>，并且<strong>不可以商用</strong>。</p>
<h1 id="如何使用题库"><a href="#如何使用题库" class="headerlink" title="如何使用题库"></a>如何使用题库</h1><ol>
<li>在题库中下载题目。</li>
<li>打开 Windows 磁盘管理 （右键<strong>计算机</strong>→<strong>管理</strong>→<strong>磁盘管理</strong>）。</li>
</ol>
<p><img src="https://image.im0o.top/gitee/img/202110212007880.png" alt="image-20211021200703935"></p>
<ol start="3">
<li>右键点击磁盘管理，点击<strong>附加 VHD</strong>。</li>
</ol>
<p><img src="https://image.im0o.top/gitee/img/202110212007725.png" alt="image-20211021200757704"></p>
<ol start="4">
<li>选择<strong>下载解压好的题目路径</strong>，点击<strong>确定</strong>即可附加VHD至计算机。</li>
</ol>
<p><img src="https://image.im0o.top/gitee/img/202110212009358.png" alt="image-20211021200906703"></p>
<p>成功附加 VHD 后即可打开 Winhex，选择对应的虚拟磁盘进行数据恢复训练。</p>
<ol start="5">
<li>结束数据恢复后，<strong>分离 VHD 文件</strong>。</li>
</ol>
<div class="note info modern"><p><strong>VHD 为虚拟磁盘文件，在虚拟磁盘的分区中存放的文件实际将占用 VHD 文件的大小（动态扩展）</strong></p>
<p>所以请不要在 VHD 内存放文件，这将占用你实际文件位置的大小！</p>
</div>

<p><img src="https://image.im0o.top/gitee/img/202110212012766.png" alt="image-20211021201159183"></p>
<p>右键相应的<strong>虚拟磁盘</strong>，点击<strong>分离 VHD</strong> 即可，如果不希望题目占用您的存储空间，在分离后请记得删除该VHD文件。</p>
<p><img src="https://image.im0o.top/gitee/img/202110212013511.png" alt="image-20211021201328657"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p>本系列教程参考了以下资料文献。</p>
<ul>
<li>《数据恢复技术深度揭秘》刘伟编著，2010.5版，北京：电子工业出版社</li>
<li>张景生，汪中夏，刘伟. 《数据恢复方法及案例分析》，电子工业出版社</li>
<li>戴士剑. 《数据恢复技术》. 电子工业出版社</li>
<li>（美）理曼德. 《UNIX 编程艺术》. 电子工业出版社</li>
<li>Brain Carrier. 《File System Forensic Analysis》. Addison Wesley Professional</li>
<li>Apple 官方技术文档（<a href="http://developer.apple.com/%EF%BC%89">http://developer.apple.com/）</a>. Technical Note TN1150</li>
<li>ACE Laboratory. PC3000 User Manual</li>
<li>Vadim Morozov. Sergey Yatsenko. Modern Hard disk drive</li>
<li>《基于Winhex的HFS+文件提取方法研究》徐健，江苏联合职业技术学院扬州分院</li>
<li>《基于Ext3文件系统数据提取方法的研究》徐健，信息技术与信息化</li>
<li>《基于Ext4文件系统的数据提取方法研究》徐健，信息技术与信息化</li>
<li>《ExFAT被快速格式化成NTFS后数据恢复的研究》徐健，江苏联合职业技术学院扬州分院</li>
<li>《数据恢复高级技术》汪中夏，刘伟，电子工业出版社</li>
<li>《识数寻踪：Winhex 应用与数据恢复开发秘籍》高志鹏，张志伟，孙云峰，人民邮电出版社</li>
</ul>
<h1 id="打赏"><a href="#打赏" class="headerlink" title="打赏"></a>打赏</h1><p>Winhex 手工恢复数据教程系列为站长0o酱一人编写维护，感谢以上前辈们的资料与文献，欢迎点击下方打赏按钮对我进行支持。</p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Winhex数据恢复教程</category>
      </categories>
      <tags>
        <tag>Winhex</tag>
        <tag>数据恢复</tag>
        <tag>VuePress</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Winhex进行数据恢复（4）</title>
    <url>/posts/7783b927.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本节我们将进一步学习 <strong>FAT32</strong> 格式分区的损坏实例与恢复方式、技巧。</p>
<blockquote>
<p><strong>你可以在 <a href="https://im0o.top/winhex-tiku/">https://im0o.top/winhex-tiku/</a> 中查看所有例题文件</strong></p>
</blockquote>
<h1 id="知识点总览"><a href="#知识点总览" class="headerlink" title="知识点总览"></a>知识点总览</h1><ul>
<li>FAT32 文件系统删除文件的分析</li>
<li>FAT32 文件系统删除文件后目录项起始簇号高位清零的分析</li>
<li>实例：恢复 FAT32 中被删除的文件</li>
</ul>
<h1 id="FAT32-文件系统删除文件的分析"><a href="#FAT32-文件系统删除文件的分析" class="headerlink" title="FAT32 文件系统删除文件的分析"></a>FAT32 文件系统删除文件的分析</h1><p>本案例中，在 FAT32文件系统 中有文件 <strong>codingcat.gif</strong></p>
<p><img src="https://image.im0o.top/files/202110221237619.gif" alt="codingcat"></p>
<h2 id="文件删除前"><a href="#文件删除前" class="headerlink" title="文件删除前"></a>文件删除前</h2><p>从文件系统底层了解 FAT32 文件系统中文件各部分结构的管理。现在以 FAT32 分区中的文件 <strong>codingcat.gif</strong> 为例，讲解文件的底层结构。</p>
<p><img src="https://image.im0o.top/files/202110221242297.png" alt="image-20211022124227265"></p>
<p>上图为文件在资源管理器内的截图。</p>
<p><img src="https://image.im0o.top/files/202110221249851.png" alt="image-20211022124911497"></p>
<p>由于文件名超过了8个字符，目录项中就会存储两条名字，一条为长文件名目录项，一条为短文件名目录项。</p>
<p>从目录项中可以看出该文件开始于 <strong>05H</strong>（5号）簇，文件大小为 <strong>1A B7 78H</strong>（十进制为 1750904）字节。</p>
<p><img src="https://image.im0o.top/files/202110221307597.png" alt="image-20211022130738474"></p>
<p>FAT32 文件系统的 FAT 表是 32 位的，每个 FAT 项占用 <strong>4字节</strong>。</p>
<p><img src="https://image.im0o.top/files/202110221311651.png" alt="image-20211022131154308"></p>
<p>从上图 FAT表 中可以看出，文件codingcat.gif是连续存放的，该文件共占用了107个簇。</p>
<p>用Winhex跳转到分区的5号簇，其部分内容如图所示。</p>
<p><img src="https://image.im0o.top/files/202110221313076.png" alt="image-20211022131340664"></p>
<p>从5号簇开始，往后连续的 1750904 字节（ <strong>codingcat.gif</strong> 的文件大小），就是这个文件的所有数据。</p>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><p>首先使用 <code>Shift+Delete</code> 将文件 <strong>codingcat.gif</strong> 删除（不是放入回收站）</p>
<p><img src="https://image.im0o.top/files/202110221329502.png" alt="无标题"></p>
<p>删除后的文件目录项如图所示。</p>
<p><img src="https://image.im0o.top/files/202110221334660.png" alt="image-20211022133418736"></p>
<p>从上图看出，<strong>codingcat.gif</strong> 的文件目录项的第一个字节已经被改为 <strong>E5</strong> 了，而文件名的其他字节没有发生变化，文件起始簇号 <strong>05H</strong>（5号）簇看似没有改变，但因为 FAT32 文件系统是使用4个字节记录文件开始簇号的，当文件被删除后，文件开始簇号的高位2个字节是要<strong>清零</strong>的，所以 <strong>文件开始簇号</strong> 这个值实际上已经发生了改变，只是因为这个文件的高位簇部分本身就是 <strong>00 00H</strong>，所以看不出改变。另外文件大小 <strong>1A B7 78H</strong> （十进制为 1750904）字节没有改变。</p>
<p>在FAT表中查看原本 <strong>codingcat.gif</strong>占用的部分，我们发现：</p>
<p><img src="https://image.im0o.top/files/202110221339007.png" alt="image-20211022133947739"></p>
<p>文件 <strong>codingcat.gif</strong> 在被删除后，其 FAT 表的簇链已经全部清零。</p>
<p>而跳转到5号簇查看文件的数据区</p>
<p><img src="https://image.im0o.top/files/202110221340469.png" alt="image-20211022134055794"></p>
<p>如上图所示，数据区的内容并没有被改变。</p>
<h2 id="恢复文件"><a href="#恢复文件" class="headerlink" title="恢复文件"></a>恢复文件</h2><p>将这个被删除的文件的数据区内容全部选中→编辑→复制选块→至新文件，选择保存路径，恢复文件。</p>
<p><img src="https://image.im0o.top/files/202110221351081.gif" alt="2021-10-22_13-50-40"></p>
<p>导出后的文件 <strong>recovery.gif</strong> 在资源管理器中的截图</p>
<p><img src="https://image.im0o.top/files/202110221354960.png" alt="image-20211022135409237"></p>
<p>可以看到，这个就是被删除的 <strong>codingcat.gif</strong> 文件，以上也就是恢复被删除文件的过程。</p>
<h2 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h2><ol>
<li><p>如果文件在数据区中存放的位置比较靠后，文件起始簇号就会很大，那么文件目录项中记录文件起始旗号的高位两个字节就会有数据， 当文件删除时， 这两个字节会被清零，该文件的起始簇号值也就丢失了，这种删除的文件比较难恢复。</p>
</li>
<li><p>文件删除后，其 FAT 表中的簇链也会清零，如果文件有碎片，也就是不连续存放，这种删除的文件也比较难恢复。</p>
</li>
<li><p>文件删除后，虽然文件的内容并不会被清除，但其所占用的簇会释放，这些簇就很容易被其他文件进一步占用，这样就覆盖了被删除文件的数据 这种情况下的数据将无法恢复。</p>
</li>
</ol>
<h1 id="FAT32-文件系统删除文件后目录项起始簇号高位清零的分析"><a href="#FAT32-文件系统删除文件后目录项起始簇号高位清零的分析" class="headerlink" title="FAT32 文件系统删除文件后目录项起始簇号高位清零的分析"></a>FAT32 文件系统删除文件后目录项起始簇号高位清零的分析</h1><p>上文提及到，如果文件在数据区中存放的位置比较靠后，文件起始簇号就会很大，那么文件目录项中记录文件起始簇号的高位两个字节就会有数据，当文件删除时，这两个字节会被清零。以下是高位簇目录项文件被删除的情况分析。</p>
<h2 id="文件放入回收站后清空回收站"><a href="#文件放入回收站后清空回收站" class="headerlink" title="文件放入回收站后清空回收站"></a>文件放入回收站后清空回收站</h2><div class="note info modern"><p>本小节实例来源《数据恢复深度揭秘》</p>
</div>

<p>针对文件放入回收站后清空回收站的操作分析。</p>
<p>在案例中的分区G下有一个文件 <strong>setupapi.log</strong>，该文件的信息，目录项如下图所示。</p>
<p><img src="https://image.im0o.top/files/202110222030886.png" alt="image-20211022203011824"></p>
<p><img src="https://image.im0o.top/files/202110222035680.png" alt="image-20211022203514459"></p>
<p>将该文件放入回收站后清空回收站（不是直接删除）。</p>
<p>查看该文件的目录项后。</p>
<p><img src="https://image.im0o.top/files/202110222041696.png" alt="image-20211022204104533"></p>
<p>从目录项中可以看出，<strong>setupapi.log</strong> 文件的目录项仅仅首字节变成了 <strong>E5</strong>，其他位置都没有发生变化，起始簇号的高位簇也没有清零。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>在 FAT32 文件系统中，将文件先放入回收站，再清空回收站，这种删除方法并不清楚文件目录项中起始簇高位的两个字节。</p>
<h2 id="直接删除文件"><a href="#直接删除文件" class="headerlink" title="直接删除文件"></a>直接删除文件</h2><p>在分区根目录下有一个文件 <strong>river.bmp</strong> 如下图所示。</p>
<p><img src="https://image.im0o.top/files/202110241939294.png" alt="image-20211024193956062"></p>
<p>文件目录项：</p>
<p><img src="https://image.im0o.top/files/202110241940282.png" alt="image-20211024194033229"></p>
<p>​    该文件起始簇号高位的两个字节是 <strong>00 3FH</strong>，低位的两个字节是 <strong>8D 10H</strong>，合并到一起，则该文件起始簇号的四个字节为 <strong>3F8D10H</strong>，转换为十进制为 <strong>4164880</strong>。</p>
<p>​    接下来用 <code>Shift+Delete</code> 组合键把文件彻底删除。</p>
<p><img src="https://image.im0o.top/files/202110241943787.png" alt="image-20211024194342701"></p>
<p><img src="https://image.im0o.top/files/202110241945472.png" alt="image-20211024194539421"></p>
<p>从目录项中可以看出，<strong>river.bmp</strong> 文件的目录项首字节变成了 <strong>E5</strong>，起始簇号高位的两个字节也被清零，如果用常规的数据恢复软件来恢复这个被删除的文件，软件会把该文件的起始簇号认为是 <strong>8D10H</strong> 簇，显然这样恢复出来的文件不可能正确。</p>
<h3 id="结论-1"><a href="#结论-1" class="headerlink" title="结论"></a>结论</h3><p>在 FAT32 文件系统中，将文件用 <code>Shift+Delete</code> 组合键直接彻底删除，这种删除方法将清除文件目录项中起始簇号高位的两个字节。</p>
<h2 id="直接删除目录"><a href="#直接删除目录" class="headerlink" title="直接删除目录"></a>直接删除目录</h2><p>在分区的根目录下有一个文件夹 <strong>789</strong>.</p>
<p><img src="https://image.im0o.top/files/202110241950182.png" alt="image-20211024195043126"></p>
<p>该文件夹的起始簇号高位的两个字节是 <strong>002FH</strong>，低位的两个字节是 <strong>3427H</strong>，合并到一起，则该文件夹的起始簇号为 <strong>2F3427H</strong>，转换为十进制为 <strong>3093543</strong>。</p>
<p><img src="https://image.im0o.top/files/202110242014975.png" alt="image-20211024201418926"></p>
<p>在文件夹 <strong>789</strong> 下有两个文件 <strong>explorer.exe</strong> 和 <strong>iis6.doc</strong>。</p>
<p><img src="https://image.im0o.top/files/202110242014638.png" alt="image-20211024201430590"></p>
<p>文件 <strong>explorer.exe</strong> 起始簇号的四个字节为 <strong>2F3428H</strong>；文件 <strong>iis6.doc</strong> 起始簇号的四个字节为 <strong>2F37E4H</strong>。</p>
<p><img src="https://image.im0o.top/files/202110242018075.png" alt="image-20211024201855007"></p>
<p>用 <code>Shift+Delete</code> 快捷键彻底删除文件夹 <strong>789</strong>。</p>
<p><img src="https://image.im0o.top/files/202110242020530.png" alt="image-20211024202044463"></p>
<p>从目录项中可以看出，<strong>789</strong> 文件夹的目录项首字节变成了 <strong>E5</strong>，起始簇号的高位两个字节也被清除。</p>
<p><img src="https://image.im0o.top/files/202110242023953.png" alt="image-20211024202353902"></p>
<p>文件 <strong>explorer.exe</strong> 和 <strong>iis6.doc</strong> 的目录项完好无损，首字节没有改为 <strong>E5</strong>， 起始簇高位也没有清零。</p>
<p><img src="https://image.im0o.top/files/202110242027086.png" alt="image-20211024202756025"></p>
<h3 id="结论-2"><a href="#结论-2" class="headerlink" title="结论"></a>结论</h3><p>在 FAT32 文件系统中，将文件夹用 <code>Shift+Delete</code> 快捷键彻底删除，这种删除方法将清除文件夹的目录项中的高位簇，而文件夹里面的目录项不会改动。</p>
<h1 id="实例：恢复-FAT32-中被删除的文件"><a href="#实例：恢复-FAT32-中被删除的文件" class="headerlink" title="实例：恢复 FAT32 中被删除的文件"></a>实例：恢复 FAT32 中被删除的文件</h1><div class="note info modern"><p>本次实例没有对MBR DBR作破坏 仅对 <code>Shift+Delete</code> 删除的文件进行恢复</p>
<p>但实例教程中将以底层方式进行恢复，步骤会较为繁琐</p>
<p><strong>本题需要找到的文件为 手工重建复合文档.doc</strong></p>
</div>

<ol>
<li><h2 id="导入题目-FAT32-211026-vhd-后用-Winhex-打开"><a href="#导入题目-FAT32-211026-vhd-后用-Winhex-打开" class="headerlink" title="导入题目 FAT32-211026.vhd 后用 Winhex 打开"></a>导入题目 <code>FAT32-211026.vhd</code> 后用 Winhex 打开</h2></li>
</ol>
<p><img src="https://image.im0o.top/files/202110262004305.png" alt="image-20211026200418189"></p>
<ol start="2">
<li><h2 id="跳转到-FAT32-分区-DBR"><a href="#跳转到-FAT32-分区-DBR" class="headerlink" title="跳转到 FAT32 分区 DBR"></a>跳转到 FAT32 分区 DBR</h2></li>
</ol>
<p><img src="https://image.im0o.top/files/202110262006552.png" alt="image-20211026200634443"></p>
<p>从 DBR 获取到<strong>保留区大小</strong>、<strong>FAT 表大小</strong>、<strong>每簇扇区数</strong>为<code>32</code>、<code>15,352</code>、<code>32</code>。</p>
<ol start="3">
<li><h2 id="向后跳转-30-736-扇区（保留区大小-2-FAT-表大小）到达根目录。"><a href="#向后跳转-30-736-扇区（保留区大小-2-FAT-表大小）到达根目录。" class="headerlink" title="向后跳转 30,736 扇区（保留区大小+ 2 * FAT 表大小）到达根目录。"></a>向后跳转 <code>30,736</code> 扇区（保留区大小+ 2 * FAT 表大小）到达根目录。</h2></li>
</ol>
<p><img src="https://image.im0o.top/files/202110262010644.gif" alt="2021-10-26_20-10-17"></p>
<ol start="4">
<li><h2 id="分析根目录"><a href="#分析根目录" class="headerlink" title="分析根目录"></a>分析根目录</h2></li>
</ol>
<p>切换编码预览，在切换至 <code>GB-2312</code> 编码时发现根目录中有包含 <code>工重~1DOC</code> 字样的文件，其文件目录项第一个字节为 <strong>E5</strong>，初步推断该文件为我们需要恢复的文件。</p>
<p><img src="https://image.im0o.top/files/202110262016030.png" alt="image-20211026201611917"></p>
<ol start="5">
<li><h2 id="获取文件位置，大小"><a href="#获取文件位置，大小" class="headerlink" title="获取文件位置，大小"></a>获取文件位置，大小</h2></li>
</ol>
<p>经过数据解释器查看，该文件的位置在 <strong>6号簇</strong>，大小为 <strong>1,058,306</strong> 字节。</p>
<ol start="6">
<li><h2 id="跳转至文件位置，选取大小进行恢复"><a href="#跳转至文件位置，选取大小进行恢复" class="headerlink" title="跳转至文件位置，选取大小进行恢复"></a>跳转至文件位置，选取大小进行恢复</h2></li>
</ol>
<p>向后跳转 <strong>128扇区</strong>（每簇扇区数 * (6-2)）</p>
<blockquote>
<p>因为根目录簇号为2，文件簇号为6，则需要向后跳转6-2=4个簇</p>
</blockquote>
<p><img src="https://image.im0o.top/files/202110262019436.png" alt="image-20211026201916310"></p>
<p>跳转后发现文件为 <strong>复合文档</strong>，选中文件头，向后跳转<strong>1,058,306</strong> 字节，选中末尾。</p>
<p><img src="https://image.im0o.top/files/202110262021924.gif" alt="2021-10-26_20-21-25"></p>
<p>右键 → 编辑 → 复制选块 → 至新文件</p>
<p><img src="https://image.im0o.top/files/202110262022547.png" alt="image-20211026202226503"></p>
<p>选取路径，进行文件恢复。</p>
<p>至此，你成功恢复了被删除的 FAT32 分区中的文件。</p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Winhex数据恢复教程</category>
      </categories>
      <tags>
        <tag>Winhex</tag>
        <tag>数据恢复</tag>
        <tag>FAT32</tag>
      </tags>
  </entry>
  <entry>
    <title>使用 Gitee/Github + PicGo 实现高速稳定图床</title>
    <url>/posts/fbb2e56c.html</url>
    <content><![CDATA[<div class="note danger modern"><p>Gitee 疑似使用 302 重定向防盗链，导致图片无法正常显示，请使用 Github + jsdelivr 代替</p>
</div>

<h1 id="效果展示"><a href="#效果展示" class="headerlink" title="效果展示"></a>效果展示</h1><p><img src="https://image.im0o.top/gitee/img/20211017195800.png"></p>
<blockquote>
<p>图片来源：<a href="https://whvn.cc/z8dg9y">https://whvn.cc/z8dg9y</a> 存储地址：<del>gitee/im0o/photobed</del> github/0ojixueseno0/image</p>
</blockquote>
<h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><h2 id="安装PicGo"><a href="#安装PicGo" class="headerlink" title="安装PicGo"></a>安装PicGo</h2><p>从Github Releases下载PicGo安装包</p>
<p><a href="https://github.com/Molunerfinn/PicGo/releases">Releases · Molunerfinn/PicGo (github.com)</a></p>
<p>PicGo官网：<a href="https://molunerfinn.com/PicGo/">PicGo (molunerfinn.com)</a></p>
<p><img src="https://image.im0o.top/gitee/img/202110181911783.png"></p>
<center style="margin: -1em 0 1em 0;"><font size=1>应用，功能截图</font></center>

<div class="note orange icon modern"><i class="note-icon far fa-flag"></i><p><font size=4.5>注意</font></p>
<p>请确保你安装了 Node.js， 并且版本 &gt;= 8。</p>
<p>默认上传图床为<a href="https://sm.ms/">SM.MS</a>。PicGo上传之后，会自动将上传成功的URL复制到你的剪贴板，支持5种复制格式。</p>
</div>

<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p><img src="https://ghproxy.com/https://raw.githubusercontent.com/Molunerfinn/test/master/picgo/picgo-2.0.gif"> </p>
<ol>
<li>直接在主窗口上传区域拖拽图片上传。</li>
<li>直接在主窗口上传区域点击，然后弹出文件浏览器后选择图片上传。</li>
<li>可以将图片复制到剪贴板，然后点击<code>剪贴板图片上传</code>按钮来上传。</li>
</ol>
<h1 id="使用Gitee-PicGo"><a href="#使用Gitee-PicGo" class="headerlink" title="使用Gitee+PicGo"></a>使用Gitee+PicGo</h1><ul>
<li><font color="green"><b>优点：</b></font><ul>
<li>国内访问速度快</li>
</ul>
</li>
<li><font color="darkred"><b>缺点：</b></font><ul>
<li>图片文件不能大于1MB</li>
</ul>
</li>
</ul>
<h2 id="安装PicGo插件"><a href="#安装PicGo插件" class="headerlink" title="安装PicGo插件"></a>安装PicGo插件</h2><p>在PicGo → 插件设置中搜索<code>gitee</code>关键词，安装对应插件，我使用的是<code>gitee-uploader 1.1.2</code></p>
<p><img src="https://image.im0o.top/gitee/img/202110191938460.png"></p>
<h2 id="新建码云仓库"><a href="#新建码云仓库" class="headerlink" title="新建码云仓库"></a>新建码云仓库</h2><p>我们需要在Gitee建立一个仓库作为图片存放的地点。</p>
<p><strong>点击网页右上角的+号，新建仓库</strong></p>
<p><img src="https://image.im0o.top/gitee/img/202110191943639.png" alt="image-20211019194307509"></p>
<p>新建仓库后，按照以下方式进行配置：</p>
<ol>
<li>将仓库设置为开源仓库</li>
<li>勾选设置模板——Readme文件</li>
</ol>
<p><img src="https://image.im0o.top/gitee/img/202110191946337.png" alt="image-20211019194645227"></p>
<p>确认无误后即可点击创建，创建仓库作为图床存放图片。</p>
<h2 id="获取私人令牌-Token"><a href="#获取私人令牌-Token" class="headerlink" title="获取私人令牌(Token)"></a>获取私人令牌(Token)</h2><p>后续对PicGo的配置中将使用到码云的私人令牌，通过以下步骤获取私人令牌(Token)。</p>
<ol>
<li><p>从头像的下拉菜单中进入设置。</p>
<p><img src="https://image.im0o.top/gitee/img/202110191950870.png" alt="image-20211019195024090"></p>
</li>
<li><p>在侧边栏中找到<strong>私人令牌</strong>，点击进入其设置页面。</p>
<p><img src="https://image.im0o.top/gitee/img/202110191952734.png" alt="image-20211019195159338"></p>
</li>
<li><p>点击<strong>生成新令牌</strong>，并按照下图配置权限。</p>
<p><img src="https://image.im0o.top/gitee/img/202110191953053.png" alt="image-20211019195257419"></p>
</li>
<li><p>配置描述后提交令牌生成。</p>
<p><img src="https://image.im0o.top/gitee/img/202110191954413.png" alt="image-20211019195409922"></p>
<blockquote>
<p>需注意：私人令牌只有在生成的时候明文显示一次，建议妥善保存私人令牌。丢了或者忘了就得重新生成一个了。</p>
</blockquote>
</li>
</ol>
<h2 id="配置PicGo"><a href="#配置PicGo" class="headerlink" title="配置PicGo"></a>配置PicGo</h2><p>安装完成后，点击图床设置 → gitee 进行Gitee仓库的配置。</p>
<p><em>你可以在PicGo设置中关闭不需要的图床</em></p>
<p><img src="https://image.im0o.top/gitee/img/202110191940694.png"></p>
<ul>
<li><p>repo：用户名/仓库名称，示例中的值应填为<code>im0o/image</code>，你可以在仓库的详情页面的链接上找到。</p>
</li>
<li><p>branch：分支，默认填<code>master</code>，为详情页中显示的分支。</p>
<p><img src="https://image.im0o.top/gitee/img/202110192001806.png" alt="image-20211019200139194"></p>
</li>
<li><p>token：填写刚刚获取到的私人令牌</p>
</li>
<li><p>path：路径，留空则在根目录上传文件</p>
</li>
<li><p>customPath：默认default即可</p>
</li>
<li><p>customUrl：留空即可</p>
</li>
</ul>
<p>配置完毕后即可开始上传图片使用了。需要注意的是：<strong>Gitee大于1M的图片文件需要登录后查看</strong>，所以如果是过大的文件可以尝试图片压缩，或更换图床等。</p>
<h1 id="使用Github-PicGo"><a href="#使用Github-PicGo" class="headerlink" title="使用Github+PicGo"></a>使用Github+PicGo</h1><ul>
<li>缺点：国内访问速度慢</li>
<li>相比于Gitee：没有大小限制</li>
</ul>
<h2 id="新建Github仓库"><a href="#新建Github仓库" class="headerlink" title="新建Github仓库"></a>新建Github仓库</h2><p>我们需要在Github建立一个仓库作为图片存放的地点。</p>
<p><strong>点击网页右上角的+号，<code>New Repository</code> 新建仓库</strong></p>
<p><img src="https://image.im0o.top/gitee/img/202110192026297.png" alt="image-20211019202649067"></p>
<p>新建仓库后，按照以下方式进行配置：</p>
<ol>
<li>输入一个仓库名称</li>
<li>设置仓库为<code>Public</code>模式（开源仓库）</li>
<li>勾选<code>Add a README file</code>，生成Readme文件（将自动新建一条名为<code>main</code>的分支）</li>
<li>点击<code>Create repository</code>新建仓库</li>
</ol>
<p><img src="https://image.im0o.top/gitee/img/202110192029776.png" alt="image-20211019202953399"></p>
<h2 id="获取Personal-access-token"><a href="#获取Personal-access-token" class="headerlink" title="获取Personal access token"></a>获取Personal access token</h2><p>后续对PicGo的配置中将使用到Github的<code>Personal Access Token</code>，通过以下步骤生成Token。</p>
<ol>
<li>点击页面右上角的头像 → <code>Settings</code> 进入设置页面</li>
</ol>
<p><img src="https://image.im0o.top/gitee/img/202110192034425.png" alt="image-20211019203418269"></p>
<ol start="2">
<li>在侧边栏中找到<code>Developer settings</code>点击进入设置页面，点击页面侧边栏中的<code>Personal access tokens</code>进入token配置页面。</li>
</ol>
<p><img src="https://image.im0o.top/gitee/img/202110192034915.png" alt="image-20211019203403252"></p>
<p><img src="https://image.im0o.top/gitee/img/202110192036296.png" alt="image-20211019203634589"></p>
<ol start="3">
<li><p>点击 <code>Generate new token</code> 按钮，验证密码后按照下图配置生成token。</p>
<p><strong>注意：<code>Expiration</code> 为token有效时间，请妥善保管好所有有限时间为无限（不过期）的token，以保护信息安全。</strong></p>
<ul>
<li><p>填写Token描述</p>
</li>
<li><p>设置截止时间为<code>No expiration</code>（不截止）</p>
<p><strong>（不安全，请妥善保管好所有不会过期的token）</strong></p>
</li>
<li><p>勾选<code>repo</code>复选框</p>
</li>
</ul>
<p><img src="https://image.im0o.top/gitee/img/202110192045170.png" alt="image-20211019203936889"></p>
</li>
<li><p>配置提交后token生成。</p>
<ul>
<li>妥善保管好生成的token，这段字符串只会显示这么一次！</li>
</ul>
<p><img src="https://image.im0o.top/gitee/img/202110192042801.png" alt="image-20211019204211125"></p>
</li>
</ol>
<h2 id="配置PicGo-1"><a href="#配置PicGo-1" class="headerlink" title="配置PicGo"></a>配置PicGo</h2><p><img src="https://image.im0o.top/gitee/img/202110192030200.png" alt="image-20211019203032722"></p>
<ul>
<li>仓库名：填写 用户名/仓库名，例子<code>0ojixueseno0/imagetest</code></li>
<li>分支名：默认填写 <code>main</code></li>
<li>Token：填写刚刚生成的 <code>Personal access token</code></li>
<li>存储路径：留空则存放在仓库根目录</li>
<li>域名：将域名栏内填入 <code>https://raw.githubusercontent.com/[用户名]/[仓库名]/main</code></li>
</ul>
<div class="note info morden flat"><p>你可以在自定义域名内填入 <code>https://cdn.jsdelivr.net/gh/[用户名]/[仓库名]@[分支(默认main)]</code>使用jsdelivr的CDN加速服务</p>
</div>

<p>配置完毕后即可开始上传图片使用了。</p>
<h1 id="Typora与PicGo的联动"><a href="#Typora与PicGo的联动" class="headerlink" title="Typora与PicGo的联动"></a>Typora与PicGo的联动</h1><p>在Typora → 偏好设置 → 图像中，可以设置上传服务为PicGo app。将路径设置为PicGo程序所在的位置即可。</p>
<p><img src="https://image.im0o.top/gitee/img/202110200916084.png" alt="image-20211020091600051"></p>
<p>需要注意的是，在设置好PicGo路径后需要点击<code>验证图片上传选项</code>进行测试。若测试端口与PicGo的Server端口不同，需要去PicGo进行设置。</p>
<p><img src="https://image.im0o.top/gitee/img/202110200920571.png" alt="image-20211020092038044"></p>
<p>在Typora中的测试端口为36677，则需要前往PicGo的Server设置进行设置端口为36677。</p>
<p><img src="https://image.im0o.top/gitee/img/202110200922762.png" alt="image-20211020092247581"></p>
<p>设置成功后即可重新验证，成功连接上传后就会反馈验证成功字样。</p>
<p>接下来你就可以在Typora中直接粘贴本地图片，然后右键图片，点击上传图片，即可自动将本地图片上传至设置好的图床上，并且一键替换Typora中的链接为外链。</p>
<p><img src="https://image.im0o.top/gitee/img/202110200917585.png" alt="image-20211020091740405"></p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>一些教程</category>
      </categories>
      <tags>
        <tag>图床</tag>
        <tag>图片</tag>
      </tags>
  </entry>
  <entry>
    <title>基于onebot的Go-Pichubot QQ机器人</title>
    <url>/posts/78bda4cc.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这是由python-pichubot重构而来的基于go-cqhttp(Mirai,MiraiGo的Onebot)的QQ机器人</p>
<p>开源地址（不包含大学习功能）：<a href="https://github.com/0ojixueseno0/go-pichubot">Github</a></p>
<h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><p>做Pichubot的初衷是什么？当然是自动统计QQ群青年大学习完成情况啦</p>
<p>作为一只懒狗，能偷懒的地方当然得偷懒咯</p>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li><h3 id="Python-Pichubot"><a href="#Python-Pichubot" class="headerlink" title="Python Pichubot"></a>Python Pichubot</h3><p>[!抽签][!cq] 开始抽签（观音签 共100签）<br>[!鸡汤][!cureword] 随机获取一碗鸡汤<br>[!人话][!nbnhhsh]+[词语缩写] 查询缩写对应的人话<br>[!机翻][!翻译][!百度翻译][!fanyi]+[目标语言]+[原文] 翻译语言<br>[!大学习][!dxx]+[查询][cx]<br>[!大学习][!dxx]+[列出][list]<br>[!大学习][!dxx]+[未完成][at]<br>[!大学习][!dxx]+[重置][reset]<br>[!大学习][!dxx]+[添加][add]+[@某人]<br>[!大学习][!dxx]+[移除][remove]+[@某人]</p>
</li>
<li><h3 id="Go-Pichubot"><a href="#Go-Pichubot" class="headerlink" title="Go-Pichubot"></a>Go-Pichubot</h3><p>大学习</p>
<p>长事件示例</p>
<p>短时间示例</p>
</li>
</ul>
<h1 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h1><ul>
<li><h3 id="如何判断大学习完成状态？"><a href="#如何判断大学习完成状态？" class="headerlink" title="如何判断大学习完成状态？"></a>如何判断大学习完成状态？</h3><p>读取发送的图片，与已有的上传图片进行比对 相似度达到阈值则算作完成</p>
<p>重构后在数据库内加入了大学习成绩单的分享链接，可以读取成绩单数据</p>
</li>
<li><h3 id="重构后的bot使用方法"><a href="#重构后的bot使用方法" class="headerlink" title="重构后的bot使用方法"></a>重构后的bot使用方法</h3><p>重构前：所有方法写道main函数里</p>
<p>重构后：所有方法写到mainbot内 可以外部注册调用（感觉像个包了hhh）</p>
</li>
</ul>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>  时间上，皮丘Bot比鸡汤v2要早好几个月 但是我忘了写文档了，特此补上</p>
<p>  如果有啥我想起来的 会更新进来哒</p>
<blockquote>
<p>之后如果有时间就把这个写成包 造福全人类</p>
</blockquote>
<p>  现在已经是go-package了！</p>
<p>  Pichubot QQ讨论群：645995997</p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>杂谈/踩坑笔记</category>
      </categories>
      <tags>
        <tag>go</tag>
        <tag>onebot</tag>
        <tag>Pichubot</tag>
        <tag>QQ机器人</tag>
      </tags>
  </entry>
  <entry>
    <title>CureWord.top 鸡汤重构笔记</title>
    <url>/posts/b70820cd.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近收到朋友的催更，花了一周左右把go-Cureword的进度给赶完了</p>
<p>这篇博客用来记录我这期间踩过的所有坑，解决方法，以及心得</p>
<blockquote>
<p>因为是工程写完之后来统计的 可能会有特别多的疏漏</p>
</blockquote>
<h3 id="鸡汤站地址："><a href="#鸡汤站地址：" class="headerlink" title="鸡汤站地址："></a>鸡汤站地址：</h3><p><a href="http://cureword.top/">Cureword v2 心灵鸡汤</a></p>
<h3 id="工程开源地址："><a href="#工程开源地址：" class="headerlink" title="工程开源地址："></a>工程开源地址：</h3><p>前端: <a href="https://github.com/0ojixueseno0/cureword.top">github.com/…/cureword.top</a><br>后端: <a href="https://github.com/0ojixueseno0/go-cureword">github.com/…/go-cureword</a></p>
<h1 id="坑🕳"><a href="#坑🕳" class="headerlink" title="坑🕳"></a>坑🕳</h1><ol>
<li><h2 id="Vue-js-–-axios-通过POST方式传输的json是Request-Payload"><a href="#Vue-js-–-axios-通过POST方式传输的json是Request-Payload" class="headerlink" title="Vue.js – axios 通过POST方式传输的json是Request Payload"></a>Vue.js – axios 通过POST方式传输的json是Request Payload</h2><p>搜罗了一堆东西，最后发现只要你请求头是 <code>Content-Type: application/json</code>貌似Golang就能读取出来…</p>
</li>
<li><h2 id="生成API接口文档"><a href="#生成API接口文档" class="headerlink" title="生成API接口文档"></a>生成API接口文档</h2><p>最开始使用的是APIPost/Postman的生成方法，但是这两个软件生成出来的文档夹带太多私货（指广告），后来就使用了apidoc进行生成</p>
<p><a href="https://apidocjs.com/">APIDOC</a> 可以读取源码的注释 进行生成api文档</p>
</li>
<li><h2 id="Go-net-http-处理静态文件"><a href="#Go-net-http-处理静态文件" class="headerlink" title="Go net/http 处理静态文件"></a>Go net/http 处理静态文件</h2><p>生成出来的api文档是一个文件夹，带静态文件，需要一并搭载出来</p>
<p>解决方法：</p>
</li>
</ol>
   <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">http.Handle(<span class="string">&quot;/&quot;</span>, http.FileServer(http.Dir(<span class="string">&quot;/xxx/&quot;</span>)))</span><br></pre></td></tr></table></figure>

<p>   刚开始这个方法貌似用不了，调试了很久又发现能用了，盲猜浏览器缓存的锅</p>
<p>   （这个方法真的是简单粗暴方便）<br>4. ## Go []byte 与 json 互相转换方法（搜索次数多）</p>
   <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">b, _ := json.Marshal(m)<span class="comment">//将json对象序列化为byte[]</span></span><br><span class="line">json.Unmarshal(b,&amp;ki)<span class="comment">//将序列化的byte[]重写反序列化为对象。</span></span><br></pre></td></tr></table></figure>
<ol start="5">
<li><h2 id="Gorm-指定struct对应的表名"><a href="#Gorm-指定struct对应的表名" class="headerlink" title="Gorm 指定struct对应的表名"></a>Gorm 指定struct对应的表名</h2></li>
</ol>
   <figure class="highlight go"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">type</span> Article <span class="keyword">struct</span> &#123;</span><br><span class="line">   Id         <span class="keyword">uint32</span> <span class="string">`json:&quot;id&quot;`</span>  </span><br><span class="line">   Title      <span class="keyword">string</span> <span class="string">`json:&quot;title&quot;`</span>  </span><br><span class="line">   Content    <span class="keyword">string</span> <span class="string">`json:&quot;content&quot;`</span> </span><br><span class="line">   &#125; </span><br><span class="line">   <span class="function"><span class="keyword">func</span> <span class="params">(Article)</span> <span class="title">TableName</span><span class="params">()</span> <span class="title">string</span></span> &#123;</span><br><span class="line">       <span class="comment">//实现TableName接口，以达到结构体和表对应，如果不实现该接口，并未设置全局表名禁用复数，gorm会自动扩展表名为articles（结构体+s）</span></span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;it_article&quot;</span> </span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 后记：貌似直接使用db.Table(&quot;表名&quot;)指定即可</span></span><br></pre></td></tr></table></figure>
<ol start="6">
<li><h2 id="axios-相应后执行的函数无法使用element-ui的函数-this指向有变化"><a href="#axios-相应后执行的函数无法使用element-ui的函数-this指向有变化" class="headerlink" title="axios 相应后执行的函数无法使用element-ui的函数(this指向有变化)"></a>axios 相应后执行的函数无法使用element-ui的函数(this指向有变化)</h2><p>原使用方法</p>
</li>
</ol>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios</span><br><span class="line">  .get(<span class="string">&quot;host&quot;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;&#125;)</span><br><span class="line">  .catch(...)</span><br></pre></td></tr></table></figure>

<p>   现使用方法</p>
   <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">axios</span><br><span class="line">  .get(<span class="string">&quot;host&quot;</span>)</span><br><span class="line">  .then(<span class="function">(<span class="params">res</span>)=&gt;</span>&#123;&#125;)</span><br><span class="line">  .catch(...)</span><br></pre></td></tr></table></figure>

<p>   原因：<code>function(res)&#123;this.xxx&#125;</code> 和 <code>(res)=&gt;&#123;this.xxx&#125;</code> 中的 <code>this</code>的指向是不同的，箭头函数并不简单是匿名函数的简写。</p>
<blockquote>
<p>在JS中，箭头函数并不是简单的function(){}匿名函数的简写语法糖，实际上，箭头函数和匿名函数有个明显的区别：箭头函数内部的this是词法作用域，在编写函数时就已经确定了。而匿名函数的this指向运行时实际调用该方法的对象，无法在编写函数时确定。</p>
</blockquote>
<ol start="7">
<li><h2 id="vue-router-刷新后无法定位路由"><a href="#vue-router-刷新后无法定位路由" class="headerlink" title="vue router 刷新后无法定位路由"></a>vue router 刷新后无法定位路由</h2><p>将 <code>router/index.js</code>中的 <code>mode</code>从 <code>history</code>改为 <code>hash</code>即可</p>
</li>
<li><h2 id="使用https时的证书问题"><a href="#使用https时的证书问题" class="headerlink" title="使用https时的证书问题"></a>使用https时的证书问题</h2><p>最后放弃了https，全站使用http</p>
</li>
</ol>
<h1 id="Wakatime"><a href="#Wakatime" class="headerlink" title="Wakatime"></a>Wakatime</h1><p><a href="https://wakatime.com/@Jz0ojiang/projects/aixzmfgmme?start=2021-08-03&end=2021-08-09">前往Wakatime查看 go-Cureword 编写时所需的时长</a></p>
<p>我才发现这玩意快写了30个小时了…</p>
<h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><p>获取API请前往<a href="https://afdian.net/@jz0ojiang">爱发电</a>进行充电，充电一次获取1个月API使用权限</p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>杂谈/踩坑笔记</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>cureword</tag>
        <tag>心灵鸡汤</tag>
        <tag>API</tag>
      </tags>
  </entry>
  <entry>
    <title>2021年5月11日 小记</title>
    <url>/posts/f0df67d7.html</url>
    <content><![CDATA[<h2 id="梦"><a href="#梦" class="headerlink" title="梦"></a>梦</h2><p>昨晚十二点半睡着了，早上7点醒了。</p>
<p>做了个有丶奇怪的梦，梦里像GTA一样有个小地图，小地图上有三个红色的骷髅头在向我高速移动。有三个蓝色的骷髅头追着我，当时我特别心悸，还没反应过来就被打到了，然后就惊醒了…</p>
<center><img src="https://image.im0o.top/gitee/img/20210511175744.png"/>
<img src="https://image.im0o.top/gitee/img/20210511175504.png"/></center>
<center>大概长这样...(对没错就是你想的那个游戏的boss的技能)</center>

<p><img src="https://image.im0o.top/gitee/img/20210511175920.png"></p>
<h2 id="午饭"><a href="#午饭" class="headerlink" title="午饭"></a>午饭</h2><p>好耶，上次去考试院装机器的工资到账惹！</p>
<p>徐<del>老板</del>（老师）带我们仨（我、zhjk、mohe）和几个老师去星伦多吃自助餐。（好耶！是自助餐！）</p>
<p>中午11点，老徐巨认真的和我们说（也可能是自言自语）</p>
<p>“我要把论文写好，现在就写，不能再拖了。”说完，便打开了魔兽世界….</p>
<p>”还有20秒就出发。“（很突然啊，我大意了，没有闪）</p>
<p>“老师你这太可怕了，还掐秒“</p>
<p>”不愧是时间管理大师！“</p>
<p>”等啥呢，出发了出发了“</p>
<p>（坐车到万象汇）</p>
<p><img src="https://image.im0o.top/gitee/img/20210511174550.jpg"></p>
<center>右一就是徐老板（逃（希望不要发现我偷拍23333</center>

<p><img src="https://image.im0o.top/gitee/img/20210511174551.jpg"></p>
<p><img src="https://image.im0o.top/gitee/img/20210511174552.jpg"></p>
<p><img src="https://image.im0o.top/gitee/img/20210511174549.jpg"></p>
<p>结果另外俩家伙一个全程各种吃生鱼片、冰淇淋…一个各种吃披萨…..</p>
<p>还拿了一堆肉烤了不吃….结果都是我吃的淦🙄（最后体重最轻的吃的最多…）</p>
<p>啊对了，这俩家伙还霍霍饮料…emmm具体是怎么干的呢…</p>
<p>大概是这样：</p>
<p>​    拿大杯子打一坨冰沙（啥口味都来点）</p>
<p>​    加冰淇淋</p>
<p>​    搅和搅和</p>
<p>啊结果他们拿的两大盘肉多数都是我吃的，这俩全在那玩，最后俩家伙都说吃不下了…😡（我有自助餐我不吃，我自制饮料，欸就是玩儿）</p>
<p>走的时候还拿了份冰淇淋哈哈哈哈，不得不说冰淇淋机打出来的冰淇淋单吃感觉不太行，口感更像冰沙；但是加一点柠檬汁就不一样了，瞬间味道层次和程度大幅提升。</p>
<blockquote>
<p>zhjk打了亿点点冰淇淋… 牛哇牛哇</p>
</blockquote>
<h2 id="工具人"><a href="#工具人" class="headerlink" title="工具人"></a>工具人</h2><p>日常工具人，统计了一堆数据….（计算机等级考试本系成绩）</p>
<p>好耶，整个年级就我们仨过了计算机二级。英语一级也过了，撒花~</p>
<blockquote>
<p>希望我能考过二级python 😀在这里挖个坑以后填</p>
</blockquote>
<p>我和zhjk考完英一出来那是一个慌啊，各种觉得自己出岔子过不了…（有卖弱嫌疑）</p>
<p>mohe考完之后，啊~那叫一个自信，什么</p>
<p>“这次我必过，太简单了“</p>
<p>”比我想象的简单多了”</p>
<p>“我全做出来了”</p>
<p><del>“打完这场仗我就回老家结婚”</del></p>
<p>各种flag飞出…</p>
<p>结果：mohe英一没过（惨咯）</p>
<hr>
<p>然后就是把这几天的视频任务完成了，剪了个报告视频。</p>
<p><img src="https://image.im0o.top/gitee/img/20210511182615.png"></p>
<p>工程名是对口相声（哈哈哈哈哈哈）因为开头我和zhjk在念台词（虽然后期配音）。</p>
<p>~~ 撒….晚饭吃什么呢…. ~~</p>
<p>啊啊啊写摘要忘了点外卖！！！我晚上没吃的了呜呜呜呜呜，我简直是这个世界上最惨的崽。</p>
<center><h2>At last</h2></center>

<p><img src="https://image.im0o.top/gitee/img/20210511185204.jpg"></p>
<blockquote>
<p>后记：</p>
<p>日记这个坑在网站更新之前就开了，到现在才写第一篇日记哈哈哈</p>
<p>希望我能养成随手记录生活的习惯吧~</p>
</blockquote>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>小记：拿到国家奖学金</title>
    <url>/posts/661c1b85.html</url>
    <content><![CDATA[<h1 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h1><p>在 2020 年 12 月 22 日，站长拿到了 19-20 学年的国家奖学金，共计 6000 元。</p>
<p>全部打给母上大人了哈哈哈哈哈。</p>
<h1 id="照片"><a href="#照片" class="headerlink" title="照片"></a>照片</h1><p><img src="https://image.im0o.top/gitee/img/20220123045719.png"></p>
<p><img src="https://image.im0o.top/gitee/img/20220123045831.png"></p>
<h1 id="Ps"><a href="#Ps" class="headerlink" title="Ps"></a>Ps</h1><p>封面是oc约的模板图hhh</p>
<p>本文发布日期于2022年1月23日。</p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>日记</category>
      </categories>
      <tags>
        <tag>奖状</tag>
        <tag>奖学金</tag>
      </tags>
  </entry>
  <entry>
    <title>Discuz日记 - 更换域名</title>
    <url>/posts/39c0dcf5.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前段时间，我给我们班级搭建了一个dz论坛（G19305空间站），之后觉得比较大材小用了，就决定更换域名，作为学校的论坛使用（我们学校没有自己的论坛:D）</p>
<p>后续为了加强安全（Https），也为了看起来nb一点（浏览器的小锁），我们给新的域名上了CloudFlare的CDN加速，还有它的证书。但是，我们发现游客访问时虽然是有小锁的，在登录后就又变为不安全了。</p>
<span id="more"></span>

<h2 id="找出问题所在"><a href="#找出问题所在" class="headerlink" title="找出问题所在"></a>找出问题所在</h2><p>在“不安全”页面中按下<code>F12</code>键，打开Console，得到提示，是一张图片的源地址为不安全的，经过检查发现是用户的头像（来自UCenter），地址还是旧的g19305.top。所以如果想让网页完全安全，我们需要把UCenter的链接也改为新的地址。</p>
<h2 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h2><p>在dz论坛变更域名后，你需要把以下地点的域名都检查并变更：</p>
<ul>
<li>管理后台<ol>
<li>全局——站点信息——网站URL</li>
<li>全局——域名设置——应用域名</li>
<li>全局——域名设置——根域名设置</li>
<li>界面——导航设置——链接竖栏内的链接</li>
<li>运营——站点广告（我的站点有导向帖子的广告位）</li>
<li>运营——友情链接</li>
<li>运营——关联链接</li>
<li><strong>站长——UCenter设置——UCenter 访问地址</strong></li>
<li><strong>登录UCenter——应用管理——应用的主URL</strong></li>
</ol>
</li>
</ul>
<p>核查并更改好这些信息后重启你的服务器，进入CloudFlare后台将页面缓存清空，等待服务器开启后Ctrl+F5刷新即可</p>
<p>最后，论坛终于上小锁辣！！！超帅的有没有哈哈哈哈哈~</p>
<p>网页：<a href="https://yzgz.ac.cn/">扬州高职校</a></p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>杂谈/踩坑笔记</category>
      </categories>
      <tags>
        <tag>http</tag>
        <tag>discuz!</tag>
        <tag>域名</tag>
        <tag>cloudflare</tag>
        <tag>https</tag>
      </tags>
  </entry>
  <entry>
    <title>Skript 功能体验服</title>
    <url>/posts/8b38d942.html</url>
    <content><![CDATA[<p>为了便于体验博客内的Skript所带来的效果，我搭建了一个我的世界的服务器。</p>
<blockquote>
<p>您可以使用以下版本的游戏进入服务器：</p>
<p>Minecraft 1.12.2+</p>
<p>理论支持 1.8 1.8.9 1.9 1.10 1.11 1.12 </p>
</blockquote>
<ul>
<li>服务器地址：mc.im0o.top</li>
</ul>
<p><img src="https://im0o.gitee.io/photobed/photos/2020-2-12-132218.gif" alt="motd.png"></p>
<hr>
<span id="more"></span>

<p>以下是服务器的内容与配置：</p>
<p><img src="https://im0o.gitee.io/photobed/photos/2020-2-13-090514.png" alt="img.png"></p>
<p><img src="https://im0o.gitee.io/photobed/photos/2020-2-13-090505.png" alt="img.png"></p>
<p><img src="https://im0o.gitee.io/photobed/photos/2020-2-13-090447.png" alt="img.png"></p>
<p><img src="https://im0o.gitee.io/photobed/photos/2020-2-13-090455.jpg" alt="img.png"></p>
<blockquote>
<p>你可以通过挖掘钻石获取VaultMoney，Ueco的汇率将不定期变动</p>
</blockquote>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>我的Skript旅途</category>
      </categories>
      <tags>
        <tag>我的世界</tag>
        <tag>minecraft</tag>
        <tag>skript</tag>
      </tags>
  </entry>
  <entry>
    <title>使用abbrlink插件来缩短文章链接</title>
    <url>/posts/deee77a9.html</url>
    <content><![CDATA[<p>在分享博客中的文章链接时，链接总是带中文，很多地方都无法识别到中文的部分，某些浏览器的地址栏复制出来的链接则是<code>.../%xx%xx%xx...</code>。</p>
<blockquote>
<p>本篇你将了解到如何使用hexo插件abbrlink解决该问题</p>
</blockquote>
<span id="more"></span>

<h3 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h3><p>在博客根目录<code>右键——打开git bash</code>执行指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>

<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><p>打开根目录的<code>_config.yml</code>文件，修改下面的配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">permalink:</span> <span class="string">posts/:abbrlink.html</span></span><br></pre></td></tr></table></figure>

<p>添加abbrlink的配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">abbrlink:</span></span><br><span class="line">  <span class="attr">alg:</span> <span class="string">crc32</span>  <span class="comment"># 算法：crc16(default) and crc32</span></span><br><span class="line">  <span class="attr">rep:</span> <span class="string">hex</span>    <span class="comment"># 进制：dec(default) and hex</span></span><br></pre></td></tr></table></figure>

<h3 id="清除已生成文件，重新部署"><a href="#清除已生成文件，重新部署" class="headerlink" title="清除已生成文件，重新部署"></a>清除已生成文件，重新部署</h3><p>执行下面的指令，一键重新生成并部署到github上</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo d -g</span><br></pre></td></tr></table></figure>

<h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>你可以在每篇文章的<code>Yaml font</code>区域添加一行</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">abbrlink:</span> <span class="string">&#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure>

<p>以此达到自定义链接地址的目的，例如该链接导向的就是 …/posts/xxx.html</p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>一些教程</category>
      </categories>
      <tags>
        <tag>优化博客</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>UltraEconomy -- 全新的货币系统</title>
    <url>/posts/4cbde4df.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>这是一款非常强大（大概）的金融系统，它新增了一种货币。该货币可以与插件Vault，Playerpoints的货币流通。</p>
<p>这也是我写了这么久sk脚本以来代码行数最多的一个脚本。</p>
<p>以下是文件信息</p>
<table>
<thead>
<tr>
<th>文件名</th>
<th>大小</th>
<th>代码行数</th>
</tr>
</thead>
<tbody><tr>
<td>UltraEconomy.sk</td>
<td>37.3 KB (38,292 字节)</td>
<td>758行</td>
</tr>
</tbody></table>
<p>如果你需要该脚本，可以联系我购买。价格为 255CNY</p>
<p>如有倒卖现象，请联系邮箱<a href="mailto:&#x61;&#100;&#x6d;&#x69;&#x6e;&#x40;&#x69;&#109;&#x30;&#111;&#46;&#x74;&#x6f;&#x70;">&#x61;&#100;&#x6d;&#x69;&#x6e;&#x40;&#x69;&#109;&#x30;&#111;&#46;&#x74;&#x6f;&#x70;</a>，核实后我会追究到底๑乛△乛๑</p>
<span id="more"></span>

<h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><ul>
<li><h4 id="玩家指令"><a href="#玩家指令" class="headerlink" title="玩家指令"></a>玩家指令</h4></li>
</ul>
<p>正常情况下，ueco的货币与Vault、Playerpoints是不互通的。在安装本插件后，管理员需要通过<code>/ueco admin globalset</code>指令来开启互通。</p>
<p><img src="https://im0o.gitee.io/photobed/photos/2020-2-10-095111.png" alt="normal.png"></p>
<p>开启互通后的截图如下：</p>
<p><img src="https://im0o.gitee.io/photobed/photos/2020-2-10-095119.png" alt="img.png"></p>
<p>可见开启互通后玩家的Help帮助提示也会新增可用的指令。</p>
<p><img src="https://im0o.gitee.io/photobed/photos/2020-2-10-095157.png" alt="img.png"></p>
<p>开启Playerpoints与Ueco的互通</p>
<p><img src="https://im0o.gitee.io/photobed/photos/2020-2-10-095227.png" alt="img.png"></p>
<p>Vault与Playerpoints都开启后的样子…</p>
<ul>
<li><h4 id="管理员指令"><a href="#管理员指令" class="headerlink" title="管理员指令"></a>管理员指令</h4></li>
</ul>
<p><img src="https://im0o.gitee.io/photobed/photos/2020-2-10-095339.png" alt="img.png"></p>
<hr>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ul>
<li><h4 id="基础的货币功能"><a href="#基础的货币功能" class="headerlink" title="基础的货币功能"></a>基础的货币功能</h4></li>
</ul>
<p>玩家可以通过执行指令来查看自己的余额</p>
<p>玩家可以通过执行指令进行转账</p>
<p>玩家可以通过执行指令购买管理员上架的物品</p>
<ul>
<li><h4 id="对Vault的互通"><a href="#对Vault的互通" class="headerlink" title="对Vault的互通"></a>对Vault的互通</h4></li>
</ul>
<p>玩家可以使用硬币（默认金融名）购买Vault的金钱</p>
<p>玩家可以使用Vault金钱购买硬币</p>
<p>玩家可以查看硬币与Vault的汇率</p>
<ul>
<li><h4 id="对PlayerPoints点券的互通"><a href="#对PlayerPoints点券的互通" class="headerlink" title="对PlayerPoints点券的互通"></a>对PlayerPoints点券的互通</h4></li>
</ul>
<p>玩家可以使用硬币（默认金融名）购买点券</p>
<p>玩家可以使用点券购买硬币</p>
<p>玩家可以查看硬币与点券的汇率</p>
<ul>
<li><h4 id="高度自定义功能开关"><a href="#高度自定义功能开关" class="headerlink" title="高度自定义功能开关"></a>高度自定义功能开关</h4></li>
</ul>
<p>管理员可以自定义开启各个金融之间的互通</p>
<p>管理员可以自定义开启各个金融互通时的功能</p>
<p>在关闭功能时玩家的帮助提示也会相应减少/增加</p>
<p>以下是管理员可以自定义的功能：</p>
<blockquote>
<p>更改货币之间的汇率： 管理员可以更改Vault/PlayerPoints与硬币的汇率</p>
<p>开启/关闭Vault/Points与硬币之间的流通</p>
<p>开启/关闭玩家查看汇率的功能</p>
<p>开启/关闭玩家消耗Vault/Points买入硬币的功能</p>
<p>开启/关闭玩家抛售硬币获得Vault/Points的功能</p>
<p>自定义货币昵称与单位（提示信息也会随之修改）</p>
<p>自定义玩家初始资金</p>
</blockquote>
<h2 id="快速上手"><a href="#快速上手" class="headerlink" title="快速上手"></a>快速上手</h2><ul>
<li><h4 id="安装脚本"><a href="#安装脚本" class="headerlink" title="安装脚本"></a>安装脚本</h4></li>
</ul>
<p>请将脚本安装在2.3.7版本的Skript插件目录下/skripts/文件夹内</p>
<p>安装完毕后在服务端内输入<code>/sk reload UltraEconomy</code>即可</p>
<ul>
<li><h4 id="初始化设置"><a href="#初始化设置" class="headerlink" title="初始化设置"></a>初始化设置</h4></li>
</ul>
<p>因为该脚本不会产生配置文件，且一切自定义是在游戏内进行操作，请按照以下流程进行脚本的初始化。</p>
<ol>
<li><h5 id="自定义你的货币名称"><a href="#自定义你的货币名称" class="headerlink" title="自定义你的货币名称"></a>自定义你的货币名称</h5><p>首先，你需要给你自己的货币起个名字。当然，如果你懒得想，使用默认的<code>硬币</code>也可以。</p>
<p>需要注意的是，如果你准备开启货币与其他货币之间的流通，我还是建议你更改Vault与PlayerPoints的货币名，因为它们的默认名字就是<code>VaultMoney</code>与<code>PlayerPoints</code></p>
</li>
<li><h5 id="开启货币流通，更改汇率"><a href="#开启货币流通，更改汇率" class="headerlink" title="开启货币流通，更改汇率"></a>开启货币流通，更改汇率</h5><p>如果你想开启货币之间的流通，请务必要记的更改汇率。否则你的服务器就会出现1点券=1硬币=1游戏币的尴尬情况。当然，你也可以关闭抛售/买入功能来限制或阻止货币之间的流通。</p>
</li>
<li><h5 id="设置初始，迎接玩家"><a href="#设置初始，迎接玩家" class="headerlink" title="设置初始，迎接玩家"></a>设置初始，迎接玩家</h5><p>默认玩家初始的货币数为零，如果你希望玩家快速发展，可以适量设置一些初始资金，供玩家抛售/买入其他货币。</p>
</li>
<li><h5 id="上架物品，流通货币"><a href="#上架物品，流通货币" class="headerlink" title="上架物品，流通货币"></a>上架物品，流通货币</h5><p>本脚本已经自带了系统商店，管理员可以通过上架手中物品供玩家购买。</p>
</li>
</ol>
<p>至此，你已经将<code>UltraEconomy</code>配置完毕，可以放玩家进来体验“钱生钱”的感觉啦~</p>
<h2 id="需要的插件与前置"><a href="#需要的插件与前置" class="headerlink" title="需要的插件与前置"></a>需要的插件与前置</h2><p>如果你要开启货币之间的流通，请务必安装以下插件：</p>
<p>Vault，PlayerPoints，任意一个前置为Vault的经济插件（例如Ess），Skript 2.3，TabooSK</p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>我的Skript旅途</category>
      </categories>
      <tags>
        <tag>Skript</tag>
      </tags>
  </entry>
  <entry>
    <title>JPEG与PNG图片隐藏信息传递术</title>
    <url>/posts/56d51092.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在研究JPEG和PNG的文件格式，在其属性中包含了图片文件的分辨率（<strong>该分辨率值为所有图片显示工具显示这个图片时会显示的大小</strong>）。</p>
<p>于是，我们可以通过更改图片显示的分辨率来隐藏图片的部分区域。从而达到隐藏传递信息的效果。</p>
<span id="more"></span>

<h2 id="开始操作"><a href="#开始操作" class="headerlink" title="开始操作"></a>开始操作</h2><h3 id="PNG部分"><a href="#PNG部分" class="headerlink" title="PNG部分"></a>PNG部分</h3><p><img src="https://i.loli.net/2019/12/22/HjreaISC6xbWogQ.png" alt="image.png"></p>
<p>这是一张普通的png格式的照片，我们可以通过编辑这张照片进行传递信息</p>
<p><img src="https://i.loli.net/2019/12/22/xOLY5VD1lWcS6Ak.png" alt="image.png"></p>
<p>编辑后可以修改图片的分辨率，在上面的图片中我们可以看到，这张图片的分辨率是<code>1920*908</code>像素</p>
<p>也就是图片的长度为1920像素，宽度为908像素。</p>
<p>接下来，打开Winhex<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>，将编辑好的图片拖入Winhex窗口中</p>
<p><img src="https://i.loli.net/2019/12/22/o3HlntUGZSCzIse.png" alt="image.png"></p>
<p>将数据解释器设置为Big-Endian（设置方法：点击选项—数据解释器—将窗口右下角的Big-Endian打勾即可）</p>
<p>在PNG图片中，其分辨率位置总是在IHDR（ASCII码栏中的IHDR）的后8个字节，即图中选择的8个字节：</p>
<p><img src="https://i.loli.net/2019/12/22/hGjxzM3cBaTikq6.png" alt="image.png"></p>
<p>使用数据解释器点选到前四个字节的开头，其值为1920，这四个字节则为图片的宽度。我们主要需要修改的是后四个字节：高度</p>
<p><img src="https://i.loli.net/2019/12/22/J8D2EQACPZpjLbM.png" alt="image.png"></p>
<p>点选到后4个字节中，查看其值为908，这个值就是图片的高度。</p>
<p><img src="https://i.loli.net/2019/12/22/AYOB2uDGrHE8FRT.png" alt="image.png"></p>
<p>在数据解释器中的32Bit栏中修改数值即可修改该图片的”显示“高度，将其修改为750（像素），保存后查看图片：</p>
<p><img src="https://i.loli.net/2019/12/22/LsYE1ptgk6GcvBf.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2019/12/22/yx9w2A3VJsFkUe5.png" alt="image.png"></p>
<p>可以看到这张图片的高度被缩小了，先前添加的文字只剩下一点部分可以看见。</p>
<p>可能有人说了：这不就是剪切吗？</p>
<p>接下来就是与剪切不同的地方了，因为图片的数据还在，只显示了1920*750的部分而已，我们将数值改回去看看会发生什么：</p>
<p><img src="https://i.loli.net/2019/12/22/GcKODThZItPb5UE.gif" alt="pngheight.gif"></p>
<p>将显示大小更改为1920*1000后可以看见原来编辑的信息了。</p>
<h3 id="JPEG图片部分"><a href="#JPEG图片部分" class="headerlink" title="JPEG图片部分"></a>JPEG图片部分</h3><p>这是一张jpg格式的文件，与png图片一样，我们在上面添加文字。</p>
<p><img src="https://i.loli.net/2019/12/22/G6rhTfeRZtpFQYw.png" alt="image.png"></p>
<p><img src="https://i.loli.net/2019/12/22/zaIBlOAH9DMEVUL.png" alt="image.png"></p>
<p>添加完毕后拖入Winhex，显示如下图：</p>
<p><img src="https://i.loli.net/2019/12/22/T4mFuMsjWSIQKvh.png" alt="image.png"></p>
<p>在JPEG格式的文件中，有一个属性是也是显示分辨率，其标识为<code>FF C0</code>，更改下图中绿色的部分即可</p>
<p>（绿色部分为高度，蓝色部分为宽度，均为Big-Endian）</p>
<p><img src="https://i.loli.net/2019/12/22/Tda8HtZPRmLcgbu.png" alt="image.png"></p>
<p>修改高度后的图片如下图（修改方法同PNG修改方法，即在数据解释器中修改数值，不过这里是2个字节，则在16bit栏中更改数字）</p>
<p><img src="https://i.loli.net/2019/12/22/tjluKv81O4RSBGr.gif" alt="jpghight.gif"></p>
<center>更改JPEG图片显示分辨率大小具体操作</center>
以上为图片信息隐藏术，在发送图片的时候请注意要记得勾选**发送原图**哦，不是原图的话图片数据会比原图少，隐藏掉的部分也会消失哦



<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">Winhex破解方法请前往 <a href="/2019/11/24/%E5%AE%9E%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E6%81%A2%E5%A4%8D%E8%BD%AF%E4%BB%B6/">实用的数据恢复软件</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li></ol></div></div><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>一些教程</category>
      </categories>
      <tags>
        <tag>JPG文件</tag>
        <tag>加密传输</tag>
        <tag>小技巧</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Winhex进行数据恢复（3）</title>
    <url>/posts/ea54819e.html</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>现在，你已经学会了简单的修复MBR，迈出了数据恢复的第一步。接下来，我们将了解到 <strong>FAT32</strong> 格式的分区是如何工作的。</p>
<blockquote>
<p><strong>你可以在 <a href="https://im0o.top/winhex-tiku/">https://im0o.top/winhex-tiku/</a> 中查看所有例题文件</strong></p>
</blockquote>
<h1 id="知识点总览"><a href="#知识点总览" class="headerlink" title="知识点总览"></a>知识点总览</h1><ul>
<li>FAT32分区构成</li>
<li>实例：导出损坏分区FAT32中的文件</li>
<li>实例：恢复FAT32分区（手动填写FAT32分区的DBR）</li>
<li>EBR的组成</li>
</ul>
<span id="more"></span>

<h1 id="FAT32-分区的构成"><a href="#FAT32-分区的构成" class="headerlink" title="FAT32 分区的构成"></a>FAT32 分区的构成</h1><p>​    FAT32 文件系统是从微软Windows 95 系统的 OSR2 版本开始使用的，它能够支持大于32MB小于32GB的分区。虽然第三方的格式化程序可以把超过32GB的分区格式化为FAT32，但微软自身的系统不允许将大于32GB的分区格式化为FAT32文件系统。</p>
<p>​    FAT32文件系统由保留扇区（包含DBR以及其备份等），FAT表1，FAT表2，数据区四个部分组成，下图为其结构示意图：</p>
<p><img src="https://image.im0o.top/gitee/img/20210510161528.png" alt="fat32Jiegou"></p>
<h2 id="DBR及其保留扇区"><a href="#DBR及其保留扇区" class="headerlink" title="DBR及其保留扇区"></a>DBR及其保留扇区</h2><p>​    FAT32文件系统的DBR开始于其第一个扇区，由5个部分组成，分别为跳转指令、OEM代号、BPB、引导程序和结束标志，下图为一个完整的FAT32文件系统的DBR。</p>
<p><img src="https://image.im0o.top/gitee/img/20210510161555.png" alt="fat32dbr"></p>
<ol>
<li><h3 id="跳转指令"><a href="#跳转指令" class="headerlink" title="跳转指令"></a>跳转指令</h3><p>跳转指令本身占用2字节，它将程序执行流程跳转到引导程序处。</p>
<p>当前DBR中的<code>EB 58</code>代表汇编语言中的<code>JMP 58</code>。需注意，该指令本身占用了2字节，计算跳转目标地址时应该以该指令的下一字节为基准，所以执行下一条指令应该位于<code>5A</code>处，紧接着跳转指令的是一条空指令NOP(<code>90H</code>)。</p>
<p>由此跳转指令中第二个字节内容可以知道OEM代号与BPB参数的大小，FAT32分区即为90开始向下5行+8个字节（如下图中选中部分）。</p>
<p><img src="https://image.im0o.top/gitee/img/20210510163439.png" alt="BPB"></p>
</li>
<li><h3 id="OEM代号"><a href="#OEM代号" class="headerlink" title="OEM代号"></a>OEM代号</h3><p>这部分占8个字节，其内容有创建该文件系统的OEM厂商具体安排。当前DBR中的OEM代号为<code>MSDOS5.0</code>。</p>
</li>
<li><h3 id="BPB"><a href="#BPB" class="headerlink" title="BPB"></a>BPB</h3><p>FAT32的BPB从DBR的第12（<code>0BH</code>偏移处）个字节开始，占用79字节，记录了有关该文件系统的<strong>重要信息</strong>，其中各个参数的含义为：</p>
<table>
<thead>
<tr>
<th>字节偏移</th>
<th align="center">字段长度（字节）</th>
<th align="center">对应图中参数</th>
<th>字段内容及含义</th>
</tr>
</thead>
<tbody><tr>
<td>0x0B</td>
<td align="center">2</td>
<td align="center"><code>00 02</code></td>
<td>每扇区字节数</td>
</tr>
<tr>
<td>0x0D</td>
<td align="center">1</td>
<td align="center"><code>20</code></td>
<td>每簇扇区数</td>
</tr>
<tr>
<td>0x0E</td>
<td align="center">2</td>
<td align="center"><code>26 00</code></td>
<td>DOS保留扇区数</td>
</tr>
<tr>
<td>0x10</td>
<td align="center">1</td>
<td align="center"><code>02</code></td>
<td>FAT表个数</td>
</tr>
<tr>
<td>0x11</td>
<td align="center">2</td>
<td align="center"><code>00 00</code></td>
<td>未用</td>
</tr>
<tr>
<td>0x13</td>
<td align="center">2</td>
<td align="center"><code>00 00</code></td>
<td>未用</td>
</tr>
<tr>
<td>0x15</td>
<td align="center">1</td>
<td align="center"><code>F8</code></td>
<td>介质描述符（16进制）</td>
</tr>
<tr>
<td>0x16</td>
<td align="center">2</td>
<td align="center"><code>00 00</code></td>
<td>未用</td>
</tr>
<tr>
<td>0x18</td>
<td align="center">2</td>
<td align="center"><code>3F 00</code></td>
<td>每磁道扇区数</td>
</tr>
<tr>
<td>0x1A</td>
<td align="center">2</td>
<td align="center"><code>FF 00</code></td>
<td>磁头数</td>
</tr>
<tr>
<td>0x1C</td>
<td align="center">4</td>
<td align="center"><code>00 30 60 03</code></td>
<td>隐藏扇区</td>
</tr>
<tr>
<td>0x20</td>
<td align="center">4</td>
<td align="center"><code>00 48 20 02</code></td>
<td>该分区的扇区总数</td>
</tr>
<tr>
<td>0x24</td>
<td align="center">4</td>
<td align="center"><code>01 22 00 00</code></td>
<td>每FAT扇区数</td>
</tr>
<tr>
<td>0x28</td>
<td align="center">2</td>
<td align="center"><code>00 00</code></td>
<td>标记</td>
</tr>
<tr>
<td>0x2A</td>
<td align="center">2</td>
<td align="center"><code>00 00</code></td>
<td>版本</td>
</tr>
<tr>
<td>0x2C</td>
<td align="center">4</td>
<td align="center"><code>02 00 00 00</code></td>
<td>根目录首簇号</td>
</tr>
<tr>
<td>0x30</td>
<td align="center">2</td>
<td align="center"><code>01 00</code></td>
<td>文件系统信息扇区号</td>
</tr>
<tr>
<td>0x32</td>
<td align="center">2</td>
<td align="center"><code>06 00</code></td>
<td>DBR备份扇区号</td>
</tr>
<tr>
<td>0x34</td>
<td align="center">12</td>
<td align="center"><code>00 00 00 00 00 00 00 00 00 00 00 00</code></td>
<td>保留</td>
</tr>
<tr>
<td>0x40</td>
<td align="center">1</td>
<td align="center"><code>80</code></td>
<td>BIOS驱动器号</td>
</tr>
<tr>
<td>0x41</td>
<td align="center">1</td>
<td align="center"><code>00</code></td>
<td>未用</td>
</tr>
<tr>
<td>0x42</td>
<td align="center">1</td>
<td align="center"><code>29</code></td>
<td>扩展引导标记</td>
</tr>
<tr>
<td>0x43</td>
<td align="center">4</td>
<td align="center"><code>26 68 E5 DE</code></td>
<td>卷序列号</td>
</tr>
<tr>
<td>0x47</td>
<td align="center">11</td>
<td align="center"><code>20 20 20 20 20 20 20 20 20 20 20</code></td>
<td>卷标</td>
</tr>
<tr>
<td>0x52</td>
<td align="center">8</td>
<td align="center"><code>46 41 54 33 32 20 20 20</code></td>
<td>文件系统类型</td>
</tr>
</tbody></table>
<p>下面对这些参数做详细分析：</p>
<ol>
<li><p><strong>0BH~0CH：每扇区字节数</strong></p>
<p>记录每个逻辑扇区的大小，一般为512字节，但512不是固定值，该值可以由程序定义，合法值包括512、1024、2048和4096字节</p>
</li>
<li><p><strong>0DH：每簇扇区数</strong></p>
<p>每簇扇区数记录着文件系统的簇大小，即由多少个扇区组成一个簇<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup></p>
<p>FAT32最大支持128扇区的簇。</p>
<p>在FAT32文件系统中所有的簇从2开始编号，每个簇都有一个自己的地址编号，并且所有的簇都位于数据区内，在数据区之前是没有簇的。</p>
</li>
<li><p><strong>0EH~0FH：DBR保留扇区数</strong></p>
<p>DBR保留扇区数指DBR本身占用的扇区以及其后保留扇区的总和，也就是说DBR到FAT1之间的扇区总数，也可以说是FAT1的相对地址（相对于DBR）。</p>
</li>
<li><p><strong>10H：FAT表个数</strong></p>
<p>FAT个数描述了该文件系统中有几个FAT表，一般在FAT32文件系统中有2个FAT表，即FAT1和FAT2，FAT2是FAT1的备份。</p>
</li>
<li><p><strong>11H~12H：未用</strong></p>
</li>
<li><p><strong>13H~14H：未用</strong></p>
</li>
<li><p><strong>15H：介质描述符</strong></p>
<p>介质描述符是描述磁盘介质的参数，根据磁盘性质的不同，取不同的值<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>。</p>
</li>
<li><p><strong>16H~17H：未用</strong></p>
</li>
<li><p><strong>18H~19H：每磁道扇区数</strong></p>
<p>这是逻辑C/H/S中的一个参数，其值一般为63。</p>
</li>
<li><p><strong>1AH~1BH：磁头数</strong></p>
<p>这也是逻辑C/H/S中的一个参数，其值一般为255。</p>
</li>
<li><p><strong>1CH~1FH：隐藏扇区数</strong></p>
<p>隐藏扇区数是指本分区之前使用的扇区数，该值与分区表中描述的<strong>该分区的起始扇区号</strong>一致。对于主分区来讲，是MBR到该分区DBR之间的扇区数；对于扩展分区中的逻辑分区而言，是其EBR到DBR之间的扇区数<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>。</p>
</li>
<li><p><strong>20H~23H：扇区总数</strong></p>
<p>扇区总数是指分区的总扇区数，也就是说FAT32分区的大小。</p>
</li>
<li><p><strong>24H~27H：每FAT扇区数</strong></p>
<p>这四个字节用来记录FAT32分区中每个FAT表占用的扇区数。</p>
</li>
<li><p><strong>28H~29H：标志</strong></p>
<p>这两个字节用于表示FAT2是否可用，当其二进制最高位置为1时，表示只有FAT1可用，否则FAT2也可用。</p>
</li>
<li><p><strong>2AH~2BH：版本</strong></p>
<p>这两个字节通常为0。</p>
</li>
<li><p><strong>2CH~2FH：根目录首簇号</strong></p>
<p>分区在格式化FAT32文件系统时，格式化程序会在数据区中指派一个簇作为FAT32根目录区的开始，并把该簇号记录在BPB中。通常斗士把数据区的第一个簇分配给根目录使用，也就是2号簇。</p>
</li>
<li><p><strong>30H~31H：文件系统信息扇区号</strong></p>
<p>FAT32文件系统在DBR的保留扇区安排了一个文件系统信息扇区，用以记录数据区中空闲簇的数量及下一个空闲簇的簇号，该扇区一般在分区的1号扇区，即紧跟DBR后的一个扇区。</p>
</li>
<li><p><strong>32H~33H：DBR备份扇区号</strong></p>
<p>FAT32文件系统在DBR保留扇区中安排了一个DBR的备份，一般在6号扇区，也就是第7个扇区。该备份与原DBR的内容一摸一样，如果原DBR遭到破坏，可以用备份扇区修复。</p>
</li>
<li><p><strong>34H~3FH：保留</strong></p>
</li>
<li><p><strong>40H：BIOS驱动器号</strong></p>
<p>这是BIOS的INT 13H所描述的设备号码，一般把硬盘定义为8xH。</p>
</li>
<li><p><strong>41H：未用</strong></p>
</li>
<li><p><strong>42H：扩展引导标记</strong></p>
<p>扩展引导标记用来确认后面的三个参数是否有效，一般值为29H。</p>
</li>
<li><p><strong>43H~46H：卷序列号</strong></p>
<p>卷序列号是格式化程序在创建系统是生成的一组4个字节的随机数值。</p>
</li>
<li><p><strong>47H~51H：卷标</strong></p>
<p>卷标是由用户在创建文件系统时指定的一个卷的名称，但这是旧系统所记录的位置，现在的系统已经不再使用这个位置记录卷标，而是由一个目录项管理卷标。</p>
</li>
<li><p><strong>52H~59H：文件系统类型</strong></p>
<p>BPB的最后一个参数，直接用ASCII码记录当前分区的文件系统类型。</p>
</li>
</ol>
</li>
<li><h3 id="引导程序"><a href="#引导程序" class="headerlink" title="引导程序"></a>引导程序</h3><p>FAT32的DBR引导程序占用420字节（5AH~1FDH）），在Windows 98之前的系统之下，这段代码负责完成DOS三个系统的装入，在Windows 2000之后的系统中，其负责完成将系统文件NTLDR装入，对于一个没有安装操作系统的分区来讲，这段程序没啥用处…</p>
</li>
<li><h3 id="结束标志"><a href="#结束标志" class="headerlink" title="结束标志"></a>结束标志</h3><p>DBR的结束标志与MBR、EBR的结束标志相同，都是<code>55 AA</code>。</p>
</li>
</ol>
<h2 id="FAT表"><a href="#FAT表" class="headerlink" title="FAT表"></a>FAT表</h2><p>FAT（File Allocation Table）即文件分配表，对于FAT文件系统来讲是非常重要的一个组成部分，其主要作用及特点如下：</p>
<ol>
<li>FAT文件系统一般有2个FAT表，FAT1是活动FAT，FAT2是备份。</li>
<li>FAT1的大小与FAT2相同，因此我们可以通过算出FAT1的大小在FAT2处跳转这么多到达数据区。</li>
<li>FAT表是由FAT表项构成的，我们把FAT表项简称为FAT项，每个FAT项的大小有32位（4字节）。</li>
<li>每个FAT项都有一个固定的编号，这个编号从0开始。也就是说，第一个FAT项为0号FAT项，第二个FAT项为1号FAT项，以此类推。</li>
<li>FAT表的前两个FAT项有专门的用途：0号FAT项用于存放分区所在的介质类型，例如硬盘的类型为“<code>F8</code>”，那么硬盘上分区的FAT表第一个FAT项就以“<code>F8</code>”开始；1号FAT项则用来存储文件系统的肮脏标志，表明文件系统被非法卸载或者磁盘表面存在错误。</li>
<li>分区中每一个簇的适应情况都会映射到FAT表中的唯一一个FAT项。因为0号FAT项和1号FAT项和1号FAT项有特殊用途，无法与数据区中的簇形成映射，因此，数据区中的第一个簇的编号对应FAT表中的2号FAT项，以此类推。</li>
</ol>
<p>总的来说，FAT表是用来表示分区使用情况的一个部分，我们可以通过FAT表来计算FAT分区的大小。</p>
<p><img src="https://image.im0o.top/gitee/img/20210510163953.png" alt="fat1"></p>
<center>上图为FAT32文件系统中的FAT1</center>

<h2 id="数据区"><a href="#数据区" class="headerlink" title="数据区"></a>数据区</h2><ol>
<li><h3 id="数据区的位置"><a href="#数据区的位置" class="headerlink" title="数据区的位置"></a>数据区的位置</h3><p>FAT32的数据区在文件系统中的具体位置是紧跟在FAT2之后的。</p>
<p>以下为详细流程：</p>
<div class="note default no-icon flat"><p>① 系统通过读取MBR中分区表的信息定位到该分区的DBR扇区；</p>
<p>② 读取 DBR 的<code>0EH~0FH</code>偏移处，得到<strong>DBR保留扇区数</strong>的值为38；</p>
<p>③ 读取 DBR 的<code>24H~27H</code>偏移处，得到<strong>FAT表大小</strong>的值为8705；</p>
<p>④ 用<code>DBR保留扇区数+2*FAT表大小</code>，结果等于17448，从DBR向后跳转17448扇区，这里就是数据区的开始。</p>
</div></li>
<li><h3 id="数据区的内容"><a href="#数据区的内容" class="headerlink" title="数据区的内容"></a>数据区的内容</h3><p>FAT32文件系统数据区的内容主要由三个部分组成：根目录、子目录和文件内容。在数据中是以<strong>簇</strong><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>为单位来管理这段空间的。</p>
<p><img src="https://image.im0o.top/gitee/img/20210510164112.png"></p>
<center>FAT32数据区根目录</center></li>
<li><h3 id="目录项"><a href="#目录项" class="headerlink" title="目录项"></a>目录项</h3><p>在FAT32文件系统下，分区根目录下的文件及文件夹的目录项存放在根目录区中，分区子目录下的文件及文件夹的目录项存放在子目录区中，根目录区和子目录区都在数据区中。</p>
<ul>
<li><a name="目录项类型" style=" text-decoration:none;color: black">在FAT32文件系统中，目录项可以分为<strong>4</strong>类：</a></li>
</ul>
<div class="note default no-icon flat"><ul>
<li>点击对应的文字可以直接跳转到对应内容</li>
</ul>
<p><a href="#短文件名" style=" text-decoration:none;">① 短文件名目录项。</a></p>
<p><a href="#长文件名" style=" text-decoration:none;">② 长文件名目录项。</a></p>
<p><a href="#根目录" style=" text-decoration:none;">③ <code>.</code>目录项和<code>..</code>目录项。</a></p>
<p><a href="#卷标" style=" text-decoration:none;">④ 卷标目录项</a></p>
</div>

<p><a name="短文件名" style=" text-decoration:none;color: black"><strong>1）短文件名目录项</strong></a></p>
<p><img src="https://image.im0o.top/gitee/img/20210510164140.png"></p>
<p>上图是一条文件目录项，目录项占32字节，从Winhex中看（默认）是两行数据。</p>
<p>让我们来分析下这条目录项的含义：</p>
<table>
<thead>
<tr>
<th>字节偏移</th>
<th align="center">字段长度（字节）</th>
<th>字段内容及含义</th>
</tr>
</thead>
<tbody><tr>
<td>0x00</td>
<td align="center">8</td>
<td>主文件名</td>
</tr>
<tr>
<td>0x08</td>
<td align="center">3</td>
<td>文件的扩展名</td>
</tr>
<tr>
<td>0x0B</td>
<td align="center">1</td>
<td>文件属性<br />（读写/只读/隐藏/系统/卷标/子目录/存档）</td>
</tr>
<tr>
<td>0x0C</td>
<td align="center">1</td>
<td>未用</td>
</tr>
<tr>
<td>0x0D</td>
<td align="center">1</td>
<td>文件创建时间精确到 10ms 的值</td>
</tr>
<tr>
<td>0x0E</td>
<td align="center">2</td>
<td>文件创建时间，包括时、分、秒</td>
</tr>
<tr>
<td>0x10</td>
<td align="center">2</td>
<td>文件创建日期，包括年、月、日</td>
</tr>
<tr>
<td>0x12</td>
<td align="center">2</td>
<td>文件最近访问日期，包括年、月、日</td>
</tr>
<tr>
<td>0x14</td>
<td align="center">2</td>
<td>文件起始簇号高位（<code>高位簇</code>）</td>
</tr>
<tr>
<td>0x16</td>
<td align="center">2</td>
<td>文件修改时间，包括时、分、秒</td>
</tr>
<tr>
<td>0x18</td>
<td align="center">2</td>
<td>文件修改日期，包括年、月、日</td>
</tr>
<tr>
<td>0x1A</td>
<td align="center">2</td>
<td>文件起始簇号的低位（<code>低位簇</code>）</td>
</tr>
<tr>
<td>0x1C</td>
<td align="center">4</td>
<td>文件大小（字节）</td>
</tr>
</tbody></table>
<ol>
<li><p>00H~07H：主文件名共占<code>8</code>字节，如果文件名（不包含扩展名）用不完8字节，后面用空格填充<sup id="fnref:4"><a href="#fn:4" rel="footnote">4</a></sup>。图中主文件名为<code>IM0O</code>。</p>
<p>另外该位置的第一个字节也用来表示目录项的分配状态，当该字节是<code>00</code>时，表示该目录项从未使用过；当该字节是<code>E5</code>时，表示该目录项曾经使用过，但目前已经被删除。</p>
</li>
<li><p>08H~0AH：文件的扩展名</p>
<p>文件的扩展名共占<code>3</code>字节，文件夹没有扩展名，如果是文件夹的目录项，该位置会被空格填充。图中的扩展名为<code>JPG</code>。</p>
</li>
<li><p>0BH：文件属性<sup id="fnref:5"><a href="#fn:5" rel="footnote">5</a></sup></p>
<p>文件属性占1字节（<code>8bit</code>），可以用来表示文件的各种属性。</p>
</li>
</ol>
<p><a href="#目录项类型" style=" text-decoration:none;">&lt;&lt;返回目录项类型</a></p>
<p><a name="长文件名" style=" text-decoration:none;color: black"><strong>2）长文件名目录项</strong></a></p>
<p><img src="https://image.im0o.top/gitee/img/20210510164350.png"></p>
<p>上图为一个长文件名文件的目录项，图中长文件的文件名为<code>System Volume Info...</code></p>
<p>示例文件名<code>SHUJUHUIFU.txt</code></p>
<blockquote>
<p>在Windows 95开始，文件名”8.3“格式的限制被打破了，文件名可以超过8个字符，并且可以使用中文了，扩展名也可以超过3字节，这种格式的文件名就称为长文件名。</p>
<p>在Windows 95以上的系统中，长文件名实际存储着两个名字，一个短文件名和一个长文件名。当创建一个长文件名时，其对应的短文件名有以下3个处理原则。</p>
</blockquote>
<div class="note warning no-icon flat"><ul>
<li>系统取长文件名的前6个字符加上<code>~1</code>形成短文件名，其扩展名不变；</li>
</ul>
<blockquote>
<p>图中取前六个字符<code>SHUJUH</code></p>
</blockquote>
<ul>
<li>如果已存在这个名字的文件，则符号<code>~</code>后的数字自动增加；</li>
</ul>
<blockquote>
<p>例如：<code>SHUJUH~1TXT</code>与<code>SHUJUH~2TXT</code></p>
</blockquote>
<ul>
<li>如果有DOS和Windows 3.x非法的字符，则以下划线<code>_</code>替代。</li>
<li>每个长文件名目录项也占用32字节，一个目录项作为长文件名目录项使用时，其属性字节值为0FH，能够存储13个字符，如果文件名很长，一个长文件名就需要多个目录项，这些目录项按<strong>倒序排列</strong>在其短文件名目录项之前。</li>
</ul>
<blockquote>
<p>如图中标明的顺序</p>
</blockquote>
</div>

<table>
<thead>
<tr>
<th>字节偏移</th>
<th align="center">字段长度（字节）</th>
<th>字段内容及含义</th>
</tr>
</thead>
<tbody><tr>
<td>0x00</td>
<td align="center">1</td>
<td>序列号</td>
</tr>
<tr>
<td>0x01</td>
<td align="center">10</td>
<td>文件名的第1~5个Unicode码字符</td>
</tr>
<tr>
<td>0x0B</td>
<td align="center">1</td>
<td>长文件名目录项的属性标志</td>
</tr>
<tr>
<td>0x0C</td>
<td align="center">1</td>
<td>保留未用</td>
</tr>
<tr>
<td>0x0D</td>
<td align="center">1</td>
<td>短文件名校验</td>
</tr>
<tr>
<td>0x0E</td>
<td align="center">12</td>
<td>文件名的第6~11个Unicode码字符</td>
</tr>
<tr>
<td>0x1A</td>
<td align="center">2</td>
<td>始终为0</td>
</tr>
<tr>
<td>0x1C</td>
<td align="center">2</td>
<td>文件名的第12~13个Unicode码字符</td>
</tr>
</tbody></table>
<hr>
<ul>
<li><ol>
<li>序列号(00)</li>
</ol>
<p>序列号占1字节，该参数用来描述长文件名目录项的排序。</p>
<p>在这个字节的8位中，0~4这5位用来描述长文件名目录项的顺序号，从1开始编号。6位（也就是说第7位）如果“1”表明该目录项是最后一项。如果文件删除，该字节也会改为<code>E5</code>。</p>
</li>
<li><ol start="2">
<li>  文件名的第1~5个Unicode码字符</li>
</ol>
<p>该参数长度为10字节（因为Unicode编码储存字符时每个字符占用2字节）。</p>
<p>如果文件名已经记录完，但该参数的空间中还有未用的字节，就会在文件名最后一个字节填充2个字节的<code>00</code>，随后未用的字节用<code>FF</code>填充。</p>
</li>
<li><ol start="3">
<li>  长文件名目录项的属性标志</li>
</ol>
<p>该参数长度为1字节，是属性字节。当属性的只读位、隐藏位、系统位、卷标位全为1，其它全为0是，改制就为16进制的<code>0FH</code>，表示该目录项为长文件名记录项。</p>
</li>
<li><ol start="4">
<li>未用</li>
</ol>
<p>该字节不使用。</p>
</li>
<li><ol start="5">
<li>短文件名校验和</li>
</ol>
<p>该参数长度为 1 字节，是个校验和，长文件名目录项通过这个校验和将其与相应的短文件名目录项关联起来。校验和的数值是使用短文件名计算得到，同 文件的长文件名目录项的校验和必须是相 向的。校验和的计算方法是依次将短文件名的各个字符对应的二进制值相加，在每一步相加前要先将二进制的结果值依次向右移动一位，最右边的位循环移动到最左边，然后再加上下一个字符所对应的二进制值，直到把最后一个字符加完，结果就是校验和的数值。</p>
</li>
<li><ol start="6">
<li>文件名的第6~11个字符</li>
</ol>
<p>同[2.]</p>
</li>
</ul>
<p>③号长文件名目录项的首字节为<code>42H</code>，换算为二进制等于<code>01000010</code>，其0~4位的值为<code>00010</code>，说明这是第二个长文件名目录项，6位上的值是<code>1</code>，说明这是最后一项长文件名目录项。</p>
<p>②、③两条长文件名目录项的结构一样，以倒序的方式排列在其短文件名目录项之前，完整地记录了文件名<code>shujuhuifu.txt</code></p>
<p><a href="#目录项类型" style=" text-decoration:none;">&lt;&lt;返回目录项类型</a></p>
<p><strong><a name="长文件名" style=" text-decoration:none;color: black">3）<code>.</code>目录项和<code>..</code>目录项</a></strong></p>
<p>在<strong>子目录</strong>所在的文件目录项区域中，总有两个特殊的目录，它们就是<code>.</code>和<code>..</code></p>
<p>使用DOS命令<code>dir</code>可以看到这两个目录</p>
<p><img src="https://image.im0o.top/gitee/img/20210510170036.png"></p>
<p>① <code>.</code>表示当前目录</p>
<p>② <code>..</code>表示上级目录</p>
<p>在winhex中查看<code>.</code>目录与<code>..</code>目录的目录项：</p>
<p><img src="https://image.im0o.top/gitee/img/20210510170010.png"></p>
<p>其中0x00H<del>0x1FH为<code>.</code>目录的目录项，0x20H</del>0x3FH为<code>..</code>目录的目录项</p>
<p><img src="https://image.im0o.top/gitee/img/202110191227753.png"></p>
<CENTER>图为两个目录项的在模板管理器中的效果</CENTER>
从这两个目录项的实际数据可以得知：

<ol>
<li><code>.</code>目录项所描述的<code>起始簇号</code>是子目录本身所在的簇号。</li>
<li><code>..</code>目录项所描述的<code>起始簇号</code>是上级目录的起始簇号，如果上级目录是根目录，则该值为<code>0</code>。</li>
<li>所有目录的文件大小都是<code>0</code>。</li>
</ol>
<p><a href="#目录项类型" style=" text-decoration:none;">&lt;&lt;返回目录项类型</a></p>
<p><strong><a name="长文件名" style=" text-decoration:none;color: black">4）卷标目录项</a></strong></p>
<p>卷标就是一个分区的名字，可以在格式化分区时创建，也可以随时修改。</p>
<div class="note default no-icon flat"><p>① 对于FAT格式的分区，卷标的长度最多为11字节，若果卷标为中文，则最多支持5个字符。</p>
<p>② 卷标的目录项中不记录簇号和大小。</p>
<p>③ 卷标的目录项中不记录创建时间和最后访问时间，只记录修改时间。</p>
</div>

<p><a href="#目录项类型" style=" text-decoration:none;">&lt;&lt;返回目录项类型</a></p>
</li>
</ol>
<h1 id="实例：导出损坏分区FAT32中的文件"><a href="#实例：导出损坏分区FAT32中的文件" class="headerlink" title="实例：导出损坏分区FAT32中的文件"></a>实例：导出损坏分区FAT32中的文件</h1><ol>
<li><h2 id="导入题目FAT32-19123-vhd后用Winhex打开"><a href="#导入题目FAT32-19123-vhd后用Winhex打开" class="headerlink" title="导入题目FAT32-19123.vhd后用Winhex打开"></a>导入题目<code>FAT32-19123.vhd</code>后用Winhex打开</h2></li>
</ol>
<p><a href="https://im0o.top/winhex-tiku/tiku/main/02-%E5%AF%BC%E5%87%BA%E6%8D%9F%E5%9D%8F%E5%88%86%E5%8C%BAFAT32%E4%B8%AD%E7%9A%84%E6%96%87%E4%BB%B6.html">题库/FAT32-19123</a></p>
<p><img src="https://image.im0o.top/gitee/img/202110191231605.png" alt="fat32.png"></p>
<ol start="2">
<li><h2 id="填写结束标志，跳转到FAT32分区"><a href="#填写结束标志，跳转到FAT32分区" class="headerlink" title="填写结束标志，跳转到FAT32分区"></a>填写结束标志，跳转到FAT32分区</h2></li>
</ol>
<p>首先填写MBR主引导记录所缺失的结束标志<code>55 AA</code>。接着查看分区表中的第一个分区，并跳转到该分区。</p>
<p><img src="https://image.im0o.top/gitee/img/202110191231492.png" alt="image.png"></p>
<p>从残留的DBR中，可以看出该分区为FAT32，其每簇扇区数为<code>32</code></p>
<ol start="3">
<li><h2 id="向下搜索-00"><a href="#向下搜索-00" class="headerlink" title="向下搜索!00"></a>向下搜索<code>!00</code></h2></li>
</ol>
<p>使用快捷键<code>Ctrl+Alt+x</code>向下搜索16进制数值<code>!00</code>（非零），可以搜索到根目录。</p>
<p><img src="https://image.im0o.top/gitee/img/20210510170212.png"></p>
<p>在根目录中发现需要找到的文件，查看其高位簇，低位簇（<code>位置</code>）和大小，导出文件即可</p>
<div class="note warning no-icon flat"><p><code>box.png</code>在3号簇，大小为3,752字节</p>
<p><code>box.txt</code>在4号簇，大小为283字节</p>
</div>

<p>跳转到对应位置后选中对应大小，右键&gt;&gt;编辑&gt;&gt;复制选快&gt;&gt;至新文件</p>
<p><img src="https://image.im0o.top/gitee/img/20210510171025.gif"></p>
<center>导出文件步骤（gif有录制时有点问题）</center>
> 在本题中有一道附加题，即恢复分区2。

<h1 id="实例：恢复FAT32分区（手动填写FAT32分区的DBR）"><a href="#实例：恢复FAT32分区（手动填写FAT32分区的DBR）" class="headerlink" title="实例：恢复FAT32分区（手动填写FAT32分区的DBR）"></a>实例：恢复FAT32分区（手动填写FAT32分区的DBR）</h1><ol>
<li><h2 id="导入题目FAT32-191226-vhd后用Winhex打开"><a href="#导入题目FAT32-191226-vhd后用Winhex打开" class="headerlink" title="导入题目FAT32-191226.vhd后用Winhex打开"></a>导入题目<code>FAT32-191226.vhd</code>后用Winhex打开</h2></li>
</ol>
<p><a href="https://im0o.top/winhex-tiku/tiku/main/03-%E6%81%A2%E5%A4%8DFAT32%E5%88%86%E5%8C%BA%EF%BC%88%E6%89%8B%E5%8A%A8%E5%A1%AB%E5%86%99DBR%EF%BC%89.htmlv">题库/FAT32-191226</a></p>
<ol start="2">
<li><h2 id="填写结束标志55-AA，向下搜索非0，确定分区类型与DBR位置"><a href="#填写结束标志55-AA，向下搜索非0，确定分区类型与DBR位置" class="headerlink" title="填写结束标志55 AA，向下搜索非0，确定分区类型与DBR位置"></a>填写结束标志<code>55 AA</code>，向下搜索非0，确定分区类型与DBR位置</h2></li>
</ol>
<p>打开虚拟磁盘后，我们发现MBR的<strong>分区表</strong>和<strong>结束标志</strong>被清空，首先，填写结束标志<code>55 AA</code>。</p>
<p>保存后重新加载虚拟磁盘，点选到00处，向下搜索非零。</p>
<p>根据FAT32分区的特征：<code>RRaA</code>，可以判断处该扇区前一个扇区为FAT32分区的DBR。</p>
<ol start="3">
<li><h2 id="计算FAT32分区所必须的数值"><a href="#计算FAT32分区所必须的数值" class="headerlink" title="计算FAT32分区所必须的数值"></a>计算FAT32分区所必须的数值</h2><ol>
<li><h3 id="计算FAT32分区保留区大小"><a href="#计算FAT32分区保留区大小" class="headerlink" title="计算FAT32分区保留区大小"></a>计算FAT32分区保留区大小</h3><p>在FAT32分区头部有一部分区域为保留区，在填写DBR时我们需要填写<code>保留区大小</code>值，所以我们需要计算保留区的大小。</p>
<ul>
<li>向下搜索<code>F8FF</code></li>
</ul>
<p><code>F8FF</code>为FAT文件系统中<strong>FAT表</strong>的标识，我们通过找到<strong>FAT表的位置</strong>后将<strong>FAT表位置</strong>减去<strong>DBR位置</strong>得到<strong>保留区大小</strong></p>
<ul>
<li><p>复制FAT表位置 <code>2086</code></p>
</li>
<li><p>复制DBR位置 <code>2048</code></p>
</li>
<li><p>用<strong>FAT表位置</strong>减去<strong>DBR位置</strong>得到<strong>保留区大小</strong>为 <code>38</code></p>
</li>
</ul>
</li>
<li><h3 id="计算FAT32分区FAT表大小"><a href="#计算FAT32分区FAT表大小" class="headerlink" title="计算FAT32分区FAT表大小"></a>计算FAT32分区FAT表大小</h3><p>填写DBR时还需要填写<code>FAT表的大小</code>，那么如何计算FAT表的大小呢？</p>
<ul>
<li><p>记录FAT1的位置<code>2086</code>，向下搜索<code>F8FF</code></p>
<p>FAT1与FAT2的标识符均为F8FF，用<strong>FAT2的位置</strong>减去<strong>FAT1的位置</strong>即可得到<strong>FAT表的大小</strong></p>
</li>
<li><p>记录FAT2的位置<code>27687</code></p>
</li>
<li><p>用<strong>FAT2的位置</strong>减去<strong>FAT1的位置</strong>得到<strong>FAT表的大小</strong>为<code>25601</code></p>
</li>
</ul>
</li>
<li><h3 id="计算FAT32分区每簇扇区数"><a href="#计算FAT32分区每簇扇区数" class="headerlink" title="计算FAT32分区每簇扇区数"></a>计算FAT32分区每簇扇区数</h3><ul>
<li><p>跳转到<strong>数据区</strong></p>
<p>从<strong>FAT2</strong>向后跳转<strong>FAT表大小</strong>即可达到<strong>数据区</strong></p>
</li>
<li><p>记录数据区的位置：<code>53288</code>，该位置为根目录（数据区中的首个扇区）</p>
</li>
<li><p>点击空余处，向下搜索非0，搜索到下一簇的目录，位置为<code>53416</code></p>
</li>
<li><p>用<strong>相邻的子目录的位置</strong>减去<strong>根目录的位置</strong>得到<strong>每簇扇区数</strong>为<code>128</code></p>
</li>
</ul>
</li>
<li><h3 id="计算FAT32分区大小"><a href="#计算FAT32分区大小" class="headerlink" title="计算FAT32分区大小"></a>计算FAT32分区大小</h3><p>得到以上参数后我们就可以计算最后需要填写到DBR内的参数——<strong>分区大小</strong></p>
<p><code>（FAT表大小-1）x128x每簇扇区数+保留区大小</code>即可得到该分区的大小。</p>
<p>需注意，这个大小会比分区时的分区大小稍小一点，不过不影响分区中的文件（除非你用满了整个分区）</p>
<ul>
<li>通过计算，我们得到该<strong>FAT分区的大小</strong>为<code>419430438</code>扇区</li>
</ul>
</li>
</ol>
</li>
<li><h2 id="填写DBR"><a href="#填写DBR" class="headerlink" title="填写DBR"></a>填写DBR</h2><ol>
<li><p>填写<strong>跳转指令</strong><code>EB 58 90</code></p>
<p>在DBR扇区起始处填写FAT32分区的跳转指令</p>
</li>
<li><p>填写<strong>每扇区字节数</strong> <code>512</code></p>
<p>在<code>0x0B</code>处（2字节）填写每扇区字节数，默认为512</p>
</li>
<li><p>填写<strong>每簇扇区数</strong><code>128</code></p>
<p>在<code>0x0D</code>处（1字节）填写每簇扇区数，本题为<code>128</code></p>
</li>
<li><p>填写<strong>保留区大小</strong><code>38</code></p>
<p>在<code>0x0E</code>处（2字节）填写保留区大小，本题为<code>38</code></p>
</li>
<li><p>填写<strong>FAT表个数</strong><code>2</code></p>
<p>在<code>0x10</code>处（4字节）填写FAT表个数，默认为<code>2</code></p>
</li>
<li><p>填写<strong>磁盘介质</strong><code>F8</code></p>
<p>在<code>0x15</code>处（1字节）填写磁盘介质，默认为<code>F8</code></p>
</li>
<li><p>填写<strong>分区位置</strong><code>2048</code></p>
<p>在<code>0x1C</code>处（4字节）填写分区位置，本题为<code>2048</code></p>
</li>
<li><p>填写<strong>分区大小</strong><code>419430438</code></p>
<p>在<code>0x20</code>处（4字节）填写分区大小，本题为<code>419430438</code></p>
</li>
<li><p>填写<strong>FAT表大小</strong><code>25601</code></p>
<p>在<code>0x24</code>处（4字节）填写FAT表大小，本题为<code>25601</code></p>
</li>
<li><p>填写<strong>根目录首簇号</strong><code>2</code></p>
<p>在<code>0x2C</code>处（4字节）填写根目录首簇号，默认为<code>2</code></p>
</li>
<li><p>填写<strong>文件系统标识</strong><code>FAT32(ASCII)</code></p>
<p>在<code>0x52</code>处填写文件系统标识，在ASCII栏处直接填写<code>FAT32</code>即可</p>
</li>
<li><p>填写<strong>结束标志</strong><code>55 AA</code></p>
<p>在扇区结尾处填写<code>55 AA</code>结束标志</p>
</li>
</ol>
<ul>
<li>下图为填写FAT32文件系统DBR全过程。</li>
</ul>
<p><img src="https://image.im0o.top/gitee/img/20210510171900.gif"></p>
<ul>
<li><strong>至此，你已经恢复了分区1</strong></li>
</ul>
</li>
<li><h2 id="从DBR向后跳转分区大小，恢复分区2"><a href="#从DBR向后跳转分区大小，恢复分区2" class="headerlink" title="从DBR向后跳转分区大小，恢复分区2"></a>从DBR向后跳转分区大小，恢复分区2</h2><ul>
<li>恢复分区2的步骤与分区1相同</li>
</ul>
</li>
</ol>
<h1 id="EBR的组成"><a href="#EBR的组成" class="headerlink" title="EBR的组成"></a>EBR的组成</h1><p>在上篇文章中我们了解到了扩展分区的结构，以及其在整个磁盘中的作用。本节我们将了解EBR具体的组成。</p>
<p><img src="https://image.im0o.top/files/202112060911955.png" alt="image-20211206091143875"></p>
<p>可以看到，EBR中含有与MBR主引导记录中相似的分区表，通常最多有两个分区表项。</p>
<p>第一个分区表项类同与MBR主引导记录中的分区表格式，不过需要注意的是：扩展分区中的逻辑分区无法成为活动分区。</p>
<p>第二个分区表项用来链接下一个EBR扇区，下图为一个扩展分区的结构</p>
<p><img src="https://image.im0o.top/files/202112060913146.png" alt="image-20211206091355096"></p>
<p>从上图中可以看出，逻辑分区后无扩展分区的情况时，逻辑分区前的扩展分区无第二个分区表项</p>
<p>分区表项1的作用同等于MBR中的分区表项，所以在这里我们查看分区表项2</p>
<p><img src="https://image.im0o.top/gitee/img/20210510172030.gif"></p>
<p>所谓扩展分区，严格地讲它不是一个实际意义的分区，它仅仅是一个指向下一个用来定义分区的参数的指针，这种指针结构形成一个单向链表。</p>
<p>扩展分区的分区表项2是用来指向下一个EBR的位置与大小。</p>
<p>下图为一个磁盘的 EBR 结构。</p>
<p><img src="https://image.im0o.top/files/202112060917344.jpeg" alt="扩展分区的结构分析"></p>
<p>需要注意的是：EBR 中的位置参数均是以 EBR1（扩展分区的首位置）相对偏移的位置。</p>
<blockquote>
<p><em>图床404 部分图片丢失无法找回 博客已根据现有图片进行部分内容修改 部分无法找回的图片丢失</em></p>
</blockquote>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">分区中的簇：<a href="/blog/document/%E5%88%86%E5%8C%BA%E4%B8%AD%E7%9A%84%E7%B0%87.html">文档</a></span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">磁盘介质描述符：<a href="/blog/document/%E7%A3%81%E7%9B%98%E4%BB%8B%E8%B4%A8%E6%8F%8F%E8%BF%B0%E7%AC%A6.html">文档</a></span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">不过该值不严谨，填写时可以直接填其绝对位置</span><a href="#fnref:3" rev="footnote"> ↩</a></li><li id="fn:4"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">4.</span><span style="display: inline-block; vertical-align: top;">空格在16进制中的数值为<code>20H</code></span><a href="#fnref:4" rev="footnote"> ↩</a></li><li id="fn:5"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">5.</span><span style="display: inline-block; vertical-align: top;">FAT32目录项的文件属性：<a href="/blog/document/FAT32%E7%9B%AE%E5%BD%95%E9%A1%B9%E7%9A%84%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7.html">文档</a></span><a href="#fnref:5" rev="footnote"> ↩</a></li></ol></div></div><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Winhex数据恢复教程</category>
      </categories>
      <tags>
        <tag>Winhex</tag>
        <tag>数据恢复</tag>
        <tag>FAT32</tag>
      </tags>
  </entry>
  <entry>
    <title>实用的数据恢复软件</title>
    <url>/posts/102848cd.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在数据恢复的过程中，我们常常需要使用不同的工具，以下是我常用的数据恢复软件</p>
<blockquote>
<p><strong>DiskGenius</strong></p>
<p><strong>Winhex</strong></p>
<p><strong>R-Studio</strong></p>
</blockquote>
<hr>
<blockquote>
<p>一张写博客时喝的饮料的照片，没啥意义…（元气森林记得打钱啊）</p>
</blockquote>
<p><img src="https://i.loli.net/2019/11/26/5UgYoapGtPij2FC.png" alt="soda.png"></p>
<hr>
<span id="more"></span>

<ul>
<li><h3 id="DiskGenius-专业版"><a href="#DiskGenius-专业版" class="headerlink" title="DiskGenius 专业版"></a>DiskGenius 专业版</h3></li>
</ul>
<div class="post-copyright" style="height:150px">
<div style="width:35%;height:100%;padding:15px;float:left">
<img src="http://www.diskgenius.cn/public/images/logo-dg.jpg" alt="DiskGenius Logo" align="left" />
</div>
<div style="width:65%;padding:10px;float:right;text-align:left">
    <p align="left">
    <strong>软件名称：</strong>DiskGenius
    <br />
    <strong>软件大小：</strong>33.4MB
    <br />
    <strong>更新时间：</strong>2019-11-26
    </p>
</div>
</div>

<hr>
<p>​        <strong>DiskGenius</strong>是一款硬盘分区及数据恢复软件。它是在最初的DOS版的基础上开发而成的。Windows版本的DiskGenius软件，除了继承并增强了DOS版的大部分功能外(少部分没有实现的功能将会陆续加入)，还增加了许多新的功能。如：已删除文件恢复、分区复制、分区备份、硬盘复制等功能。另外还增加了对VMWare、Virtual PC、VirtualBox虚拟硬盘的支持。更多功能正在制作并在不断完善中</p>
<hr>
<p>DG是一款方便的分区工具，支持2种分区结构（MBR与GPT），在专业版的DG中，支持组建RAID等功能。</p>
<blockquote>
<blockquote>
<blockquote>
<ul>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>&#160;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>DiskGenius 破解版下载地址（百度网盘）：链接： <a href="https://eyun.baidu.com/s/3jJ2iEWI">点击下载</a> 密码：im0o</p>
<ul>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li><ul>
<li>&#160;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li>安装密码：im0o.top</li>
</ul>
</blockquote>
<ul>
<li><h3 id="Winhex"><a href="#Winhex" class="headerlink" title="Winhex"></a>Winhex</h3></li>
</ul>
<div class="post-copyright" style="height:150px">
<div style="width:15%;height:100%;padding:20px;float:left">
<img src="http://www.winhex.com/pics/hex.gif" alt="Winhex Logo" align="left" height="70" width="70" />
</div>
<div style="width:85%;padding:10px;float:right;text-align:left">
    <p align="left">
    <strong>软件名称：</strong>Winhex
    <br />
    <strong>软件大小：</strong>8.6MB
    <br />
    <strong>软件版本：</strong>19.6-SR2 x64
    </p>
</div>
</div>

<hr>
<p>​        winhex 是一个专门用来对付各种日常紧急情况的工具。它可以用来检查和修复各种文件、恢复删除文件、硬盘损坏造成的数据丢失等。同时它还可以让你看到其他程序隐藏起来的文件和数据。总体来说是一款非常不错的 16 进制编辑器。得到 ZDNetSoftwareLibrary 五星级最高评价，拥有强大的系统效用。</p>
<hr>
<p>Winhex是主要的数据恢复软件，通过其16进制编辑器，我们可以恢复分区/导出文件等。</p>
<h4 id="注册-Winhex"><a href="#注册-Winhex" class="headerlink" title="注册 Winhex"></a>注册 Winhex</h4><p>点击<strong>菜单栏</strong>中的<strong>帮助</strong>——<strong>注册</strong>，将代码块中的内容粘贴到窗口内即可</p>
<p><img src="https://i.loli.net/2019/11/26/4V8hyXLMSpbAImP.png" alt="regwinhex.png"></p>
<p><img src="https://i.loli.net/2019/11/26/GYD1sm3NiuBLSrF.png" alt="image.png"></p>
<figure class="highlight plaintext"><figcaption><span>Key</span></figcaption><table><tr><td class="code"><pre><span class="line">Name: &quot;WinHex 19.6-SR2&quot;</span><br><span class="line">Addr1: &quot;Specialist License&quot;</span><br><span class="line">Addr2: &quot;Only valid for this version&quot;</span><br><span class="line">Data: &quot;B884E8CE836E7A3EC70F2DA7F0D7B9F8&quot;</span><br><span class="line">Key: &quot;B6E03D26307E5A7700F3F04C8429A25B&quot;</span><br><span class="line">Cksm: &quot;FD37FCFB&quot;</span><br></pre></td></tr></table></figure>

<ul>
<li><h3 id="R-Studio"><a href="#R-Studio" class="headerlink" title="R-Studio"></a>R-Studio</h3></li>
</ul>
<div class="post-copyright" style="height:150px">
<div style="width:15%;height:100%;padding:25px;float:left">
<img src="https://pic.cr173.com/up/2018-3/20183181058455849.png" alt="Winhex Logo" align="left" height="70" width="70" />
</div>
<div style="width:85%;padding:10px;float:right;text-align:left">
    <p align="left">
    <strong>软件名称：</strong>R-Studio
    <br />
    <strong>软件大小：</strong>148MB
    <br />
    <strong>软件版本：</strong>R-STUDIO Network 8.9.173593
    </p>
</div>
</div>

<hr>
<p>R-Studio是一个功能强大、节省成本的反删除和数据恢复软件系列。它采用独特的数据恢复新技术，为恢复FAT12/16/32、NTFS、NTFS5（由 Windows 2000/XP/2003/Vista/Windows 8/Windows 10创建或更新）、Ext2FS/Ext3FS（OSX LINUX 文件系统）以及 UFS1/UFS2（FreeBSD/OpenBSD/NetBSD文件系统）分区的文件提供了最为广泛的数据恢复解决方案。为用户挽回数据，减少数据丢失造成的损失。</p>
<hr>
<p>通过配合R-Studio的扫描，可以找到误Ghost前的分区碎片，以便于恢复其他分区。（也可以扫描全盘导出文件）</p>
<p><img src="https://i.loli.net/2019/11/26/JybzmGpkIrQYC7q.png" alt="image.png"></p>
<blockquote>
<p>R-Studio 注册版下载（百度网盘）：链接：<a href="https://eyun.baidu.com/s/3dGJnO45">https://eyun.baidu.com/s/3dGJnO45</a> 密码：im0o</p>
</blockquote>
<p><img src="https://i.loli.net/2019/11/26/h1z8lpmetKf9DqS.png" alt="image.png"></p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>Winhex</tag>
        <tag>数据恢复</tag>
        <tag>DiskGenius</tag>
        <tag>R-Studio</tag>
      </tags>
  </entry>
  <entry>
    <title>Winhex数据恢复题库</title>
    <url>/posts/3df005df.html</url>
    <content><![CDATA[<div class="note warning modern"><p>由于 Baklib 不再内测，不再对题库进行支持，该题库不再更新，并且内容随时可能丢失</p>
<p>新题库请前往 <a href="https://im0o.top/winhex-tiku/">https://im0o.top/winhex-tiku/</a> 查看</p>
</div>

<center><h1>&emsp;题库地址</h1></center>

<blockquote>
<p>感谢 Baklib.com 提供的免费文档站点</p>
<p>访问该站点需要输入题库密码，密码即为博客主页链接（不含http://）</p>
</blockquote>
<h2 id="教程例题"><a href="#教程例题" class="headerlink" title="教程例题"></a>教程例题</h2><ul>
<li><strong><a href="http://winhex.baklib.com/38fe">点击访问</a></strong></li>
</ul>
<h2 id="其他题目"><a href="#其他题目" class="headerlink" title="其他题目"></a>其他题目</h2><ul>
<li><strong><a href="http://winhex.baklib.com/d51b">点击访问</a></strong></li>
</ul>
<h2 id="题库密码"><a href="#题库密码" class="headerlink" title="题库密码"></a>题库密码</h2><ul>
<li><pre><code>因baklib服务器宕机，题库关闭。新题库请前往文章：
</code></pre>
</li>
</ul>
<blockquote>
<p>题库使用方法请点击<code>阅读全文</code>进行查看</p>
</blockquote>
<span id="more"></span>

<h2 id="题库使用方法"><a href="#题库使用方法" class="headerlink" title="题库使用方法"></a>题库使用方法</h2><ol>
<li><p>在**<a href="winhex.baklib.com">Baklib题库</a>**下载题目</p>
</li>
<li><p>打开Windows磁盘管理（右键<code>计算机</code>点击管理）</p>
</li>
</ol>
<p><img src="https://i.loli.net/2019/12/03/v4aBVJGjsk3trYb.png" alt="image.png"></p>
<ol start="3">
<li>右键磁盘管理，点击附加 VHD</li>
</ol>
<p><img src="https://i.loli.net/2019/12/03/b8j3GtA4rS5WQiz.png" alt="image.png"></p>
<ol start="4">
<li>选择对应的题目路径</li>
</ol>
<p><img src="https://i.loli.net/2019/12/03/CA9xQthdBZsLIDk.png" alt="image.png"></p>
<p>附加VHD后即可打开Winhex，选择对应的虚拟磁盘进行数据恢复。</p>
<ol start="5">
<li>做题后分离VHD文件</li>
</ol>
<p><strong>VHD为虚拟磁盘文件，在虚拟磁盘的分区中存放的文件实际将占用VHD文件的大小（动态扩展）</strong></p>
<p><img src="https://i.loli.net/2019/12/03/TuaK4gpAFiY5L28.png" alt="image.png"></p>
<p>右键磁盘，点击分离VHD即可，如果您不希望题目占用您的存储空间，在分离时可以勾选<code>删除磁盘后删除虚拟磁盘文件</code>选项以快捷删除VHD文件</p>
<p><img src="https://i.loli.net/2019/12/03/o6BMCeFEkzVycO5.png" alt="image.png"></p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Winhex数据恢复教程</category>
      </categories>
      <tags>
        <tag>Winhex</tag>
        <tag>baklib</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Winhex进行数据恢复（2）</title>
    <url>/posts/52e8e6fb.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在上一篇文章后，我们了解到了Winhex是什么，以及Winhex的快捷键等。</p>
<p>本篇，我们将正式使用Winhex进行简单的分区恢复。</p>
<blockquote>
<p><strong>你可以在 <a href="https://im0o.top/winhex-tiku/">https://im0o.top/winhex-tiku/</a> 中查看所有例题文件</strong></p>
</blockquote>
<h2 id="知识点总览"><a href="#知识点总览" class="headerlink" title="知识点总览"></a>知识点总览</h2><ul>
<li>Winhex 窗口使用介绍</li>
<li>实例：填写MBR</li>
<li>什么是 DBR</li>
<li>主分区与扩展分区</li>
</ul>
<span id="more"></span>

<h2 id="Winhex窗口使用介绍"><a href="#Winhex窗口使用介绍" class="headerlink" title="Winhex窗口使用介绍"></a>Winhex窗口使用介绍</h2><p><img src="https://image.im0o.top/gitee/img/20200518145242.png"></p>
<ul>
<li><h3 id="文件类功能"><a href="#文件类功能" class="headerlink" title="文件类功能"></a>文件类功能</h3></li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>功能名称</strong></th>
<th align="center"><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>新建</strong></td>
<td align="center">新建一个文件（可以自定义大小，导出文件时可以自定义扩展名）</td>
</tr>
<tr>
<td align="center"><strong>打开</strong></td>
<td align="center">打开一个文件</td>
</tr>
<tr>
<td align="center"><strong>保存</strong></td>
<td align="center">保存更改</td>
</tr>
<tr>
<td align="center"><strong>创建磁盘镜像</strong></td>
<td align="center">为一个分区/磁盘创建镜像</td>
</tr>
<tr>
<td align="center"><strong>打印</strong></td>
<td align="center">将范围内的二进制数据导出为*.xps格式的文档</td>
</tr>
<tr>
<td align="center"><strong>属性</strong></td>
<td align="center">查看一个文件的属性</td>
</tr>
<tr>
<td align="center"><strong>打开文件夹</strong></td>
<td align="center">打开一个文件夹进行编辑</td>
</tr>
</tbody></table>
<ul>
<li><h3 id="编辑类功能"><a href="#编辑类功能" class="headerlink" title="编辑类功能"></a>编辑类功能</h3></li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>功能名称</strong></th>
<th align="center"><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>撤销</strong></td>
<td align="center">撤销上一次的操作</td>
</tr>
<tr>
<td align="center"><strong>复制选区</strong></td>
<td align="center">复制选定的区域</td>
</tr>
<tr>
<td align="center"><strong>粘贴选区</strong></td>
<td align="center">将刚刚复制的内容粘贴</td>
</tr>
<tr>
<td align="center"><strong>写入剪贴板</strong></td>
<td align="center">将剪贴板的数据写入</td>
</tr>
<tr>
<td align="center"><strong>叠加扇区</strong></td>
<td align="center">叠加扇区</td>
</tr>
<tr>
<td align="center"><strong>修改数据</strong></td>
<td align="center">对选定的数据批量操作<del><strong>（动刀子）</strong></del></td>
</tr>
</tbody></table>
<ul>
<li><h3 id="查找类功能"><a href="#查找类功能" class="headerlink" title="查找类功能"></a>查找类功能</h3></li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>功能名称</strong></th>
<th align="center"><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>同步搜索</strong></td>
<td align="center">高级搜索</td>
</tr>
<tr>
<td align="center"><strong>查找文本</strong></td>
<td align="center">查找ASCII/Unicode等其他格式的文本</td>
</tr>
<tr>
<td align="center"><strong>查找十六进制数值</strong></td>
<td align="center">查找16进制格式的数值</td>
</tr>
<tr>
<td align="center"><strong>替换文本</strong></td>
<td align="center">查找并替换ASCII/Unicode等其他格式的文本</td>
</tr>
<tr>
<td align="center"><strong>替换十六进制数值</strong></td>
<td align="center">查找并替换16进制格式的数值</td>
</tr>
</tbody></table>
<ul>
<li><h3 id="跳转类功能"><a href="#跳转类功能" class="headerlink" title="跳转类功能"></a>跳转类功能</h3></li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>功能名称</strong></th>
<th align="center"><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>转到偏移量</strong></td>
<td align="center">转到相对位置</td>
</tr>
<tr>
<td align="center"><strong>跳至扇区</strong></td>
<td align="center">转到绝对位置</td>
</tr>
<tr>
<td align="center"><strong>向前</strong></td>
<td align="center">转到上一个光标所在的位置</td>
</tr>
<tr>
<td align="center"><strong>向后</strong></td>
<td align="center">转到后一个光标所在的位置</td>
</tr>
</tbody></table>
<ul>
<li><h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3></li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>功能名称</strong></th>
<th align="center"><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>打开磁盘</strong></td>
<td align="center">在Winhex中打开一个磁盘/分区进行编辑</td>
</tr>
<tr>
<td align="center"><strong>克隆磁盘</strong></td>
<td align="center">克隆一个磁盘</td>
</tr>
<tr>
<td align="center"><strong>打开RAM</strong></td>
<td align="center">打开RAM内存</td>
</tr>
<tr>
<td align="center"><strong>计算器</strong></td>
<td align="center">打开计算机基带软件——计算器</td>
</tr>
<tr>
<td align="center"><strong>分析选快</strong></td>
<td align="center">分析选中的区域</td>
</tr>
<tr>
<td align="center"><strong>进行磁盘快照</strong></td>
<td align="center">对磁盘进行<a href="https://baike.baidu.com/item/%E7%A3%81%E7%9B%98%E5%BF%AB%E7%85%A7">磁盘快照</a></td>
</tr>
<tr>
<td align="center"><strong>Mount as Drive Letter</strong></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">(空)</td>
<td align="center"></td>
</tr>
</tbody></table>
<ul>
<li><h3 id="设置项"><a href="#设置项" class="headerlink" title="设置项"></a>设置项</h3></li>
</ul>
<table>
<thead>
<tr>
<th align="center"><strong>功能名称</strong></th>
<th align="center"><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>常规设置</strong></td>
<td align="center">打开常规设置菜单</td>
</tr>
<tr>
<td align="center"><strong>目录浏览器</strong></td>
<td align="center">打开目录浏览器设置菜单</td>
</tr>
<tr>
<td align="center"><strong>减小一列</strong></td>
<td align="center">减小16进制编辑器中显示的一列（默认16列，不会更改分区/磁盘大小）</td>
</tr>
<tr>
<td align="center"><strong>增大一列</strong></td>
<td align="center">增加16进制编辑器中显示的一列</td>
</tr>
<tr>
<td align="center"><strong>内容</strong></td>
<td align="center">Winhex帮助，打开时会提示“是否打开”</td>
</tr>
</tbody></table>
<ul>
<li><h3 id="工具：数据解释器"><a href="#工具：数据解释器" class="headerlink" title="工具：数据解释器"></a>工具：数据解释器</h3></li>
</ul>
<div class="post-copyright" style="height:150px">
<div style="width:30%;height:100%;padding:15px;float:left">
<img src="https://image.im0o.top/gitee/img/20200518145424.png" alt="数据解释器" align="left" />
</div>
<div style="width:70%;padding:20px;float:right;text-align:left">
    <p align="left">
    数据解释器是Winhex中比较重要的一个工具，你可以通过点击某字节/某字节组的头看到这（几）个字节的数值大小。
    </p>
</div>
</div>

<ul>
<li><strong>如何打开数据解释器？</strong></li>
</ul>
<p>在WinHex中，数据解释器默认会一直存在，如果你不小心关闭了它，可以在【查看】–【显示】–【数据解释器】中打开它（如图）</p>
<p><img src="https://image.im0o.top/gitee/img/20200518145636.png"></p>
<ul>
<li><strong>使用数据解释器</strong></li>
</ul>
<p><img src="https://image.im0o.top/gitee/img/20200518145710.gif"></p>
<p>如图，黄色部分则为16进制（Little-Endian）数值，红色部分则为前方黄色部分的数值，FF则为例子填充。</p>
<p>当点击字节时，数据解释器默认会以Little-Endian显示从光标开始（包括光标所在字节）向后3个字节的数值大小，8Bit栏为1个字节，16Bit栏为2个字节，32Bit栏为4个字节。</p>
<p>数据解释器可以在【选项】–【数据解释器】中修改（快捷键：Alt+F5）</p>
<p><img src="https://image.im0o.top/gitee/img/20200518150232.png"></p>
<p>打开后的界面如下：</p>
<p><img src="https://image.im0o.top/gitee/img/20200518150324.png"></p>
<h2 id="实例：填写MBR"><a href="#实例：填写MBR" class="headerlink" title="实例：填写MBR"></a>实例：填写MBR</h2><ol>
<li><h3 id="导入题目-MBR-vhd-后使用Winhex打开："><a href="#导入题目-MBR-vhd-后使用Winhex打开：" class="headerlink" title="导入题目 MBR.vhd 后使用Winhex打开："></a>导入题目 <code>MBR.vhd</code> 后使用Winhex打开：</h3></li>
</ol>
<p>MBR.vhd <sup id="fnref:0"><a href="#fn:0" rel="footnote">0</a></sup></p>
<p><img src="https://image.im0o.top/gitee/img/20200518153557.png"></p>
<ol start="2">
<li><h3 id="填写0扇区中的结束标志：55-AA"><a href="#填写0扇区中的结束标志：55-AA" class="headerlink" title="填写0扇区中的结束标志：55 AA"></a>填写0扇区中的结束标志：<code>55 AA</code></h3></li>
</ol>
<p>观察0扇区后面的几个扇区，发现是这个虚拟磁盘的分区结构是<strong>MBR分区结构</strong></p>
<p>填写完结束标志后保存并关闭，重新打开虚拟磁盘</p>
<p><img src="https://image.im0o.top/gitee/img/20200518153635.png"></p>
<ol start="3">
<li><h3 id="寻找第一个分区"><a href="#寻找第一个分区" class="headerlink" title="寻找第一个分区"></a>寻找第一个分区</h3></li>
</ol>
<p>可以通过多种方法寻找到第一个分区，这里举例两种方法：</p>
<h4 id="通过位置管理器跳转到第一个分区"><a href="#通过位置管理器跳转到第一个分区" class="headerlink" title="通过位置管理器跳转到第一个分区"></a>通过位置管理器跳转到第一个分区</h4><p>​        如果你能够像图中在位置管理器中看到第一个分区，可以直接点击该分区跳转到该分区的DBR处</p>
<h4 id="通过搜索结束标志"><a href="#通过搜索结束标志" class="headerlink" title="通过搜索结束标志"></a>通过搜索结束标志</h4><p>​        你可以搜索每个扇区结尾2字节的<code>55 AA</code>（结束标志）来找到分区的DBR，如果<code>55 AA</code>被删除了，就无法通过该方法找到DBR</p>
<h4 id="通过搜索非零"><a href="#通过搜索非零" class="headerlink" title="通过搜索非零"></a>通过搜索非零</h4><p>​        你可以在MBR主引导记录后的空闲扇区中向下搜索<code>!00</code>（非零）找到DBR，在本例题中，你需要进行搜索非零或直接通过导航跳转。</p>
<h3 id="记录DBR的信息"><a href="#记录DBR的信息" class="headerlink" title="记录DBR的信息"></a>记录DBR的信息</h3><p>打开<u>记事本</u>，记录DBR的信息，一般的记录格式为：</p>
<p><code>| 分区类型</code><sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup><code>| 分区地址 | 分区大小 |</code></p>
<p>如果该分区是 <strong>FAT32</strong> 类型，则记录格式为：</p>
<p><code>| 分区类型 | 分区地址 | 分区大小 | 保留区大小 | FAT表大小 | 每簇扇区数 |</code></p>
<p>如果该分区是扩展分区<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>，则记录格式为：</p>
<p><code>| 分区类型（05） | EBR地址 | 分区类型 | ……（同上）</code></p>
<blockquote>
<p><strong>记录格式只是为了方便分区的恢复与数据的填写，这玩意……怎么顺手怎么来吧。</strong></p>
</blockquote>
<hr>
<h4 id="查看该分区的位置与大小"><a href="#查看该分区的位置与大小" class="headerlink" title="查看该分区的位置与大小"></a>查看该分区的位置与大小</h4><p>​    <img src="https://image.im0o.top/gitee/img/20200518155429.png"></p>
<p>如上图，在黄色标记处为该分区的绝对位置，红色标记处为该分区的大小，通过点击4个字节中的第一个字节，可以在数据解释器中看到位置和大小的数据。图中的分区为NTFS分区，其位置的16进制数值为<code>00 08 00 00</code>；其分区大小数值为<code>FF 07 A0 00</code>，换算为Big-Endian为<code>00 00 08 00</code> 和<code>00 A0 07 FF</code>其值为<code>2048</code> 和<code>10487807</code>。</p>
<h4 id="填写数值"><a href="#填写数值" class="headerlink" title="填写数值"></a>填写数值</h4><p>将刚刚找到的数值填入记事本（如下图）</p>
<p><img src="https://image.im0o.top/gitee/img/20200518155626.png"></p>
<p>接着，从该分区的 DBR 向后跳转其分区大小<code>10487807</code>即可转到该分区的备份</p>
<p>下图为该分区跳转示意图</p>
<p><img src="https://image.im0o.top/gitee/img/20200518155703.png"></p>
<p>由跳转图我们可以知道，NTFS分区DBR中描述的分区大小不包括NTFS分区的备份，所以最后填写到MBR主引导记录中的分区大小要比记录的大小+1</p>
<p>在第一个分区的备份后即为第二个分区的DBR，重复上述的步骤，得到以下数据。</p>
<p><img src="https://image.im0o.top/gitee/img/20200518155726.png"></p>
<ol start="5">
<li><h3 id="填写MBR"><a href="#填写MBR" class="headerlink" title="填写MBR"></a>填写MBR</h3></li>
</ol>
<p>跳转到0扇区后，填写主引导记录中的分区表。</p>
<p><img src="https://image.im0o.top/gitee/img/20200518155849.png"></p>
<p>在填写分区表前，我们需要了解分区表结构：</p>
<table>
<thead>
<tr>
<th align="center">字节偏移</th>
<th align="center">字段长度</th>
<th align="center">值</th>
<th align="left">字段名定义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x01BE</td>
<td align="center">1字节</td>
<td align="center">0x80</td>
<td align="left">引导标志：指明该分区是否为活动分区</td>
</tr>
<tr>
<td align="center">0x01BF</td>
<td align="center">1字节</td>
<td align="center">0x20</td>
<td align="left">开始磁头</td>
</tr>
<tr>
<td align="center">0x01C2</td>
<td align="center">1字节</td>
<td align="center">0x07</td>
<td align="left"><strong>分区类型描述</strong></td>
</tr>
<tr>
<td align="center">0x01C6</td>
<td align="center">4字节</td>
<td align="center">0x00008000</td>
<td align="left"><strong>分区起始扇区</strong></td>
</tr>
<tr>
<td align="center">0x01CA</td>
<td align="center">4字节</td>
<td align="center">0x0C800800</td>
<td align="left"><strong>分区大小</strong></td>
</tr>
</tbody></table>
<p>实际需要填写的内容为上表中加粗的部分，将记事本中的内容填入分区表。</p>
<p>填完之后的效果：</p>
<p><img src="https://image.im0o.top/gitee/img/20200518155952.png"></p>
<p>Ctrl+S保存后进入计算机管理——存储——磁盘管理中刷新虚拟分区</p>
<p>如果你看到的是图中的效果，那么恭喜你，你成功恢复了这4个分区</p>
<p><img src="https://image.im0o.top/gitee/img/20200518160022.png"></p>
<h2 id="什么是DBR"><a href="#什么是DBR" class="headerlink" title="什么是DBR"></a>什么是DBR</h2><p>DBR（DOS BOOT RECORD），分区引导扇区，是由FORMAT高级格式化命令写到该扇区的内容，DBR是由硬盘的MBR装载的程序段。DBR装入内存后，即开始执行该引导程序段，其主要功能是完成操作系统的自举并将控制权交给操作系统。每个分区都有引导扇区，但只有被设为活动分区的DBR才会被MBR装入内存运行。</p>
<hr>
<p>DBR一般位于一个分区的分区头，是这个分区的开始。各个分区的DBR结构也会有所不同，若将分区的DBR删除，则系统将无法识别这个分区（即会显示为RAW）</p>
<p>一般情况下，分区的DBR会有其备份，例：</p>
<table>
<thead>
<tr>
<th>分区类型</th>
<th>备份偏移地址</th>
</tr>
</thead>
<tbody><tr>
<td>NTFS</td>
<td>分区结束后1个扇区</td>
</tr>
<tr>
<td>FAT32</td>
<td>DBR后6个扇区</td>
</tr>
<tr>
<td>ExFAT</td>
<td>DBR后12个扇区</td>
</tr>
</tbody></table>
<hr>
<p>图为FAT32从DBR向后跳转了6个扇区到达备份</p>
<p><img src="https://image.im0o.top/gitee/img/20200518160048.gif"></p>
<h2 id="主分区与扩展分区"><a href="#主分区与扩展分区" class="headerlink" title="主分区与扩展分区"></a>主分区与扩展分区</h2><h3 id="主分区"><a href="#主分区" class="headerlink" title="主分区"></a>主分区</h3><p>MBR磁盘的分区形式一般有3种：主分区，扩展分区和非DOS分区<sup id="fnref:3"><a href="#fn:3" rel="footnote">3</a></sup>。主分区又被称为主DOS分区，目前也称为主磁盘分区。</p>
<p>为了便于用户对磁盘的管理，操作系统引用了分区的概念，即将一块磁盘逻辑划分为几个区域。在分区表的64字节中，以16个字节为一个分区表项来描述一个分区的结构。</p>
<p>一块硬盘中可以有多个主磁盘分区，被激活的主磁盘分区称为活动分区，活动分区在一块分区中只能有一个。</p>
<p><img src="https://image.im0o.top/gitee/img/20200518160157.png"></p>
<h3 id="扩展分区"><a href="#扩展分区" class="headerlink" title="扩展分区"></a>扩展分区</h3><p>在了解扩展分区之前，我们先看看MBR中分区表的结构：</p>
<p><img src="https://image.im0o.top/gitee/img/20200518160328.png"></p>
<p>图中加黑部分为MBR主引导记录中的分区表，分区表被分为了4个主分区表项，这就意味着，在MBR分区结构中只能存在4个主分区表项，即4个主分区。那我们如何分出4个以上的分区呢？</p>
<p>使用分区工具DiskGenius的快速分区功能，我们可以看到</p>
<p><img src="https://image.im0o.top/gitee/img/20200518160356.png"></p>
<p>可以看到高级设置中分区的最右方有主分区选项，当我们把分区数目选择为4个分区以上时，再视图将所有分区设置为主分区，可以看到这样的效果</p>
<p><img src="https://image.im0o.top/gitee/img/20200518160417.png"></p>
<p>只能将3个分区分配成主分区，剩下两个分区无法设置成分配为主分区，当我们点击确定后，该磁盘将被分成5个分区</p>
<blockquote>
<p><strong>请务必在虚拟磁盘上执行该操作！格式化之前请注意不要格成自己的硬盘，以免造成数据丢失！</strong></p>
</blockquote>
<p>格式化后可以在DiskGenius中看到分区情况</p>
<p><img src="https://image.im0o.top/gitee/img/20200518160518.png"></p>
<p>可以看到虚拟磁盘被分为了3个主分区和一个扩展分区，扩展分区内包含了两个分区。</p>
<p>再在Winhex中打开该虚拟磁盘查看它的分区表</p>
<p><img src="https://image.im0o.top/gitee/img/20200518160538.png"></p>
<p>可以观察到扩展分区的标识符是 <code>0F</code>，通过数据解释器可以看出其大小为<code>41,934,848</code>，约为20GB，即为2个分区（L:和J:）的大小。</p>
<p>接下来跳转到扩展分区的位置，查看它的“DBR”</p>
<p><img src="https://image.im0o.top/gitee/img/20200518160807.png"></p>
<p>可以观察到，扩展分区的“DBR”类似于MBR，拥有分区表，里面指向了两个分区。</p>
<p>由此可见，扩展分区严格意义上并不算是一个分区，它的作用仅仅是指向后面的分区。</p>
<p>因此，我们给扩展分区的“DBR”定义了一个专属的名字：<strong>EBR</strong>（Extended Boot Record）</p>
<p>在扩展分区内的分区也有专属的称呼：逻辑分区</p>
<p>下图为MBR指向扩展分区的流程：</p>
<p><img src="https://image.im0o.top/gitee/img/20200518160929.png"></p>
<div id="footnotes"><hr><div id="footnotelist"><ol style="list-style:none; padding-left: 0;"><li id="fn:0"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">0.</span><span style="display: inline-block; vertical-align: top;">点<a href="https://im0o.top/winhex-tiku/tiku/main/01-%E5%A1%AB%E5%86%99MBR.html">这里</a>访问本题地址</span><a href="#fnref:0" rev="footnote"> ↩</a></li><li id="fn:1"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">1.</span><span style="display: inline-block; vertical-align: top;">点<a href="/blog/document/%E5%90%84%E4%B8%AA%E5%88%86%E5%8C%BA%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%A0%87%E8%AF%86%E7%AC%A6%E6%B1%87%E6%80%BB.html">这里</a>查看（近乎）所有的分区类型标识符</span><a href="#fnref:1" rev="footnote"> ↩</a></li><li id="fn:2"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">2.</span><span style="display: inline-block; vertical-align: top;">扩展分区仅在MBR结构分区中存在，将在以后的教程讲到。</span><a href="#fnref:2" rev="footnote"> ↩</a></li><li id="fn:3"><span style="display: inline-block; vertical-align: top; padding-right: 10px;">3.</span><span style="display: inline-block; vertical-align: top;">一般情况为启动盘</span><a href="#fnref:3" rev="footnote"> ↩</a></li></ol></div></div><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Winhex数据恢复教程</category>
      </categories>
      <tags>
        <tag>Winhex</tag>
        <tag>数据恢复</tag>
        <tag>恢复分区</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Winhex进行数据恢复（1）</title>
    <url>/posts/405d4915.html</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>我看过太多人因为没有做好数据备份或误操作，而把数据丢失的情况。</p>
<p>比如因为病毒的破坏导致文件丢失、打不开、或者成为乱码。</p>
<p>因为某数字安全卫士修复系统漏洞导致电脑无法启动，修复引导后电脑数据硬盘提示需要初始化。</p>
<p>因为一次重装系统，导致所有数据分区被误格式化为一个系统分区等。</p>
<p>本系列教程将介绍如何使用Winhex进行逻辑层面的数据恢复与文件修复。</p>
<blockquote>
<p><strong>你可以在 <a href="https://im0o.top/winhex-tiku/">这里</a> 中查看所有例题文件</strong></p>
<p><strong>你可以在 <a href="/posts/1aa64c01.html">这里</a> 找到该教程的索引</strong></p>
</blockquote>
<h2 id="知识点总览"><a href="#知识点总览" class="headerlink" title="知识点总览"></a>知识点总览</h2><ul>
<li>Winhex 是什么</li>
<li>Winhex 的常用快捷键</li>
<li>MBR主引导记录</li>
<li>windows系统常用的分区简述</li>
</ul>
<span id="more"></span>

<h2 id="Winhex是什么？"><a href="#Winhex是什么？" class="headerlink" title="Winhex是什么？"></a>Winhex是什么？</h2><p>简单来讲，Winhex是一个16进制的窗口型编辑器，它专门用来检查和修复文件、恢复删除文件、硬盘损坏、数码相机卡损坏造成的数据丢失等……</p>
<p>当然，它也能够用来人为损坏文件（笑）</p>
<h2 id="Winhex的常用快捷键"><a href="#Winhex的常用快捷键" class="headerlink" title="Winhex的常用快捷键"></a>Winhex的常用快捷键</h2><p>以下是使用Winhex进行数据恢复时常用的快捷键：</p>
<table>
<thead>
<tr>
<th align="center">快捷键</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>Ctrl+Shift+N</strong></td>
<td align="center">导出（复制）文件</td>
</tr>
<tr>
<td align="center"><strong>Ctrl+Alt+X</strong></td>
<td align="center">查找16进制数值</td>
</tr>
<tr>
<td align="center"><strong>Ctrl+F</strong></td>
<td align="center">查找文本</td>
</tr>
<tr>
<td align="center"><strong>Ctrl+W</strong></td>
<td align="center">关闭当前页面</td>
</tr>
<tr>
<td align="center"><strong>Ctrl+G</strong></td>
<td align="center">跳至扇区</td>
</tr>
<tr>
<td align="center"><strong>Ctrl+C</strong></td>
<td align="center">复制</td>
</tr>
<tr>
<td align="center"><u><strong>Ctrl+B</strong></u></td>
<td align="center">粘贴</td>
</tr>
<tr>
<td align="center"><strong>Ctrl+T</strong></td>
<td align="center">编辑选中内容（异或等）</td>
</tr>
<tr>
<td align="center"><strong>Alt+Tab</strong></td>
<td align="center">切换窗口（Windows快捷键）</td>
</tr>
<tr>
<td align="center"><strong>Alt+G</strong></td>
<td align="center">转到偏移量</td>
</tr>
<tr>
<td align="center"><strong>Enter</strong></td>
<td align="center">打开启动中心</td>
</tr>
<tr>
<td align="center"><strong>F3</strong></td>
<td align="center">继续上一次的搜索</td>
</tr>
</tbody></table>
<h2 id="MBR主引导记录"><a href="#MBR主引导记录" class="headerlink" title="MBR主引导记录"></a>MBR主引导记录</h2><p>MBR主引导记录通常在分区的开头（0扇区处）。其作用为指向分区的DBR/EBR</p>
<p><img src="https://image.im0o.top/gitee/img/202110191218007.png"></p>
<hr>
<h3 id="MBR主引导记录主要有以下部分构成"><a href="#MBR主引导记录主要有以下部分构成" class="headerlink" title="MBR主引导记录主要有以下部分构成"></a><strong>MBR主引导记录主要有以下部分构成</strong></h3><ol>
<li><p><strong>引导程序</strong></p>
<p>引导程序占用MBR的前440字节，其地址在偏移0~偏移1B7H处。</p>
</li>
<li><p><strong>Windows磁盘签名</strong></p>
<p>Windows磁盘标签占用引导程序后的4个字节，是Windows系统对初始化硬盘写入的一个磁盘标签</p>
<blockquote>
<h3 id="Disk-Signature-磁盘签名"><a href="#Disk-Signature-磁盘签名" class="headerlink" title="Disk Signature (磁盘签名)"></a>Disk Signature (磁盘签名)</h3><p>磁盘签名用于在操作系统上标识磁盘。Windows 要求磁盘在使用之前必须有一个签名。将签名写入磁盘后，该磁盘将显示为基本磁盘。</p>
</blockquote>
</li>
<li><p><strong>分区表</strong></p>
<p>偏移1BEH~偏移1FDH的64字节为硬盘分区表，这是MBR分区中非常重要的结构。</p>
</li>
<li><p><strong>结束标志</strong></p>
<p>扇区最后的两个字节“55 AA”是MBR的结束标志，如果丢失了55 AA，计算机将无法识别出MBR</p>
<p>（这也是最简单的故障）。</p>
</li>
</ol>
<p><img src="https://image.im0o.top/gitee/img/202110191219636.png"></p>
<ul>
<li>只有通过分区表才可以指向所有的分区，分区表由以下值构成</li>
</ul>
<table>
<thead>
<tr>
<th align="center">字节偏移</th>
<th align="center">字段长度</th>
<th align="center">值</th>
<th align="left">字段名定义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x01BE</td>
<td align="center">1字节</td>
<td align="center">0x80</td>
<td align="left">引导标志：指明该分区是否为活动分区</td>
</tr>
<tr>
<td align="center">0x01BF</td>
<td align="center">1字节</td>
<td align="center">0x20</td>
<td align="left">开始磁头</td>
</tr>
<tr>
<td align="center">0x01C2</td>
<td align="center">1字节</td>
<td align="center">0x07</td>
<td align="left"><strong>分区类型描述</strong></td>
</tr>
<tr>
<td align="center">0x01C6</td>
<td align="center">4字节</td>
<td align="center">0x00008000</td>
<td align="left"><strong>分区起始扇区</strong></td>
</tr>
<tr>
<td align="center">0x01CA</td>
<td align="center">4字节</td>
<td align="center">0x0C800800</td>
<td align="left"><strong>分区大小</strong></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意</strong>：上表中超过1字节的数据都是以 BIG-ENDIAN（即从低位到高位）的方式显示，因为Windows系统是运行在x86架构之上的，所以在实际存储时是按低位到高位存储的，两者表现不同。</p>
</blockquote>
<blockquote>
<p> <strong>LITTLE-ENDIAN</strong>（小字节序、低字节序）,即低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。 与之对应的是：BIG-ENDIAN（大字节序、高字节序）                     ——百度百科</p>
</blockquote>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>Winhex数据恢复教程</category>
      </categories>
      <tags>
        <tag>Winhex</tag>
        <tag>数据恢复</tag>
        <tag>Windows系统</tag>
      </tags>
  </entry>
  <entry>
    <title>ThownFireball -- 丢出火焰弹</title>
    <url>/posts/566520c1.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>为了增加游戏趣味性，与一直感叹火焰弹为何无法丢出的问题，我利用最近正在学习的Skript插件写出了一个简单的脚本</p>
<p>——ThownFireball</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>当玩家手持火焰弹并Shift右键时会丢出这个火焰弹（效果等同于恶魂吐出的火球，并且可以完成进度/成就“见鬼去吧”（用一个火球打败恶魂）</p>
<p>丢出火球后，玩家会获得虚弱的debuff</p>
<p>（buff时长可以叠加）</p>
<span id="more"></span>

<hr>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">options:</span><br><span class="line">	#冷却时间</span><br><span class="line">	cooldown: 3 seconds</span><br><span class="line">	#虚弱时间</span><br><span class="line">	debufftimes: 5 seconds</span><br><span class="line">on right click with a fire charge:</span><br><span class="line">	if player is sneaking:</span><br><span class="line">		set &#123;_cooldown&#125; to difference between &#123;cd.%player%.fireball&#125; and now</span><br><span class="line">		if &#123;_cooldown&#125; is less than &#123;@cooldown&#125;:</span><br><span class="line">			send action bar &quot;&amp;c&amp;l火焰弹冷却中&quot; to player</span><br><span class="line">			stop</span><br><span class="line">		else:</span><br><span class="line">			remove a fire charge from player&#x27;s inventory</span><br><span class="line">			shoot a fireball from the player with speed 0.001</span><br><span class="line">			apply weakness of tier 2 to the player for &#123;@debufftimes&#125;</span><br><span class="line">			set &#123;cd.%player%.fireball&#125; to now</span><br><span class="line">	else:</span><br><span class="line">		stop</span><br><span class="line">on load:</span><br><span class="line">	send &quot;[ThrownFireball] &amp;b丢出火焰弹 &amp;a已加载&quot; to console</span><br><span class="line">on unload:</span><br><span class="line">	send &quot;[ThrownFireball] &amp;b丢出火焰弹 &amp;c已卸载&quot; to console</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>地址1（百度网盘）</p>
<p>链接：<a href="http://tonancos.com/3efK">http://tonancos.com/3efK</a></p>
<p>密码：im0o</p>
<p>地址2（本地下载）</p>
<p>链接：<a href="http://im0o.top/assets/download/ThrownFireball.sk">http://im0o.top/assets/download/ThrownFireball.sk</a></p>
<p>Q.关于广告</p>
<p>A.作者也是要恰饭的嘛</p>
<hr>
<h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><p>本脚本源码已发布至Minecraft插件百科中的Skript目录内，欢迎查阅。</p>
<p>地址：<a href="http://mineplugin.org/Skript">http://mineplugin.org/Skript</a></p>
<hr>
<h2 id="支持作者"><a href="#支持作者" class="headerlink" title="支持作者"></a>支持作者</h2><p>你可以通过点击下方的“赞赏”按钮来支持我~ 感谢支持</p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>我的Skript旅途</category>
      </categories>
      <tags>
        <tag>Skript</tag>
      </tags>
  </entry>
  <entry>
    <title>GoldenMelon -- 可以吃的金西瓜</title>
    <url>/posts/4018ab83.html</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>在UHC极限生存中，为了简化一些难度，我和朋友商量写出了这个脚本——GoldenMelon</p>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>当右键金西瓜的时候，玩家会获得失明效果与生命恢复效果，并且会消耗1个金西瓜，进入冷却</p>
<p>注：生命恢复效果与失明效果可以设置持续时间，效果可以叠加</p>
<span id="more"></span>

<hr>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">options:</span><br><span class="line">	#单次回血等级</span><br><span class="line">	regain: 2</span><br><span class="line">	#buff持续时间</span><br><span class="line">	time: 2 seconds</span><br><span class="line">	#单次饱食度恢复</span><br><span class="line">	beefs: 1</span><br><span class="line">	#两次之间的冷却</span><br><span class="line">	cooldown: 5 seconds</span><br><span class="line">	#失明时间</span><br><span class="line">	debufftime: 10 seconds</span><br><span class="line"></span><br><span class="line">on right click with a gold melon:</span><br><span class="line">	set &#123;_cd&#125; to difference between &#123;cd.%player%.melon&#125; and now</span><br><span class="line">	if &#123;_cd&#125; is less than &#123;@cooldown&#125;:</span><br><span class="line">		send action bar &quot;&amp;6&amp;l这个食物还在冷却中!&quot; to player</span><br><span class="line">		stop</span><br><span class="line">	else:</span><br><span class="line">		remove a gold melon from player&#x27;s inventory</span><br><span class="line">		apply regeneration of tier &#123;@regain&#125; to the player for &#123;@time&#125;</span><br><span class="line">		apply blindness of tier 2 to the player for &#123;@debufftime&#125;</span><br><span class="line">		feed the player by &#123;@beefs&#125; beefs</span><br><span class="line">		set &#123;cd.%player%.melon&#125; to now</span><br><span class="line">on load:</span><br><span class="line">	send &quot;[GoldenMelon] &amp;e可食用的金西瓜 &amp;a已加载&quot; to console</span><br><span class="line">on unload:</span><br><span class="line">	send &quot;[GoldenMelon] &amp;e可食用的金西瓜 &amp;c已卸载&quot; to console</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>地址1（百度网盘）：</p>
<p>链接：<a href="http://tonancos.com/3efs">http://tonancos.com/3efs</a></p>
<p>密码：im0o</p>
<p>地址2（本地下载）：</p>
<p>链接：<a href="http://im0o.top/assets/download/GoldenMelon.sk">http://im0o.top/assets/download/GoldenMelon.sk</a></p>
<p>Q.关于广告</p>
<p>A.作者也是要恰饭的嘛</p>
<hr>
<h2 id="支持作者"><a href="#支持作者" class="headerlink" title="支持作者"></a>支持作者</h2><p>你可以通过点击下方的“赞赏”按钮来支持我~ 感谢支持</p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <categories>
        <category>我的Skript旅途</category>
      </categories>
      <tags>
        <tag>Skript</tag>
      </tags>
  </entry>
  <entry>
    <title>博客建立</title>
    <url>/posts/1628c517.html</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>你好，欢迎访问0o酱的个人博客，本博客主要用于分享我的一些笔记、教程、记录等。</p>
<p>本博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">知识共享署名-非商业性使用-相同方式共享 4.0 国际许可协议</a> 进行许可，转载请注明出处。</p>
<h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><p>你可以前往本站的<a href="/about/">关于页面</a>查看我的简介。</p>
<h1 id="一些其他的东西"><a href="#一些其他的东西" class="headerlink" title="一些其他的东西"></a>一些其他的东西</h1><p>你可以前往<a href="https://im0o.top/">本站首页</a>找到我的联系方式。</p>
<p>你可以点击菜单栏的<a href="/link/">友情链接</a>查看我的友情链接，如果你需要添加友情链接，请按照页面上的提示填写并联系我。</p>
<p>欢迎前往我的吹水群聊天：<a href="//shang.qq.com/wpa/qunwpa?idkey=ee2df537f7dcb2bd80cfb29b0cfbe532e414105b80dfe4674f6260722922cc6d">点击加群</a></p>
<script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text&#x2F;javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text&#x2F;css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.7.0/dist/mindmap.min.css">]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
